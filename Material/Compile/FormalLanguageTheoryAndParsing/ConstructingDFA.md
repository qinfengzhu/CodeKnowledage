### NFA 构造 DFA

我们通过从输入字符的角度来看它们将NFA状态合并在一起：
    * 从输入的角度来看，通过`ε-transition` 连接的任何两个状态也可以是相同的，因为我们可以从一个移动到另一个而不消耗任何字符。因此,通过`ε-transition`连接的状态将由DFA中的相同状态表示。
    * 如果可以基于相同的符号进行多次转换,那么我们可以将符号上的转换视为从状态移动到一组状态(即,通过当前符号的转换可达到的所有状态的并集)。因此,这些状态将组合成单个DFA状态。
要执行此操作,我们定义两个函数:
    * 所述`ε-closure`函数采用一个状态,并返回该组的状态从它到达基于(一个或多个)`ε-transition`。请注意,这将始终包括状态 tself.我们应该能够在ε不消耗任何输入的情况下从一个状态进入其中的任何状态。
    * 函数`move`接受状态和字符,并返回此字符上一次转换可到达的状态集。
我们可以通过将应用程序联合到各个状态来概括这两个函数以应用于状态集。

例如:如果A,B和C是状态,则移动({A,B,C},"a")=移动(A,"a")U移动(B,"a")U移动(C,"a")

### 子集构造算法

1. 通过获取`ε`NFA的开始状态的`closure`来创建`DFA`的开始状态.
2. 对新的`DFA`状态执行以下操作:
    对于每个可能的输入符号:
    1. 将move移动到新创建的状态和输入符号，这将返回一组状态
    2. 将`ε-closure`应用于这组状态,可能会产生一个新的状态
    这组`NFA`状态将是`DFA`中的单个状态
3. 每次我们生成新的DFA状态时,我们都必须对其应用第2步。当应用步骤2不产生任何新状态时,该过程完成。
4. `DFA`的完成状态是包含`NFA`的任何完成状态的完成状态。
