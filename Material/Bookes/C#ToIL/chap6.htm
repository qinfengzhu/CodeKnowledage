<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./chap6_files/filelist.xml">
<link rel=Edit-Time-Data href="./chap6_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Reference and Value Types - C# to IL</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>4</o:Revision>
  <o:TotalTime>15</o:TotalTime>
  <o:Created>2001-01-24T06:00:00Z</o:Created>
  <o:LastSaved>2001-01-24T06:01:00Z</o:LastSaved>
  <o:Pages>21</o:Pages>
  <o:Words>5184</o:Words>
  <o:Characters>26960</o:Characters>
  <o:Company>VMCI</o:Company>
  <o:Lines>3370</o:Lines>
  <o:Paragraphs>1685</o:Paragraphs>
  <o:CharactersWithSpaces>36292</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Monotype Corsiva";
	panose-1:3 1 1 1 1 2 1 1 1 1;
	mso-font-charset:0;
	mso-generic-font-family:script;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cbullets, li.Cbullets, div.Cbullets
	{mso-style-name:"C\#bullets";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.5pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.5pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=Cbase><b><span style='font-size:9.0pt;mso-bidi-font-size:10.0pt'><img
width=64 height=48 id="_x0000_i1025" src=bpb.jpg><o:p></o:p></span></b></p>

<p class=Cbase><b><span style='font-size:24.0pt;mso-bidi-font-size:10.0pt'>-6-</span></b><span
style='font-size:24.0pt;mso-bidi-font-size:10.0pt;color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase align=center style='text-align:center'><span style='font-size:
24.0pt;font-family:"Monotype Corsiva"'>Reference and Value Types</span><span
style='color:windowtext'><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'>Interfaces</span></i></b><b><span
style='color:windowtext'><o:p></o:p></span></b></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>An interface is a reference
type, in spite of the fact that it has no code at all. Thus, we cannot
instantiate an interface. We can use it as a construct for the creation of new
types. An interface defines a contract that is left to the class to implement. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>An interface can have static
fields. If an interface contains 10 abstract virtual functions, then the class
implementing from that interface has to supply the code for all 10 of them.
Thus, if a class does not provide all the function implementations, then we
cannot use the class. In such a scenario, a class derived from it must provide
the implementation.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The interface keyword in C# is a
class, which the documentation describes as a semantic attribute.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method static void vijay() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We are not allowed to place any
code in an interface. An interface consists only of the function prototype,
followed by a pair of curly braces {}.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method static void vijay() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method static void vijay1() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>***** FAILURE ***** <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>vijay1 is a function created in
the interface yyy. As this is not permitted, the il assembler has the domino
effect as shown above.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method static void vijay() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field int32 i<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>***** FAILURE ***** <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>No variables either can be
placed inside an interface. This rule is similar to that of C#. Even though the
documentation says that we can place static fields in an interface, when we
tried to do so, an error was generated.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method static void vijay() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>newobj instance void yyy::.ctor()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Exception occurred: System.ExecutionEngineException: An
exception of type System.ExecutionEngineException was thrown.<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>If we create an object such as
an interface using newobj, the assembler does not generate any error, but the
runtime throws an exception.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class zzz implements yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method static void vijay() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>} <o:p></o:p></p>

<p class=ILprg>} <o:p></o:p></p>

<p class=ILoutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Exception occurred: System.TypeLoadException: Could not load
class 'zzz' because the method 'a1' is not defined.<o:p></o:p></p>

<p class=ILoutput>Exception occurred: System.MissingMethodException: Could not
find the entry point.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above program has only one
function, a1 in the interface. This function has a pair of curly braces {}, but
as mentioned earlier, we are not allowed to place any code within them. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The class zzz has been derived
from yyy, using the keyword implements. The assembler does not check whether
all code of the interface is implemented as it is done only at runtime, and
hence, an exception is generated. Thus, we can see that most IL errors occur at
run time, and not at compile time.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>interface ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>void a1();<o:p></o:p></p>

<p class=ILprg>void a2();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class public auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a2() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To reiterate what we have said
earlier, an interface in C# becomes a class directive in IL with the interface
modifier added to it. The two functions a1 and a2 become actual functions in
the class ddd, and are marked as virtual, newslot as well as abstract, i.e.
having no implementation.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class public auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a2() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>Error<o:p></o:p></p>

<p class=ILoutput>***** FAILURE ***** <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We cannot place any code,
including a ret, in a method that is marked as abstract. This modifier
signifies that the code for the function will be provided from some other
source. Inspite of what the documentation says, a static constructor cannot be
placed in an interface.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz : ddd,eee {<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>interface ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>interface eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object
implements ddd,eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>For the purposes of inheritance,
C# does not differentiate between an interface and a class. There is, however,
a subtle difference between them in a sense that, we can derive from more than
one interface, but not from more than one class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In IL, there is a marked
differentiation between an interface and a class. We extend from a class and
implement an interface. This is the same syntax that the Java programming
language uses. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>When one compares C# with Java,
their support for features such as these should be highlighted.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz {<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>yyy a = new yyy();<o:p></o:p></p>

<p class=ILprg>ddd d = a;<o:p></o:p></p>

<p class=ILprg>d.a1();<o:p></o:p></p>

<p class=ILprg>a.a1();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>interface ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>void a1();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>class yyy : ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public void a1() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;a1&quot;);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object {<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed {<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (class yyy V_0,class ddd V_1)<o:p></o:p></p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
yyy::.ctor()<o:p></o:p></p>

<p class=ILprg>stloc.0<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>callvirt<span style="mso-spacerun: yes">  </span>instance void
ddd::a1()<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>call instance void yyy::a1()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi yyy extends [mscorlib]System.Object
implements ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot final virtual instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldstr &quot;a1&quot;<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance void
.ctor() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>call instance void [mscorlib]System.Object::.ctor()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>a1<o:p></o:p></p>

<p class=ILoutput>a1<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We created two locals that look
like class yyy and interface ddd. Then, we created an object that looks like
yyy and initialized the variable V_0 to it. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The statement d =a is translated
to: loading the value of V_0 on the stack, and using instruction stloc.1 to
initialize the variable V_1. Thereafter, calling the function a1 of the
interface ddd.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We loaded the variable value V_1
on the stack. Since it was called through the interface, we used callvirt
instead of call. If we had called it through the object of type yyy, then we
would have used call. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, IL understands that a call
through an interface object is to be treated in a special manner. We can change
the last occurrence of ldloc.1 to ldloc.0, since both have the same values. A
call to an interface is evaluated at run time, as the assembler does not
convert it into a class access. In the locals directive, the word class, and
not interface, is placed in front of ddd. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, calling a function through
an interface is equivalent to using callvirt since, there is no code in the
interface. A callvirt takes more time to execute than the plain call
instruction. However, callvirt introduces dynamism at runtime.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ddd d = new yyy();<o:p></o:p></p>

<p class=ILprg>eee e = new yyy();<o:p></o:p></p>

<p class=ILprg>d.a1();<o:p></o:p></p>

<p class=ILprg>e.a1();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>interface ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>void a1();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>interface eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>void a1();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>class yyy : ddd , eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>void ddd.a1() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;ddd a1&quot;);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>void eee.a1() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;eee a1&quot;);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals ( class yyy v , class eee v1)<o:p></o:p></p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
yyy::.ctor()<o:p></o:p></p>

<p class=ILprg>stloc.0<o:p></o:p></p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
yyy::.ctor()<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>callvirt<span style="mso-spacerun: yes">   </span>instance void
ddd::a1()<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>callvirt<span style="mso-spacerun: yes">   </span>instance void
eee::a1()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi yyy extends [mscorlib]System.Object
implements ddd,eee<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method private hidebysig newslot final virtual instance void
ddd.a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.override ddd::a1<o:p></o:p></p>

<p class=ILprg>ldstr &quot;ddd a1&quot;<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method private hidebysig newslot final virtual instance void
eee.a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.override eee::a1<o:p></o:p></p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;eee
a1&quot;<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance void
.ctor() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>call instance void [mscorlib]System.Object::.ctor()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>ddd a1<o:p></o:p></p>

<p class=ILoutput>eee a1<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have created a class yyy that
is derived from two interfaces, ddd and eee, that have the same function a1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Since we want a separate
implementation for each, we have to preface each occurrence of a1 with the name
of the interface, i.e. either<span style="mso-spacerun: yes">  </span>ddd or
eee, in the class yyy. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have created the two objects
that look like yyy and stored them in classes that look like ddd and eee. Since
the function is called from an interface pointer, we have to use callvirt
instead of call. In the IL code, the two interfaces are created as shown
earlier. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In class yyy, we implement from
ddd and eee, but since the two functions cannot have the same name, we have to
preface the name of the function with the name of the interface. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the method, we have used a
directive called .override. This directive<span style="mso-spacerun: yes">  
</span>clearly specifies as to which function from a specified interface the
function override. Calling of an interface is a run time issue. The CLR does
all the routine work.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object {<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed {<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (class xxx V_0,class ddd V_1)<o:p></o:p></p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
xxx::.ctor()<o:p></o:p></p>

<p class=ILprg>stloc.0<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>callvirt<span style="mso-spacerun: yes">  </span>instance void
ddd::a2()<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>call instance void xxx::a2()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface private abstract auto ansi ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a2() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class private auto abstract ansi yyy extends
[mscorlib]System.Object implements ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot final virtual instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldstr &quot;a1&quot;<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual instance void a2() il
managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldstr &quot;a2&quot;<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance void
.ctor() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>call instance void [mscorlib]System.Object::.ctor()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class xxx extends yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot final virtual instance void
a2() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldstr &quot;a22&quot;<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>a2<o:p></o:p></p>

<p class=ILoutput>a22<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above program clears a large
number of cobwebs. Let us start analysing this program from the beginning. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have a class interface ddd
that has two functions a1 and a2. We then create a class yyy, that implements
from ddd and contains<span style="mso-spacerun: yes">  </span>code for only one
function a1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This makes the class incomplete
and hence, we tag it with the modifier abstract. However, this modifier is
optional. One more class xxx is created, that derives from yyy and implements
the second function a2. All goes well so far. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Then, using call,<span
style="mso-spacerun: yes">  </span>the function a2 of class xxx is called.
However, when we call the same function off the interface ddd using callvirt,
the function is called off class yyy and not xxx. This is so as the function in
class xxx has nothing to do with the one in class yyy. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Compare this example with the
override modifier example shown earlier. If we eliminate the code of function
a2 from the class yyy, we get the following error:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Exception occurred: System.TypeLoadException: Could not load
class 'xxx' because the method 'a2' is not defined.<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The function a2 is present in
the class xxx, but it has been eliminated from the class yyy. However, the
function needs to be present in both the classes. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The same rules of nesting apply
to interfaces also. Nothing stops an interface from implementing another
interfaces, using the keyword implements. Here, the word implements may be
misleading. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The keyword implies<span
style="mso-spacerun: yes">  </span>that the class that implements this
interface must provide the code for it. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>An interface has five
restrictions: <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><b>i</b>.<span style='mso-tab-count:1'>   </span><span
style="mso-spacerun: yes">  </span>All methods must be either virtual or
static. <o:p></o:p></p>

<p class=ILbullets><b>ii</b>.<span style='mso-tab-count:1'> </span><span
style="mso-spacerun: yes">  </span>The virtual methods must be abstract and
public. <o:p></o:p></p>

<p class=ILbullets><b>iii</b>.<span style="mso-spacerun: yes">  </span>No
instance fields are allowed. <o:p></o:p></p>

<p class=ILbullets><b>iv</b>.<span style='mso-tab-count:1'> </span><span
style="mso-spacerun: yes">  </span>An interface is abstract and cannot be
instantiated. <o:p></o:p></p>

<p class=ILbullets><b>v</b>.<span style='mso-tab-count:1'>  </span><span
style="mso-spacerun: yes">  </span>An interface cannot inherit from a class.<o:p></o:p></p>

<p class=ILbullets><b>vi.</b><span style="mso-spacerun: yes">   </span>Under no
circumstances can an interface contain code. <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'>Structures</span></i></b><span
style='color:windowtext'><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>A structure handles memory more
efficiently than a class. IL does not support a struct type directly. As IL
does not recognise a structure, it does not enforce the following rules:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>Constructors must have parameters<o:p></o:p></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>All members of a structure must be initialised
before leaving the constructor. <o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Also, structures are derived
from ValueType and not Object.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The type system of the .Net
world is simplicity personified. It divides all the known types into one of the
two categories: a value type or a reference type. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>A reference type is known by a
reference, that is, a memory location that stores the address where the object
resides in memory. <o:p></o:p></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>A value type, however, is directly
stored in the memory location occupied by the variable that represents the type.
<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Value types are used to
represent small data items like local variables, integers, numbers with decimal
places etc. The memory allocated is on the stack and not on the heap. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To access a reference type, the
location of the variable in memory is to be first determined. This is not true
for a value type. Hence, there is no overhead of an indirection involved with a
value type and therefore, it is much more efficient. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The disadvantage of a value type
is that they cannot be derived from and, if the data they represent is fairly
large, then copying the type on the stack is not an efficient way of
representing that type.<span style="mso-spacerun: yes">  </span>There is no
need to instantiate a variable of value type, as it is already instantiated.
Apart from these variations, value types are similar to reference types.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx v)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>initobj value class xxx<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>ldfld int32 xxx::i<o:p></o:p></p>

<p class=ILprg>call void System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value xxx<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.field public int32 j<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>0<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above example, we have
created a value class or a value type called xxx, that has two public fields i
and j. We used the instruction initobj to create a new value type. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To display the value of i, we
first created a local variable that represents our value class. In our case,
the variable is called v. ldloca is used to load the address of the variable v
on the stack. Then we called initobj with the name of the value class xxx as a
parameter thus creating a a new value type. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We, then, again load the address
of the value type v on the stack and call ldfld. This instruction needs the
address of the value type on the stack to work with. The only reason that the
value of i is ZERO is that the instruction initobj guarantees that all members
of the value type will be initialized to zero.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object {<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed {<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx v)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>initobj value class xxx<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>ldc.i4.2<o:p></o:p></p>

<p class=ILprg>call instance void xxx::.ctor(int32)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>ldfld int32 xxx::i<o:p></o:p></p>

<p class=ILprg>call void System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value xxx<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.field public int32 j<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance
void<span style="mso-spacerun: yes">  </span>.ctor(int32 p) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld int32 xxx::i<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>2<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The correct way to initialize a
value class is to call the constructor. We first have to load the address of
the value type v on the stack. Then, since the constructor expects a single
parameter on the stack, we place the number 2 on the stack using ldc. The
constructor is then called in the same manner as we call any other function. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the constructor, we first
place the this pointer on the stack. The this pointer, or the first invisible
parameter to a function, is a reference to the starting location of the object
in memory. Parameter 1 is placed on the stack and stfld is called. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The constructor initializes all
members of a value class. The static fields of a value class are initialized
when the value type is first loaded.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx v)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>ldfld int32 xxx::i<o:p></o:p></p>

<p class=ILprg>call void System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value xxx<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.field public int32 j<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>51380288<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Not using initobj, like in the
above example will assign a random value to the value type. The use of initobj
is optional. This instruction requires a managed pointer to an instance of the
value type and it is one of the few instructions that does not return anything
on the stack. The constructor is never called by the initobj instruction. The
sole role initobj performs is to initialize all the value class members to
ZERO.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>While verifying code, one should
ensure that all the fields of a value type are assigned a value before they are
read or passed as parameters to a method. The code in constructor assigns
values to every field. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>You can see the contrast between
initobj and newobj. Value Types use initobj whereas reference types use newobj.
Also, value types are derived from System.ValueType.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Value types can have static,
instance and virtual methods. Here,<span style="mso-spacerun: yes">  </span>the
static methods are called in a similar manner when in a class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx v)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>ldc.i4.3<o:p></o:p></p>

<p class=ILprg>call instance void xxx::a1(int32)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>ldfld int32 xxx::i<o:p></o:p></p>

<p class=ILprg>call void System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value xxx<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.field public int32 j<o:p></o:p></p>

<p class=ILprg>.method public instance void<span style="mso-spacerun: yes"> 
</span>a1(int32 p) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld int32 xxx::i<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>3<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To call an instance function of
a value class, there is no need for<span style="mso-spacerun: yes"> 
</span>either initobj or the constructor call. But, it is a good practice to do
so. We have to place the address of the value type or the this pointer on the
stack and then place the parameters. The function a1 uses the this pointer to
access the fields. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We modified the function abc to
read as follows:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg>.method public virtual instance void<span style="mso-spacerun:
yes">  </span>a1(int32 p) il managed<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Despite making<span
style="mso-spacerun: yes">  </span>the function virtual, the program executes
as before.<span style="mso-spacerun: yes">  </span>The order of the virtual
modifier is very important. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>You may recall that a virtual
function has to be called using the instruction callvirt and not the
instruction call. However, in the case of a value class, we cannot use
callvirt. Instead, the instruction call is used. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx v)<o:p></o:p></p>

<p class=ILprg>ldloca v<o:p></o:p></p>

<p class=ILprg>box xxx<o:p></o:p></p>

<p class=ILprg>callvirt instance void ddd::a1()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class interface ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig newslot virtual abstract instance void
a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value xxx implements ddd<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.field public int32 j<o:p></o:p></p>

<p class=ILprg>.method public virtual instance void<span style="mso-spacerun:
yes">  </span>a1() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldstr &quot;hi&quot;<o:p></o:p></p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>hi<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above program, we
specified an interface ddd, that contains a single function called a1. We
created a value class xxx that implements from ddd. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Our intention is to call the
function a1 from the interface ddd. As mentioned earlier, to call a function
off an interface, the instruction callvirt has to be used and not the
instruction call, as, an interface does not contain any code. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The callvirt instruction
requires a reference type on the stack because it does not work with value
types. Thus, we use ldloca to load the address of the value type on the stack.
Then, we use the box instruction to convert it into a reference type. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Exception occurred: System.NullReferenceException: Attempted
to dereference a null object reference.<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>If we comment out the box
instruction, the following exception is generated because callvirt looks for a
a boxed type on the stack:<o:p></o:p></span></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></i></b></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></i></b></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></i></b></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></i></b></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></i></b></p>

<p class=ILbase><b><i><span style='mso-bidi-font-size:12.0pt;color:windowtext'>Boxing
and Unboxing<o:p></o:p></span></i></b></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>public class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>yyy a = new yyy(10,20);<o:p></o:p></p>

<p class=ILprg>yyy b;<o:p></o:p></p>

<p class=ILprg>b = a;<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine( b.i );<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int i,j;<o:p></o:p></p>

<p class=ILprg>public yyy(int x, int y)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;Const&quot;);<o:p></o:p></p>

<p class=ILprg>i=x;j=y;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (class yyy V_0,class yyy V_1)<o:p></o:p></p>

<p class=ILprg>ldc.i4.s<span style="mso-spacerun: yes">   </span>10<o:p></o:p></p>

<p class=ILprg>ldc.i4.s<span style="mso-spacerun: yes">   </span>20<o:p></o:p></p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
yyy::.ctor(int32,int32)<o:p></o:p></p>

<p class=ILprg>stloc.0<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>ldfld int32 yyy::i<o:p></o:p></p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi yyy extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.field public int32 j<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance
void<span style="mso-spacerun: yes">  </span>.ctor(int32 x,int32 y) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>instance void
[mscorlib]System.Object::.ctor()<o:p></o:p></p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Const&quot;<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 yyy::i<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.2<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 yyy::j<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Const<o:p></o:p></p>

<p class=ILoutput>10<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The constructor assigns values
to fields. It places the values on the stack and uses stfld to assign the
values to the fields. The question that arises is that what happens when we
equate reference objects with each other. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The explanation is very simple:
A reference object is simply a memory location stored in a local variable. The
variable V_0 contains a reference to the newly created object in memory. We
place this value on the stack and use ldloc.1 to initialize the variable V_1 to
this value. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Thus, a reference object is a
number representing the memory location of<span style="mso-spacerun: yes"> 
</span>an object. Here, the same number is stored in the objects a and b. Hence
b.i displays the number 10. Here, the constructor does not get called again, as
no new object is created.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz {<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>xxx a = new xxx(1);<o:p></o:p></p>

<p class=ILprg>object b = a;<o:p></o:p></p>

<p class=ILprg>a.x = 2;<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(((xxx)b).x);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>struct xxx<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int x;<o:p></o:p></p>

<p class=ILprg>public xxx(int i)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>x = i;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class public auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx V_0,class System.Object V_1,value class
xxx V_2)<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>ldc.i4.1<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>instance void
xxx::.ctor(int32)<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>box<span style="mso-spacerun: yes">        </span>xxx<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>ldc.i4.2<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 xxx::x<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>unbox<span style="mso-spacerun: yes">      </span>xxx<o:p></o:p></p>

<p class=ILprg>ldobj<span style="mso-spacerun: yes">      </span>xxx<o:p></o:p></p>

<p class=ILprg>stloc.2<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_2<o:p></o:p></p>

<p class=ILprg>ldfld<span style="mso-spacerun: yes">      </span>int32 xxx::x<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value private auto ansi sealed xxx extends
[mscorlib]System.ValueType<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 x<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance
void<span style="mso-spacerun: yes">  </span>.ctor(int32 i) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld int32 xxx::x<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>1<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This program and the next one
should be read in conjunction if you want to grasp the following:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>Concepts of boxing and unboxing<o:p></o:p></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>The major difference between a class
and a structure.<o:p></o:p></p>

<p class=ILbullets><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'>The concept of a structure is
not supported by IL. On conversion to IL, a struct becomes a class with the
modifier value added to it. It is sealed and derived from ValueType hence
referred to as<span style="mso-spacerun: yes">  </span>a value class.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the C# program, an object is
created, which is an instance of the structure xxx. The constructor is passed
the constant value 1, which is used to initialize the int field x to 1. Then,
the object b is initialized to a. Next, we change the value of the member x
from 1 to 2 using the value object a.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We display the value of the
field x using b. The cast operator is used as the data type of b is Object and
not xxx. We notice that there are two x ints in memory:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>One with a value of 2 that is
associated with a, <o:p></o:p></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>The other one with the value of 1 that
is associated with b.<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><span style="mso-spacerun:
yes"> </span><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>So much for the C# program, let
us see as to what happens in our IL program. We create 3 objects in IL i.e. two
variables V_1 and V_2 of the class xxx and one that looks like an Object. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We place the address of V_0 on
the stack followed by the value 1. Then, we call the constructor using a call
and not newobj, since we have a value class or structure and not a pure class.
The constructor initializes the field x to 1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We have to convert this value
class to a pure object that is an instance of the class Object. We load the address
of V_O and call the box instruction, which converts a value class into a class
and places the reference of the newly created object on the stack. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Then, we store this reference in
the local variable V_1 using stloc.1. This is the code generated when the
statement object b = a is converted to IL. We have created a fresh object using
the box instruction. Thus there are two xxx objects in memory, one as the value
object V_0 and one as a reference object V_1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We now need to initialize the
field x to 2. To do so,<span style="mso-spacerun: yes">  </span>the constant 2
is placed on the stack and stfld is called. The easier part of the code is
over. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The problem is in the expression
WriteLine((xxx)b).x. The object b or V_1 is a reference object. We have to cast
it to a value object. To do this, we need to unbox it. The act of converting a
reference object to a value object is called unboxing. The unbox instruction
requires a reference type on the stack and it will place a value type whose
data type is specified by the name following xxx. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The instruction ldobj loads an
instance of xxx on the stack whose pointer is already present on the stack. We
store this instance in V_2 and load this value type again on the stack. Then we
load the value of x and display it using WriteLine.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>yyy c = new yyy(1);<o:p></o:p></p>

<p class=ILprg>object d = c;<o:p></o:p></p>

<p class=ILprg>c.x = 2;<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(((yyy)d).x);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>class yyy<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int x;<o:p></o:p></p>

<p class=ILprg>public yyy(int i)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>x = i;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class public auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (class yyy V_0,class System.Object V_1)<o:p></o:p></p>

<p class=ILprg>ldc.i4.1<o:p></o:p></p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
yyy::.ctor(int32)<o:p></o:p></p>

<p class=ILprg>stloc.0<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloc.0<o:p></o:p></p>

<p class=ILprg>ldc.i4.2<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 yyy::x<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>castclass<span style="mso-spacerun: yes">  </span>yyy<o:p></o:p></p>

<p class=ILprg>ldfld<span style="mso-spacerun: yes">      </span>int32 yyy::x<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi yyy extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 x<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance
void<span style="mso-spacerun: yes">  </span>.ctor(int32 i) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>instance void
[mscorlib]System.Object::.ctor()<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 yyy::x<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>2<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>c is an object of type yyy and
holds a value of 1 in its member x. Object d is another class or call it a
structure, it does not create a new object in memory but instead, points to the
same object referenced by c. Thus, we have one yyy object in memory, and
any<span style="mso-spacerun: yes">  </span>changes made to the value of x
using d will be reflected when using c and vice-versa.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Here, as we are dealing with a
class, the instruction newobj is used to create it. To initialize the object d
to c, we first use ldloc.0 to place its value on the stack and then use the
instruction stloc.1 to initialize local V_1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Then, we initialize c.x to 2 in
the usual manner, by first placing the reference on the stack using ldloc.0 and
then, placing the value on the stack using stfld. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Object d is already a reference
object and yyy is a class. Hence we simply use castclass. It is easy to use
casting here because neither boxing nor unboxing is required to be carried out.
<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The important point to be
mentioned is that we are not creating another yyy in memory, and hence, there
is only one field x in memory. This was not the case earlier case, when a
structure was used. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>long f = 1;<o:p></o:p></p>

<p class=ILprg>object b = f;<o:p></o:p></p>

<p class=ILprg>int i = (int)b;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class public auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (int64 V_0,class System.Object V_1,int32 V_2)<o:p></o:p></p>

<p class=ILprg>ldc.i4.1<o:p></o:p></p>

<p class=ILprg>conv.i8<o:p></o:p></p>

<p class=ILprg>stloc.0<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>box<span style="mso-spacerun: yes">       
</span>[mscorlib]System.Int64<o:p></o:p></p>

<p class=ILprg>stloc.1<o:p></o:p></p>

<p class=ILprg>ldloc.1<o:p></o:p></p>

<p class=ILprg>unbox<span style="mso-spacerun: yes">     
</span>[mscorlib]System.Int32<o:p></o:p></p>

<p class=ILprg>ldind.i4<o:p></o:p></p>

<p class=ILprg>stloc.2<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>This example is deceptively
similar to the one above. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>First we take a reference object
b and equate it to a value object f. Then we cast the reference type object b
to a value type int. The C# compiler gives us no errors but a runtime exception
is thrown. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Back to IL. We first create a
long or an int64 V_0 using locals. Then we create an Object V_1 and finally an
int V_2. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We thereafter, place 1 on the
stack, convert it into 8 bytes using conv.i8 and use stloc.0 to store the value
in V_0. The address is then placed on the stack, as we need to use the box
instruction to convert it into a reference type, which is finally to be stored
in b or V_1. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Unbox the object b, the one
created out of a value type, and store in an int. To do this, we need to place
a reference on the stack and call unbox. This will place a value address on the
stack and use ldind.i4 to fetch the value stored at this address. Then, we use
stloc.2 to initialize the variable V_2. The exception clearly states that we
cannot cast an object that is a reference type to a value type.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>Exception occurred: System.InvalidCastException: An exception
of type System.InvalidCastException was thrown.<o:p></o:p></p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz {<o:p></o:p></p>

<p class=ILprg>public static void Main() {<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>int x;<o:p></o:p></p>

<p class=ILprg>void abc( int x)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>this.x = x;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class public auto ansi zzz extends [mscorlib]System.Object<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field private int32 x<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method private hidebysig instance void abc(int32 x) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 zzz::x<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>} <o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Languages decide on how you
write code and name variables. In C# a field and a parameter to a function can
have the same names, but the parameter name has more visibility than the field
name. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>this.x refers to the field name
in the function abc unlike the parameter named x. In IL, this dilemma does not
arise, as we have one set of instructions that deals with fields, a second set
that deals with parameters to functions and a third set that deals with locals.
Thus there is no way that a name clash can ever occur.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u><o:p></o:p></p>

<p class=ILprg>class zzz<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public static void Main() <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>xxx x = new xxx(10);<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(x.i);<o:p></o:p></p>

<p class=ILprg>x.abc();<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>struct xxx<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>public int i;<o:p></o:p></p>

<p class=ILprg>public xxx( int j)<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>i = j;<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>public void abc()<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;);<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u><o:p></o:p></p>

<p class=ILprg>.assembly mukhi {}<o:p></o:p></p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object <o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.method public hidebysig static void vijay() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.entrypoint<o:p></o:p></p>

<p class=ILprg>.locals (value class xxx V_0)<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>ldc.i4.s<span style="mso-spacerun: yes">   </span>10<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>instance void
xxx::.ctor(int32)<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>ldfld<span style="mso-spacerun: yes">      </span>int32 xxx::i<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(int32)<o:p></o:p></p>

<p class=ILprg>ldloca.s<span style="mso-spacerun: yes">   </span>V_0<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>instance void
xxx::abc()<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.class value private auto ansi sealed xxx extends
[mscorlib]System.ValueType<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>.field public int32 i<o:p></o:p></p>

<p class=ILprg>.method public hidebysig specialname rtspecialname instance
void<span style="mso-spacerun: yes">  </span>.ctor(int32 j) il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldarg.0<o:p></o:p></p>

<p class=ILprg>ldarg.1<o:p></o:p></p>

<p class=ILprg>stfld<span style="mso-spacerun: yes">      </span>int32 xxx::i<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>.method public hidebysig instance void abc() il managed<o:p></o:p></p>

<p class=ILprg>{<o:p></o:p></p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;abc&quot;<o:p></o:p></p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)<o:p></o:p></p>

<p class=ILprg>ret<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILprg>}<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u><o:p></o:p></p>

<p class=ILoutput>10<o:p></o:p></p>

<p class=ILoutput>abc<o:p></o:p></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We take one more program on
structures before we close this chapter. . We have created a struct containing
a field i and a function abc. Structures are value objects and are stored on
the stack and not on the heap. Thus, the word value has been used in the locals
directive. It is a class, but of a value type. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the definition of the
structure, we have added two modifiers, sealed and value. Therefore, we cannot
derive from this value class. Everything else is similar to a class. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

</div>

</body>

</html>
