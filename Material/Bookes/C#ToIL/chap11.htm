<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./chap11_files/filelist.xml">
<link rel=Edit-Time-Data href="./chap11_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Delegates and Events - C# to IL</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>27</o:TotalTime>
  <o:Created>2001-01-24T06:12:00Z</o:Created>
  <o:LastSaved>2001-01-24T06:15:00Z</o:LastSaved>
  <o:Pages>2</o:Pages>
  <o:Words>3493</o:Words>
  <o:Characters>18168</o:Characters>
  <o:Company>VMCI</o:Company>
  <o:Lines>2271</o:Lines>
  <o:Paragraphs>1135</o:Paragraphs>
  <o:CharactersWithSpaces>24456</o:CharactersWithSpaces>
  <o:Version>9.3821</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:Tahoma;
	panose-1:2 11 6 4 3 5 4 4 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:553679495 -2147483648 8 0 66047 0;}
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
@font-face
	{font-family:"Monotype Corsiva";
	panose-1:3 1 1 1 1 2 1 1 1 1;
	mso-font-charset:0;
	mso-generic-font-family:script;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.Cbullets, li.Cbullets, div.Cbullets
	{mso-style-name:"C\#bullets";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cbase, li.Cbase, div.Cbase
	{mso-style-name:"C\#base";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.Coutput, li.Coutput, div.Coutput
	{mso-style-name:"C\#output";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Cprg, li.Cprg, div.Cprg
	{mso-style-name:"C\#prg";
	mso-style-parent:"C\#base";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.5pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.5pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.5pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	color:black;}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"c\# base text";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Tahoma;
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=Cbase><b><span style='font-size:9.0pt;mso-bidi-font-size:10.0pt'><img
width=64 height=48 id="_x0000_i1025" src=bpb.jpg><o:p></o:p></span></b></p>

<p class=Cbase><b><span style='font-size:24.0pt;mso-bidi-font-size:10.0pt'>-11-</span></b><span
style='font-size:24.0pt;mso-bidi-font-size:10.0pt;color:windowtext'><o:p></o:p></span></p>

<p class=Cbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=Cbase align=center style='text-align:center'><span style='font-size:
30.0pt;font-family:"Monotype Corsiva"'>Delegates and Events</span><span
style='color:windowtext'><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Exception handling in IL is a
big let down. We expected a significant amount of complexity, but were proved
wrong, right from the beginning. IL cannot be termed as a machine level
assembler. It actually has a number of directives like try and catch, that work
like their higher level counterparts. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u></p>

<p class=ILprg>class zzz</p>

<p class=ILprg>{</p>

<p class=ILprg>public static void Main()</p>

<p class=ILprg>{</p>

<p class=ILprg>try</p>

<p class=ILprg>{</p>

<p class=ILprg>abc();</p>

<p class=ILprg>System.Console.WriteLine(&quot;Bye&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>catch (System.Exception e)</p>

<p class=ILprg>{</p>

<p class=ILprg>System.Console.WriteLine(&quot;In Exception&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>System.Console.WriteLine(&quot;After Exception&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>public static void abc()</p>

<p class=ILprg>{</p>

<p class=ILprg>throw new System.Exception();</p>

<p class=ILprg>System.Console.WriteLine(&quot;abc&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above example, the function
abc first creates an object that looks like Exception using newobj and places
it on the stack. Thereafter the throw instruction throws an exception. This
Exception is placed on the stack, hence the catch instruction is called. In the
catch instruction, e, a local varaible, is an instance of Exception. The next
instruction, leave.s jumps to label IL_001e, the label is beyond the catch. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>To exit off from<span
style="mso-spacerun: yes">  </span>a try or a catch block, instead of the
branch instruction br, leave is used. The reason is that we are dealing
with<span style="mso-spacerun: yes">  </span>exceptions, which are to be
handled in a special way in IL. Exception handling in IL is done using higher
level instructions. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u></p>

<p class=ILprg>class zzz</p>

<p class=ILprg>{</p>

<p class=ILprg>public static void Main()</p>

<p class=ILprg>{</p>

<p class=ILprg>yyy a;</p>

<p class=ILprg>a=new yyy();</p>

<p class=ILprg>try</p>

<p class=ILprg>{</p>

<p class=ILprg>a.abc();</p>

<p class=ILprg>System.Console.WriteLine(&quot;Bye&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>catch </p>

<p class=ILprg>{</p>

<p class=ILprg>System.Console.WriteLine(&quot;In Exception&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>System.Console.WriteLine(&quot;In finally&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>class yyy</p>

<p class=ILprg>{</p>

<p class=ILprg>public void abc()</p>

<p class=ILprg>{</p>

<p class=ILprg>throw new System.Exception();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object </p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void<span style="mso-spacerun:
yes">  </span>vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class yyy V_0)</p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
yyy::.ctor()</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>ldloc.0</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>instance void
yyy::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_0025</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Object </p>

<p class=ILprg>{</p>

<p class=ILprg>pop</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_0025</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_0025:<span style="mso-spacerun: yes">  </span>leave.s<span
style="mso-spacerun: yes">    </span>IL_0032</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
finally&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>endfinally</p>

<p class=ILprg>} </p>

<p class=ILprg>IL_0032:<span style="mso-spacerun: yes">  </span>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>.class private auto ansi yyy extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig instance void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
[mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>In finally</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above program has utilised a
try catch without a parameter and a finally clause. Adding a finally clause
associates the same try with a catch, and a finally. In a sense, two copies of
try are created, one for catch and the other for finally.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>If the catch directive is not
supplied with an Exception object, it will take an object that looks like
System.Object. In the catch, the item is popped of the stack, as its value
holds no significance. The string is printed before the leave. Also, along with
try-catch is the finally clause which is the next to be executed. A finally is
executed as a separate try finally directive and it can only be exited using
the endfinally instruction.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object </p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void<span style="mso-spacerun:
yes">  </span>vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>leave.s IL_0032</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
finally&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>endfinally</p>

<p class=ILprg>} </p>

<p class=ILprg>IL_0032:<span style="mso-spacerun: yes">  </span>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In finally</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Nowhere is it specified that a
try must have a catch. A finally will ultimately be called at the end of the
try. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object </p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void<span style="mso-spacerun:
yes">  </span>vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>Exception occurred: System.Exception: An exception of type
System.Exception was thrown.</p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the absence of a try catch
block, if function abc throws an exception, it will not get caught. Instead, a
runtime error is generated. A try<span style="mso-spacerun: yes">  </span>catch
clause is recommended to proactively catch the exception, otherwise when an
exception is thrown and the program will come to a grinding halt.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u></p>

<p class=ILprg>public class zzz </p>

<p class=ILprg>{</p>

<p class=ILprg>public static void Main()</p>

<p class=ILprg>{</p>

<p class=ILprg>int i = 1;</p>

<p class=ILprg>for ( i = 1; i&lt;= 10 ; i++)</p>

<p class=ILprg>{</p>

<p class=ILprg>try </p>

<p class=ILprg>{</p>

<p class=ILprg>System.Console.WriteLine(&quot;1 try&quot;);</p>

<p class=ILprg>try</p>

<p class=ILprg>{<span style='mso-tab-count:1'>           </span></p>

<p class=ILprg>System.Console.WriteLine(&quot;2 try&quot;);</p>

<p class=ILprg>break;</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>System.Console.WriteLine(&quot;2 finally&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>System.Console.WriteLine(&quot;1 finally&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>System.Console.WriteLine(i);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object </p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void<span style="mso-spacerun:
yes">  </span>vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (int32 V_0)</p>

<p class=ILprg>ldc.i4.1</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldc.i4.1</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>br.s<span style="mso-spacerun: yes">       </span>IL_0032</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>IL_0006:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;1 try&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;2
try&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_0037</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;2
finally&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>endfinally</p>

<p class=ILprg>}</p>

<p class=ILprg>} </p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;1
finally&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>endfinally</p>

<p class=ILprg>} </p>

<p class=ILprg>IL_0032:<span style="mso-spacerun: yes">  </span>ldloc.0</p>

<p class=ILprg>ldc.i4.s<span style="mso-spacerun: yes">   </span>10</p>

<p class=ILprg>ble.s<span style="mso-spacerun: yes">      </span>IL_0006</p>

<p class=ILprg>IL_0037:<span style="mso-spacerun: yes">  </span>ldloc.0</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void [mscorlib]System.Console::WriteLine(int32)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>1 try</p>

<p class=ILoutput>2 try</p>

<p class=ILoutput>2 finally</p>

<p class=ILoutput>1 finally</p>

<p class=ILoutput>1</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above program is quite
lengthy, but very simple. It proves the fact that code placed in a finally
block is always executed. Like death and taxes, a finally cannot be avoided.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The<span style="mso-spacerun:
yes">  </span>for statement branches<span style="mso-spacerun: yes">  </span>to
label IL_0032 where we first check for the value to be less than or equalto10.
If it results in TRUE,<span style="mso-spacerun: yes">  </span>the code at
label IL_0006 is executed. A we learnt in one of the earlier chapters, the
condition check for the for statement is always placed at the bottom in IL. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the first attempt, string
&quot;1 try&quot; is printed . Thereafter the code within the second try is
executed, where<span style="mso-spacerun: yes">  </span>&quot;2 try&quot; is
printed. The break statement in C# gets converted to a leave to label IL_0037
in IL. This label signifies the end of the for statement. The leave instruction
is smart enough to realize that it is located within two trys with a finally
clause, hence it calls the code with the finally instruction. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Under normal circumstances, break
becomes a branch instruction if not placed within try-catch.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.cs</u></p>

<p class=ILprg>public class zzz</p>

<p class=ILprg>{</p>

<p class=ILprg>public void abc() </p>

<p class=ILprg>{</p>

<p class=ILprg>lock(this)</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public static void Main() </p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed {</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig instance void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.locals (class zzz V_0)</p>

<p class=ILprg>ldarg.0</p>

<p class=ILprg>dup</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>call void [mscorlib]System.Threading.Monitor::Enter(class
System.Object)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_0011</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>ldloc.0</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Threading.Monitor::Exit(class System.Object)</p>

<p class=ILprg>endfinally</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_0011:<span style="mso-spacerun: yes">  </span>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The lock keyword ensures that
while one thread executes a function, the other threads remain suspended. This
keyword gets translated into a large amount of IL code. In fact, it generates
the maximum amount of code amongst all the keywords. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The C# compiler first calls the
static function Enter from the Monitor class. Then, it executes the code
located in a try. The try block here contains no code. On encountering the
leave instruction, the program enters the finally which calls the Exit function
from the Monitor<span style="mso-spacerun: yes">  </span>class. This initiates
another thread that is waiting at the Enter function.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Whenever an exception occurs, an
object representing the exception must be created. This exception object has to
be a class derived from Exception and cannot be a value type or a pointer.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>A Structured Exception Handling
(SEH) block is made up of a try and one or more handlers. A try directive is
used to declare a protected block. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We cannot exit from a protected
block with a ret but, on using it, no errors are generated at assemble time or
run time. As a rule, only a leave or a throw to another exception is acceptable
to exit from a protected block. A leave statement is permitted in the try and
not in the catch.<o:p></o:p></span></p>

<p class=ILprg><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed {</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::pqr()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye1&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>leave aa1</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception1&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>aa1: leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void pqr() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>Bye</p>

<p class=ILoutput>In Exception1</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We can nest as many trys or
protected blocks within each other. A leave is required at the end of every try
to avoid all errors. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We can have four types of
handlers for a try or a protected block. They are: <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>finally</p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>catch</p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>fault</p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>filter</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Only one of it can be used at a
time.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed {</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>finally</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
finally&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>endfinally</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>} </p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>If we comment out the code where
the function abc has been called, we get the following output:<o:p></o:p></span></p>

<p class=ILoutput><u><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></u></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>Bye</p>

<p class=ILoutput>In finally</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>As mentioned earlier, the
protected block can only be handled by a single handler. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In the above example, when an
exception is thrown, the catch is called and not finally as it does not have
its own try directive. The runtime does not give us any error, but it ignores
the finally handler. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>If, however, no exception is
thrown, as is the case when we comment out the call of the function abc, then
the finally gets called. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>It is quaint that the try is a
directive, but the handler is not. We have two classes of handlers:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>exception resolving handlers</p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>exception observing handlers. </p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The finally and fault handlers are
exception observing handlers as they do not resolve the exception. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>In an exception resolving
handler, we try and resolve the exception so that normal program control
continues. The catch and filter handlers are examples of such handlers.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The deepest handler will be
visited first, followed by the next enclosing one and so on, until we find an
appropriate handler. A handler has its own instructions, using which, the
program can exit a handler. It is illegal to use any other instruction for this
purpose, but at times the assembler is unable to detect this misfit. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>br a1</p>

<p class=ILprg>}</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void pqr() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>a1:</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput>Error</p>

<p class=ILoutput>***** FAILURE ***** </p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We are<span style="mso-spacerun:
yes">  </span>not allowed to jump off a catch handler. It is essential to leave
the handler in an orderly manner only.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object </p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void<span style="mso-spacerun:
yes">  </span>vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class zzz V_0)</p>

<p class=ILprg>newobj<span style="mso-spacerun: yes">     </span>instance void
zzz::.ctor()</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>startTry:</p>

<p class=ILprg>ldstr &quot;in try&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>//call instance void zzz::abc()</p>

<p class=ILprg>ldstr &quot;after function call&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave<span style='mso-tab-count:1'>    </span>exitSEH</p>

<p class=ILprg>endTry:</p>

<p class=ILprg>startFault:</p>

<p class=ILprg>ldstr &quot;in fault&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>endfault</p>

<p class=ILprg>endFault:</p>

<p class=ILprg>.try startTry to endTry fault handler startFault to endFault</p>

<p class=ILprg>exitSEH:</p>

<p class=ILprg>ldstr &quot;over&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig instance void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>in try</p>

<p class=ILoutput>after function call</p>

<p class=ILoutput>over</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>If we comment out the call of
the function abc, we get an error, a Windows error, which is incomprehensible.
The purpose of the above program is to demonstrate that we can use labels to
delimit code<span style="mso-spacerun: yes">  </span>in a protected block.
Thereafter, we can use the try directive, indicating to it the start and end
label of our code and also the start and end of the fault handler. This is
another way of utilising the try directive.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The catch keyword creates a type
filtered exception. Whenever an exception occurs in a protected block, the EE
checks whether the exception that occurred earlier, is equal to or a sub-type
of the error that the catch expects. If the type matches, the code of the catch
is called. If the type does not match, the EE will continue to search for
another handler.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>a1:</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s<span style="mso-spacerun: yes">    </span>a1</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>Bye</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The program is not allowed to resume
execution after an exception occurs. This means that, we cannot go back to the
protected block where the exception took place. In this case, we are allowed to
do so, but keep in mind that we were using a beta copy of the assembler. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Whenever the EE sees a leave in
a catch block, it knows that the exception is done with, and the system returns
to a normal state.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">    </span><span
style="mso-spacerun: yes">  </span>&quot;In Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>rethrow</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>Exception occurred: System.Exception: An exception of type
System.Exception was thrown.</p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Here, at the end of the catch is
the rethrow instruction, which<span style="mso-spacerun: yes">  </span>rethrows
the same exception again. As there is no other catch block to catch the
exception, the exception is thrown at run time.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>rethrow</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception1&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>In Exception1</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Here, we placed another try
directive with a separate catch. The exception that is thrown by the inner
catch, cannot be caught by another catch at the same level. It needs to be
caught by the catch at the higher level. Thus one more catch is needed.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public hidebysig static void vijay() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>.locals (class [mscorlib]System.Exception V_0)</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
zzz::abc()</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">     
</span>&quot;Bye&quot;</p>

<p class=ILprg>call void [mscorlib]System.Console::WriteLine(class
System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.Exception </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>catch [mscorlib]System.IOException </p>

<p class=ILprg>{</p>

<p class=ILprg>stloc.0</p>

<p class=ILprg>ldstr<span style="mso-spacerun: yes">      </span>&quot;In
Exception1&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave.s IL_001e</p>

<p class=ILprg>}</p>

<p class=ILprg>IL_001e:<span style="mso-spacerun: yes">  </span>ldstr<span
style="mso-spacerun: yes">      </span>&quot;After Exception&quot;</p>

<p class=ILprg>call<span style="mso-spacerun: yes">       </span>void
[mscorlib]System.Console::WriteLine(class System.String)</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.IOException::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>In Exception</p>

<p class=ILoutput>After Exception</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The C# compiler watches our code
like a hawk. On the other hand, the assembler is a blind bat. <o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>There are two exception
handlers:<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>IOException: This handles Input/Output
Exceptions.</p>

<p class=ILbullets><span style='font-size:14.0pt;font-family:"Times New Roman"'>•<span
style='mso-tab-count:1'>  </span></span>Exception: This is a generic handler
that handles generic exceptions since all exceptions are derived from
exception. </p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>Consciously, we have placed the
generic Exception handler first. Therefore, irrespective of the exception
thrown, the second handler will never get called. The function abc now throws a
IOException. The generic Exception handler, which is placed earlier in the
code, is encountered first, and therefore, it deals with the exception. The C#
compiler would have generated an error in this situation, but the assembler
assumes what you are conscious of your deeds.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>Exception occurred: System.ExecutionEngineException: An
exception of type System.ExecutionEngineException was thrown.</p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The above exception is thrown
when there is no leave in a catch and there is another catch following this
one. In one of our earlier programs above, we have used only a single catch.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILprg><u>a.il</u></p>

<p class=ILprg>.assembly mukhi {}</p>

<p class=ILprg>.class private auto ansi zzz extends [mscorlib]System.Object</p>

<p class=ILprg>{</p>

<p class=ILprg>.method public static void vijay() </p>

<p class=ILprg>{</p>

<p class=ILprg>.entrypoint</p>

<p class=ILprg>ldstr &quot;start&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>br<span style='mso-tab-count:1'>         </span>start</p>

<p class=ILprg>a2:</p>

<p class=ILprg>ldstr &quot;in a2&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>pop<span style='mso-tab-count:1'>       </span></p>

<p class=ILprg>ldc.i4.0<span style='mso-tab-count:1'> </span></p>

<p class=ILprg>endfilter</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>start:</p>

<p class=ILprg>.try</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr &quot;in try&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>call void zzz::abc()</p>

<p class=ILprg>ldstr &quot;after function call&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>leave a1</p>

<p class=ILprg>}</p>

<p class=ILprg>filter a2</p>

<p class=ILprg>{</p>

<p class=ILprg>ldstr &quot;filter&quot;</p>

<p class=ILprg>call void System.Console::WriteLine(class System.String)</p>

<p class=ILprg>pop<span style='mso-tab-count:1'>       </span></p>

<p class=ILprg>leave a1</p>

<p class=ILprg>}</p>

<p class=ILprg>a1:</p>

<p class=ILprg>ret</p>

<p class=ILprg>}</p>

<p class=ILprg>.method public hidebysig static void abc() il managed</p>

<p class=ILprg>{</p>

<p class=ILprg>newobj instance void [mscorlib]System.Exception::.ctor()</p>

<p class=ILprg>throw</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILoutput><u>Output</u></p>

<p class=ILoutput>start</p>

<p class=ILoutput>in try</p>

<p class=ILoutput>Exception occurred: System.Exception: An exception of type System.Exception
was thrown.</p>

<p class=ILoutput><span style="mso-spacerun: yes">   </span>at zzz.vijay()</p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>The last type of fault handler,
which is the most generic, either does not seem to work or it could also mean
that we have done something wrong.<o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></span></p>

<p class=ILbase><span style='color:windowtext'>We use the keyword filter with a
label, which denotes the start point of some code. This code checks whether the
exception must be handled or not. This is triggered off<span
style="mso-spacerun: yes">  </span>by placing either the number 0 or 1 on the
stack. In our case, none of the code dealing with the filter gets called.<o:p></o:p></span></p>

</div>

</body>

</html>
