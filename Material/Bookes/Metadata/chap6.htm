<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 9">
<meta name=Originator content="Microsoft Word 9">
<link rel=File-List href="./chap6_files/filelist.xml">
<link rel=Edit-Time-Data href="./chap6_files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>Metadata Tables - 6. Correlating Metadata Tables</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>Vijay Mukhi</o:Author>
  <o:LastAuthor>Vijay Mukhi</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>15</o:TotalTime>
  <o:Created>2002-05-15T21:13:00Z</o:Created>
  <o:LastSaved>2002-02-18T20:18:00Z</o:LastSaved>
  <o:Pages>80</o:Pages>
  <o:Words>18100</o:Words>
  <o:Characters>103173</o:Characters>
  <o:Company>VMCI</o:Company>
  <o:Lines>859</o:Lines>
  <o:Paragraphs>206</o:Paragraphs>
  <o:CharactersWithSpaces>126703</o:CharactersWithSpaces>
  <o:Version>9.2720</o:Version>
 </o:DocumentProperties>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
@font-face
	{font-family:"Bookman Old Style";
	panose-1:2 5 6 4 5 5 5 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:roman;
	mso-font-pitch:variable;
	mso-font-signature:647 0 0 0 159 0;}
@font-face
	{font-family:"Trebuchet MS";
	panose-1:2 11 6 3 2 2 2 2 2 4;
	mso-font-charset:0;
	mso-generic-font-family:swiss;
	mso-font-pitch:variable;
	mso-font-signature:7 0 0 0 19 0;}
 /* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.MsoHeader, li.MsoHeader, div.MsoHeader
	{margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:8.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	letter-spacing:10.0pt;}
p.MsoCaption, li.MsoCaption, div.MsoCaption
	{mso-style-next:Normal;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{margin:0in;
	margin-bottom:.0001pt;
	text-align:right;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:24.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.MsoBodyText, li.MsoBodyText, div.MsoBodyText
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-indent:24.0pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	color:black;}
p.MsoSubtitle, li.MsoSubtitle, div.MsoSubtitle
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:14.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.programs, li.programs, div.programs
	{mso-style-name:programs;
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.figure, li.figure, div.figure
	{mso-style-name:figure;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.figure1, li.figure1, div.figure1
	{mso-style-name:figure1;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.ChapName, li.ChapName, div.ChapName
	{mso-style-name:"Chap Name";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.ChapName1, li.ChapName1, div.ChapName1
	{mso-style-name:"Chap Name1";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.ILbase, li.ILbase, div.ILbase
	{mso-style-name:ILbase;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.basetextofthebook, li.basetextofthebook, div.basetextofthebook
	{mso-style-name:"base text of the book";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.basetextofthebook1, li.basetextofthebook1, div.basetextofthebook1
	{mso-style-name:"base text of the book1";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ChapName0, li.ChapName0, div.ChapName0
	{mso-style-name:ChapName;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.DOSPROMPT, li.DOSPROMPT, div.DOSPROMPT
	{mso-style-name:"DOS PROMPT";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.cbasetext, li.cbasetext, div.cbasetext
	{mso-style-name:"c\# base text";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ChapIntro, li.ChapIntro, div.ChapIntro
	{mso-style-name:"Chap Intro";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:42.65pt;
	margin-bottom:0in;
	margin-left:1.25in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:11.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-style:italic;}
p.PageNo, li.PageNo, div.PageNo
	{mso-style-name:"Page No";
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:9.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Headline, li.Headline, div.Headline
	{mso-style-name:Headline;
	mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:30.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.Hangingindent, li.Hangingindent, div.Hangingindent
	{mso-style-name:"Hanging indent";
	mso-style-parent:"";
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:12.0pt;
	margin-bottom:.0001pt;
	text-indent:-12.0pt;
	mso-pagination:widow-orphan;
	tab-stops:12.0pt;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILprg, li.ILprg, div.ILprg
	{mso-style-name:ILprg;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILoutput, li.ILoutput, div.ILoutput
	{mso-style-name:ILoutput;
	mso-style-parent:ILbase;
	mso-style-next:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.ILbullets, li.ILbullets, div.ILbullets
	{mso-style-name:ILbullets;
	mso-style-parent:ILbase;
	margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.3in;
	margin-bottom:.0001pt;
	text-align:justify;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	font-family:"Bookman Old Style";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";}
p.Subhead1, li.Subhead1, div.Subhead1
	{mso-style-name:"Subhead 1";
	mso-style-parent:Headline;
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:18.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
p.Subhead2, li.Subhead2, div.Subhead2
	{mso-style-name:"Subhead 2";
	mso-style-parent:"Subhead 1";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	mso-layout-grid-align:none;
	text-autospace:none;
	font-size:10.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Trebuchet MS";
	mso-fareast-font-family:"Times New Roman";
	mso-bidi-font-family:"Times New Roman";
	font-weight:bold;}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body lang=EN-US style='tab-interval:.5in'>

<div class=Section1>

<p class=MsoNormal><img width=64 height=48 id="_x0000_i1025" src=bpb.gif></p>

<p class=MsoNormal><span style='font-size:24.0pt'>6. Correlating Metadata
Tables</span></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>In all the previous chapters that we presented, we had
elucidated all the concepts and tables through distinct programs. In this
chapter, we have endeavored to inscribe a single program, which encompasses all
the tables and displays meaningful output. In lieu of displaying references to
various tables, such as typeDef[1],<span style="mso-spacerun: yes"> 
</span>MethodRef[2] etc., we shall display the actual values existent at these
locations. Thus, we have essayed to resolve all the cross-references and to
display the metadata information in a comprehensive manner. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>But, prior to embarking on the explanation of this gargantuan
program, which cross-references all the tables, we wish to shed light on a few
crucial aspects.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Every table in the metadata world is constituted of fields.
Moreover, even a structure is essentially a collection of fields. Therefore, in
the C# program, we have represented the metadata tables in a structure.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>For instance, we have created an ExportedTypeTable as a
structure tag, which contains multiple fields. The structure in essence, is a
logical entity, which has no physical existence. Hence, we generate an actual
structure by creating a variable of the structure tag named
ExportedTypeTableStruct. A structure is a value type, and hence, it does not
have to be instantiated. </p>

<p class=ILbase>The variable ExportedTypeTableStruct is declared as an array of
structures. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>public struct ExportedTypeTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
typedefindex ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int name
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
nspace ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
coded ;</p>

<p class=ILprg>}</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>public ExportedTypeTable [] ExportedTypeStruct;</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The program gets underway by creating a structure tag for every
table in the metadata.<span style="mso-spacerun: yes">  </span>We have proffered
the entire program to you, despite being aware of the fact that it would run
into reams of pages.<span style="mso-spacerun: yes">  </span>Before you get
going with the main program, compile b.cs in the c:\mdata subdirectory and
generate the file b.exe. The metadata information of this executable will be
displayed in the output.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>b.cs</u></p>

<p class=ILprg>using System.Runtime.InteropServices;</p>

<p class=ILprg>using System;</p>

<p class=ILprg>public class zzz</p>

<p class=ILprg>{</p>

<p class=ILprg>static int i;</p>

<p class=ILprg>const int j=2;</p>

<p class=ILprg>public event EventHandler a;</p>

<p class=ILprg>public event EventHandler b;</p>

<p class=ILprg>[DllImport(&quot;user32.dll&quot;)]</p>

<p class=ILprg>public static extern int MessageBox(int hWnd, String text,
String caption, uint type);</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>public static void Main () </p>

<p class=ILprg>{</p>

<p class=ILprg>i=10;</p>

<p class=ILprg>Console.WriteLine(&quot;hell {0}&quot;,i);</p>

<p class=ILprg>}</p>

<p class=ILprg>public int abc(float k)</p>

<p class=ILprg>{</p>

<p class=ILprg>return 0;</p>

<p class=ILprg>}</p>

<p class=ILprg>public long pqr( int[] i ,<span style="mso-spacerun: yes"> 
</span>char j)</p>

<p class=ILprg>{</p>

<p class=ILprg>return 0;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void xyz()</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public class yyy:iii</p>

<p class=ILprg>{</p>

<p class=ILprg>public int aa</p>

<p class=ILprg>{</p>

<p class=ILprg>set</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>get</p>

<p class=ILprg>{</p>

<p class=ILprg>return 10;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string bb</p>

<p class=ILprg>{</p>

<p class=ILprg>set</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>get</p>

<p class=ILprg>{</p>

<p class=ILprg>return &quot;hi&quot;;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public long uuu( int i , char[] j)</p>

<p class=ILprg>{</p>

<p class=ILprg>return 0;</p>

<p class=ILprg>}</p>

<p class=ILprg>void iii.xxx()</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;hello&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>public unsafe void aaa()</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>}</p>

<p class=ILprg>interface iii</p>

<p class=ILprg>{</p>

<p class=ILprg>void xxx();</p>

<p class=ILprg>}</p>

<p class=ILprg>public class uuu:yyy</p>

<p class=ILprg>{</p>

<p class=ILprg>class a1</p>

<p class=ILprg>{</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>a.txt</u></p>

<p class=ILprg>author=vijay</p>

<p class=ILprg>book=metadata</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>&gt;resgen a.txt</p>

<p class=ILprg>&gt;csc b.cs /res:a.resources /unsafe</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>a.cs</u></p>

<p class=ILprg>using System;</p>

<p class=ILprg>using System.IO;</p>

<p class=ILprg>using System.Reflection;</p>

<p class=ILprg>using System.Reflection.Emit;</p>

<p class=ILprg>using System.Configuration.Assemblies;</p>

<p class=ILprg>using<span style="mso-spacerun: yes"> 
</span>System.Globalization;</p>

<p class=ILprg>public struct ExportedTypeTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
typedefindex ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int name
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
nspace ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
coded ;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct NestedClassTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
nestedclass;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int enclosingclass;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct MethodImpTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
classindex;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
codedbody;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
codeddef; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ClassLayoutTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
packingsize ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
classsize ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
parent ;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ManifestResourceTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
offset;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
coded;<span style="mso-spacerun: yes">  </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ModuleRefTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct FileTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
index;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct EventTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
attr;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
coded;<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct EventMapTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
index;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
eindex;<span style="mso-spacerun: yes">  </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct MethodSemanticsTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
methodsemanticsattributes;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
methodindex;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
association;<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct PropertyMapTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
parent;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
propertylist; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct PropertyTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
type; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ConstantsTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
dtype;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
parent; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
value ;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct FieldLayoutTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
offset;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
fieldindex;<span style="mso-spacerun: yes">  </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct FieldRVATable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int rva
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
fieldi; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct FieldMarshalTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
coded;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
index;<span style="mso-spacerun: yes">  </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct FieldTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int sig;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ParamTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
pattr;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
sequence;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct TypeSpecTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
signature;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct MemberRefTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
clas;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
sig;<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct StandAloneSigTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
index;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct InterfaceImplTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
classindex;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
interfaceindex; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct TypeDefTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
nspace;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
cindex;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
findex;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
mindex;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct CustomAttributeTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
parent; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
type;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
value; </p>

<p class=ILprg>}</p>

<p class=ILprg>public struct AssemblyRefTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
major,minor,build,revision; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
publickey ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int name
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
culture ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
hashvalue ;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct AssemblyTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
HashAlgId; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
major, minor,build,revision ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
publickey ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int name
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
culture ;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ModuleTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
Generation;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
Name; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
Mvid;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
EncId;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
EncBaseId;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct TypeRefTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
resolutionscope;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
nspace;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct MethodTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int rva;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
impflags;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
flags;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
signature;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
param;</p>

<p class=ILprg>}</p>

<p class=ILprg>public struct DeclSecurityTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
action;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
coded;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int bindex;<span
style="mso-spacerun: yes">  </span></p>

<p class=ILprg>}</p>

<p class=ILprg>public struct ImplMapTable</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public short
attr;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
cindex;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
name;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public int
scope; </p>

<p class=ILprg>}</p>

<p class=ILprg>public class zzz</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>string []
typerefnames;<span style="mso-spacerun: yes">  </span></p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>string []
typedefnames;<span style="mso-spacerun: yes">  </span></p>

<p class=ILprg><span style='mso-tab-count:1'>            </span></p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public static
void Main (string [] args) </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>{</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>zzz
a = new zzz();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>a.abc(args);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>}</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public void
abc(string [] args) </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>{</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>InitializeObjects(args);</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>ReadPEStructures();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>DisplayPEStructures();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>ImportAdressTable();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>CLRHeader();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>ReadStreamsData();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>FillTableSizes();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>ReadTablesIntoStructures();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>DisplayTableForDebugging();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>}</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
AssemblyTable [] AssemblyStruct; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
AssemblyRefTable [] AssemblyRefStruct ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
CustomAttributeTable [] CustomAttributeStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ModuleTable[] ModuleStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
TypeDefTable [] TypeDefStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
TypeRefTable [] TypeRefStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
InterfaceImplTable [] InterfaceImplStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
MethodTable [] MethodStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
StandAloneSigTable [] StandAloneSigStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
MemberRefTable [] MemberRefStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
TypeSpecTable [] TypeSpecStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public ParamTable
[] ParamStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
FieldTable [] FieldStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
FieldMarshalTable [] FieldMarshalStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
FieldRVATable [] FieldRVAStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
FieldLayoutTable [] FieldLayoutStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ConstantsTable [] ConstantsStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
PropertyMapTable [] PropertyMapStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
PropertyTable [] PropertyStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
MethodSemanticsTable [] MethodSemanticsStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
EventTable [] EventStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
EventMapTable [] EventMapStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
FileTable [] FileStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ModuleRefTable [] ModuleRefStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ManifestResourceTable [] ManifestResourceStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ClassLayoutTable [] ClassLayoutStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
MethodImpTable [] MethodImpStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
NestedClassTable [] NestedClassStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ExportedTypeTable [] ExportedTypeStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
DeclSecurityTable [] DeclSecurityStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public
ImplMapTable [] ImplMapStruct;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int [] sizes;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>FileStream s ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>BinaryReader r
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int subsystem; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
stackreserve ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
stackcommit;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int datad;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int entrypoint;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int ImageBase;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int sectiona;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int filea;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int []
datadirectoryrva;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int []
datadirectorysize;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>long
sectionoffset;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>short sections
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
metadatarva;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
entrypointtoken; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int []
SVirtualAddress ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int []
SSizeOfRawData;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int []
SPointerToRawData ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>long
startofmetadata;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>string []
streamnames;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int tableoffset
;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int [] rows;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>long valid ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte []
metadata;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte []
strings;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte [] us;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte [] guid;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte [] blob;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int [] offset;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int [] ssize ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte [][]
names;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
offsetstring = 2;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int offsetblob
= 2;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int offsetguid =
2;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int vtablerva;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int vtablesize;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
exportaddressrva;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
exportaddresssize;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int corflags; </p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>string []
tablenames;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>string
filename;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>public void
InitializeObjects(string [] args)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>{</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>tablenames
= new String[]{&quot;Module&quot; , &quot;TypeRef&quot; ,<span
style='mso-tab-count:1'>            </span>&quot;TypeDef&quot; ,&quot;FieldPtr&quot;,&quot;Field&quot;,
&quot;MethodPtr&quot;,&quot;Method&quot;,&quot;ParamPtr&quot; ,
&quot;Param&quot;, &quot;InterfaceImpl&quot;, &quot;MemberRef&quot;,
&quot;Constant&quot;, &quot;CustomAttribute&quot;, &quot;FieldMarshal&quot;,
&quot;DeclSecurity&quot;, &quot;ClassLayout&quot;, &quot;FieldLayout&quot;,
&quot;StandAloneSig&quot; , &quot;EventMap&quot;,&quot;EventPtr&quot;,
&quot;Event&quot;, &quot;PropertyMap&quot;, &quot;PropertyPtr&quot;,
&quot;Properties&quot;,&quot;MethodSemantics&quot;,&quot;MethodImpl&quot;,&quot;ModuleRef&quot;,&quot;TypeSpec&quot;,&quot;Imp</p>

<p class=ILprg>lMap&quot;,&quot;FieldRVA&quot;,&quot;ENCLog&quot;,&quot;ENCMap&quot;,&quot;Assembly&quot;,</p>

<p class=ILprg>&quot;AssemblyProcessor&quot;,&quot;AssemblyOS&quot;,&quot;AssemblyRef&quot;,&quot;AssemblyRefProcessor&quot;,</p>

<p class=ILprg>&quot;AssemblyRefOS&quot;,&quot;File&quot;,&quot;ExportedType&quot;,&quot;ManifestResource&quot;,</p>

<p class=ILprg>&quot;NestedClass&quot;,&quot;TypeTyPar&quot;,&quot;MethodTyPar&quot;};</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>if ( args.Length == 0)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>filename =
&quot;C:\\mdata\\b.exe&quot;;</p>

<p class=ILprg>else</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>filename =
args[0];</p>

<p class=ILprg>}</p>

<p class=ILprg>public void ReadPEStructures()</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>s = new
FileStream(filename ,FileMode.Open);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>r = new
BinaryReader (s);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>s.Seek(60,
SeekOrigin.Begin);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int ii =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>s.Seek(ii,
SeekOrigin.Begin);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>byte
sig1,sig2,sig3,sig4;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sig1 =
r.ReadByte();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sig2 =
r.ReadByte();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sig3 =
r.ReadByte();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sig4 =
r.ReadByte();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>//First
Structure</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>short machine =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sections =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int time =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int pointer =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int symbols =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int headersize=
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
characteristics = r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sectionoffset =
s.Position + headersize;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>//Second
Structure</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int magic =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int major =
r.ReadByte();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int minor =
r.ReadByte();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int sizeofcode
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int sizeofdata
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int sizeofudata
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>entrypoint =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int baseofcode
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int baseofdata
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>ImageBase = r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>sectiona=
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>filea =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int majoros =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int minoros =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int majorimage
= r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int minorimage
= r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
majorsubsystem= r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
minorsubsystem = r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int verison =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int imagesize =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int
sizeofheaders= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int checksum =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>subsystem =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int dllflags =
r.ReadInt16();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>stackreserve =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>stackcommit =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int heapreserve
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int heapcommit
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>int loader =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>datad =
r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>datadirectoryrva
= new int[16];</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>datadirectorysize
= new int[16];</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>for ( int i = 0
; i &lt;=15 ; i++)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>{</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>datadirectoryrva[i]
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>datadirectorysize[i]
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>}</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>if (
datadirectorysize[14] == 0)</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>throw
new System.Exception(&quot;Not a valid CLR file&quot;);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>s.Position =
sectionoffset ;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>SVirtualAddress
= new int[sections ];</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>SSizeOfRawData
= new int[sections ];</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>SPointerToRawData
= new int[sections ];</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>for ( int i = 0
; i &lt; sections ; i++)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>{</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>r.ReadBytes(12);</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>SVirtualAddress[i]
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>SSizeOfRawData[i]
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>SPointerToRawData[i]
= r.ReadInt32();</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>r.ReadBytes(16);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayPEStructures()</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun: yes"> 
</span>Microsoft (R) .NET Framework IL Disassembler.<span style="mso-spacerun:
yes">  </span>Version 1.0.3705.0&quot;);</p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun: yes"> 
</span>Copyright (C) Microsoft Corporation 1998-2001. All rights
reserved.&quot;);</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>Console.WriteLine(&quot;// PE Header:&quot;);</p>

<p class=ILprg>Console.WriteLine(&quot;// Subsystem:<span style="mso-spacerun:
yes">                     
</span>{0}&quot;,subsystem.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// Native entry point address:<span
style="mso-spacerun: yes">    
</span>{0}&quot;,entrypoint.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// Image base:<span style="mso-spacerun:
yes">                     </span>{0}&quot;,ImageBase.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// Section alignment:<span
style="mso-spacerun: yes">             
</span>{0}&quot;,sectiona.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// File alignment:<span
style="mso-spacerun: yes">                
</span>{0}&quot;,filea.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// Stack reserve size:<span
style="mso-spacerun: yes">             </span>{0}&quot;,stackreserve.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// Stack commit size:<span
style="mso-spacerun: yes">             
</span>{0}&quot;,stackcommit.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;// Directories:<span
style="mso-spacerun: yes">                   
</span>{0}&quot;,datad.ToString(&quot;x8&quot;));</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[0] , datadirectorysize[0]
, &quot;Export Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[1] , datadirectorysize[1]
, &quot;Import Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[2] , datadirectorysize[2]
, &quot;Resource Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[3] , datadirectorysize[3]
, &quot;Exception Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[4] , datadirectorysize[4]
, &quot;Security Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[5] , datadirectorysize[5]
, &quot;Base Relocation Table&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[6] , datadirectorysize[6]
, &quot;Debug Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[7] , datadirectorysize[7]
, &quot;Architecture Specific&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[8] , datadirectorysize[8]
, &quot;Global Pointer&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[9] , datadirectorysize[9]
, &quot;TLS Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[10] ,
datadirectorysize[10] , &quot;Load Config Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[11] ,
datadirectorysize[11] , &quot;Bound Import Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[12] ,
datadirectorysize[12] , &quot;Import Address Table&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[13] ,
datadirectorysize[13] , &quot;Delay Load IAT&quot;);</p>

<p class=ILprg>DisplayDataDirectory(datadirectoryrva[14] ,
datadirectorysize[14] , &quot;CLR Header&quot;);</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayDataDirectory(int rva, int size , string ss)</p>

<p class=ILprg>{</p>

<p class=ILprg>string sfinal =<span style="mso-spacerun: yes"> 
</span>&quot;&quot;;</p>

<p class=ILprg>sfinal = String.Format(&quot;// {0:x}&quot; , rva);</p>

<p class=ILprg>sfinal = sfinal.PadRight(12);</p>

<p class=ILprg>sfinal = sfinal + String.Format(&quot;[{0:x}&quot; , size);</p>

<p class=ILprg>sfinal = sfinal.PadRight(21);</p>

<p class=ILprg>sfinal = sfinal + String.Format(&quot;] address [size] of
{0}:&quot; , ss);</p>

<p class=ILprg>if (ss == &quot;CLR Header&quot;)</p>

<p class=ILprg>sfinal = sfinal.PadRight(67);</p>

<p class=ILprg>else</p>

<p class=ILprg>sfinal = sfinal.PadRight(68);</p>

<p class=ILprg>Console.WriteLine(sfinal);</p>

<p class=ILprg>}</p>

<p class=ILprg>public void ImportAdressTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>long stratofimports = ConvertRVA(datadirectoryrva[1]);</p>

<p class=ILprg>s.Position = stratofimports;</p>

<p class=ILprg>Console.WriteLine(&quot;// Import Address Table&quot;);</p>

<p class=ILprg>int j = 0;</p>

<p class=ILprg>while (true)</p>

<p class=ILprg>{</p>

<p class=ILprg>int rvaimportlookuptable = r.ReadInt32();</p>

<p class=ILprg>if ( rvaimportlookuptable == 0)</p>

<p class=ILprg>break;</p>

<p class=ILprg>int datetimestamp = r.ReadInt32();</p>

<p class=ILprg>int forwarderchain = r.ReadInt32();</p>

<p class=ILprg>int name = r.ReadInt32();</p>

<p class=ILprg>int rvaiat = r.ReadInt32();</p>

<p class=ILprg>s.Position = ConvertRVA(name);</p>

<p class=ILprg>Console.Write(&quot;//<span style="mso-spacerun: yes">    
</span>&quot;);</p>

<p class=ILprg>DisplayStringFromFile();</p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun:
yes">              </span>{0} Import Address Table&quot; ,
rvaiat.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun:
yes">        </span><span style="mso-spacerun: yes">      </span>{0} Import
Name Table&quot; , name.ToString(&quot;x8&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun:
yes">              </span>{0}<span style="mso-spacerun: yes">       
</span>time date stamp&quot; , datetimestamp);</p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun:
yes">              </span>{0}<span style="mso-spacerun: yes">       
</span>Index of first forwarder reference&quot; , forwarderchain);</p>

<p class=ILprg>Console.WriteLine(&quot;//&quot;);</p>

<p class=ILprg>int jj = 0;</p>

<p class=ILprg>while ( true )</p>

<p class=ILprg>{</p>

<p class=ILprg>long<span style="mso-spacerun: yes">  </span>pos =
ConvertRVA(rvaimportlookuptable ) ;</p>

<p class=ILprg>if ( pos == -1)</p>

<p class=ILprg>break;</p>

<p class=ILprg>s.Position = pos + jj * 4;</p>

<p class=ILprg>int pos1 = r.ReadInt32();</p>

<p class=ILprg>if ( pos1 == 0)</p>

<p class=ILprg>break;</p>

<p class=ILprg>pos = ConvertRVA(rvaimportlookuptable ) ;</p>

<p class=ILprg>if ( pos == -1)</p>

<p class=ILprg>break;</p>

<p class=ILprg>s.Position = pos;</p>

<p class=ILprg>short hint = r.ReadInt16();</p>

<p class=ILprg>Console.Write(&quot;//<span style="mso-spacerun:
yes">                  </span>&quot;);</p>

<p class=ILprg>if ( hint.ToString(&quot;X&quot;).Length == 1)</p>

<p class=ILprg>Console.Write(&quot;<span style="mso-spacerun: yes"> 
</span>{0}&quot; , hint.ToString(&quot;x&quot;));</p>

<p class=ILprg>if ( hint.ToString(&quot;X&quot;).Length == 2)</p>

<p class=ILprg>Console.Write(&quot; {0}&quot; , hint.ToString(&quot;x&quot;));</p>

<p class=ILprg>if ( hint.ToString(&quot;X&quot;).Length == 3)</p>

<p class=ILprg>Console.Write(&quot;{0}&quot; , hint.ToString(&quot;x&quot;));</p>

<p class=ILprg>Console.Write(&quot;<span style="mso-spacerun: yes"> 
</span>&quot;);</p>

<p class=ILprg>DisplayStringFromFile();</p>

<p class=ILprg>jj++;</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>j++;</p>

<p class=ILprg>s.Position = stratofimports + j * 20;</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine(&quot;// Delay Load Import Address
Table&quot;);</p>

<p class=ILprg>if (datadirectoryrva[13] == 0)</p>

<p class=ILprg>Console.WriteLine(&quot;// No data.&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayStringFromFile()</p>

<p class=ILprg>{</p>

<p class=ILprg>while ( true )</p>

<p class=ILprg>{</p>

<p class=ILprg>byte b = (byte )s.ReadByte();</p>

<p class=ILprg>if ( b == 0)</p>

<p class=ILprg>break;</p>

<p class=ILprg>Console.Write(&quot;{0}&quot; , (char)b);</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>public void FillTableSizes()</p>

<p class=ILprg>{</p>

<p class=ILprg>int modulesize = 2 + offsetstring + offsetguid + offsetguid +
offsetguid ;</p>

<p class=ILprg>int typerefsize<span style="mso-spacerun: yes">  </span>=
GetCodedIndexSize(&quot;ResolutionScope&quot;) + offsetstring + offsetstring ;</p>

<p class=ILprg>int typedefsize = 4 + offsetstring + offsetstring +
GetCodedIndexSize(&quot;TypeDefOrRef&quot;) + GetTableSize() + GetTableSize();</p>

<p class=ILprg>int fieldsize = 2 + offsetstring + offsetblob ;</p>

<p class=ILprg>int methodsize = 4 + 2 + 2 + offsetstring + offsetblob +
GetTableSize();</p>

<p class=ILprg>int paramsize = 2 + 2 + offsetstring;</p>

<p class=ILprg>int interfaceimplsize = GetTableSize() +
GetCodedIndexSize(&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>int memberrefsize =
GetCodedIndexSize(&quot;MemberRefParent&quot;) + offsetstring<span
style="mso-spacerun: yes">  </span>+ offsetblob ;</p>

<p class=ILprg>int constantsize = 2 + GetCodedIndexSize(&quot;HasConst&quot;) +
offsetblob;</p>

<p class=ILprg>int customattributesize =
GetCodedIndexSize(&quot;HasCustomAttribute&quot;) +
GetCodedIndexSize(&quot;HasCustomAttributeType&quot;) + offsetblob;</p>

<p class=ILprg>int fieldmarshallsize =
GetCodedIndexSize(&quot;HasFieldMarshal&quot;) + offsetblob;</p>

<p class=ILprg>int declsecuritysize = 2 +
GetCodedIndexSize(&quot;HasDeclSecurity&quot;) + offsetblob;</p>

<p class=ILprg>int classlayoutsize = 2 + 4 + GetTableSize();</p>

<p class=ILprg>int fieldlayoutsize = 4 + GetTableSize();</p>

<p class=ILprg>int stanalonssigsize = offsetblob;</p>

<p class=ILprg>int eventmapsize = GetTableSize() +<span style="mso-spacerun:
yes">  </span>GetTableSize();</p>

<p class=ILprg>int eventsize = 2 + offsetstring +
GetCodedIndexSize(&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>int propertymapsize = GetTableSize() + GetTableSize() ;</p>

<p class=ILprg>int propertysize = 2 + offsetstring + offsetblob;</p>

<p class=ILprg>int methodsemantics = 2 + GetTableSize() +
GetCodedIndexSize(&quot;HasSemantics&quot;);</p>

<p class=ILprg>int methodimplsize = GetTableSize() +
GetCodedIndexSize(&quot;MethodDefOrRef&quot;) +
GetCodedIndexSize(&quot;MethodDefOrRef&quot;);</p>

<p class=ILprg>int modulerefsize = offsetstring;</p>

<p class=ILprg>int typespecsize = offsetblob;</p>

<p class=ILprg>int implmapsize = 2 +
GetCodedIndexSize(&quot;MemberForwarded&quot;) + offsetstring + GetTableSize();</p>

<p class=ILprg>int fieldrvasize = 4<span style="mso-spacerun: yes">  </span>+
GetTableSize();</p>

<p class=ILprg>int assemblysize = 4 + 2 + 2 + 2 + 2 + 4 +<span
style="mso-spacerun: yes">  </span>offsetblob + offsetstring + offsetstring ;</p>

<p class=ILprg>int assemblyrefsize = 2 + 2 + 2 + 2 + 4 +<span
style="mso-spacerun: yes">  </span>offsetblob + offsetstring + offsetstring +
offsetblob;</p>

<p class=ILprg>int filesize = 4 + offsetstring + offsetblob;</p>

<p class=ILprg>int exportedtype = 4 + 4 + offsetstring + offsetstring +
GetCodedIndexSize(&quot;Implementation&quot;);</p>

<p class=ILprg>int manifestresourcesize = 4 + 4 + offsetstring +
GetCodedIndexSize(&quot;Implementation&quot;);</p>

<p class=ILprg>int nestedclasssize = GetTableSize() + GetTableSize() ;</p>

<p class=ILprg>sizes = new int[]{ modulesize, typerefsize , typedefsize ,2,
fieldsize ,2,methodsize ,2,paramsize ,interfaceimplsize,memberrefsize
,constantsize ,customattributesize ,fieldmarshallsize ,declsecuritysize
,classlayoutsize ,fieldlayoutsize,stanalonssigsize ,eventmapsize ,2,eventsize
,propertymapsize ,2,propertysize ,methodsemantics ,methodimplsize
,modulerefsize ,typespecsize ,implmapsize ,fieldrvasize ,2 , 2 , assemblysize
,4,12,assemblyrefsize ,6,14,filesize ,exportedtype ,manifestresourcesize
,nestedclasssize };</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetCodedIndexSize(string i)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( i == &quot;Implementation&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x26] &gt;= 16384 || rows[0x23] &gt;= 16384 ||
rows[0x27] &gt;= 16384 )</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;MemberForwarded&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x04] &gt;= 32768 || rows[0x06] &gt;= 32768)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;MethodDefOrRef&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x06] &gt;= 32768 || rows[0x0A] &gt;= 32768)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;HasSemantics&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x14] &gt;= 32768 || rows[0x17] &gt;= 32768)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;HasDeclSecurity&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x02] &gt;= 16384 || rows[0x06] &gt;= 16384 ||
rows[0x20] &gt;= 16384)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;HasFieldMarshal&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x04] &gt;= 32768|| rows[0x08] &gt;= 32768)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;TypeDefOrRef&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x02] &gt;= 16384 || rows[0x01] &gt;= 16384<span
style="mso-spacerun: yes">  </span>|| rows[0x1B] &gt;= 16384<span
style="mso-spacerun: yes">   </span>)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;ResolutionScope&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x00] &gt;= 8192 || rows[0x1a] &gt;= 8192<span
style="mso-spacerun: yes">  </span>|| rows[0x23] &gt;= 8192<span
style="mso-spacerun: yes">  </span>|| rows[0x01] &gt;= 8192 )</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;HasConst&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[4] &gt;= 16384 || rows[8] &gt;= 16384 || rows[0x17]
&gt;= 16384 )</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;MemberRefParent&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x01] &gt;= 8192 || rows[0x1a] &gt;= 8192 ||
rows[0x06] &gt;= 8192 || rows[0x1b] &gt;= 8192<span style="mso-spacerun: yes"> 
</span>)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;HasCustomAttribute&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x06] &gt;= 2048 || rows[0x04] &gt;= 2048 ||
rows[0x01] &gt;= 2048 || rows[0x02] &gt;= 2048 || rows[0x08] &gt;= 2048 ||
rows[0x09] &gt;= 2048 || rows[0x0a] &gt;= 2048 || rows[0x00] &gt;= 2048 ||
rows[0x0e] &gt;= 2048 || rows[0x17] &gt;= 2048 || rows[0x14] &gt;= 2048 ||
rows[0x11] &gt;= 2048 || rows[0x1a] &gt;= 2048 || rows[0x1b] &gt;= 2048 ||
rows[0x20] &gt;= 2048 || rows[0x23] &gt;= 2048 || rows[0x26] &gt;= 2048 ||
rows[0x27] &gt;= 2048 || rows[0x28] &gt;= 2048 )</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( i == &quot;HasCustomAttributeType&quot;)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rows[0x06] &gt;= 8192 || rows[0x0a] &gt;= 8192)</p>

<p class=ILprg>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int ReadCodedIndex(byte [] a , int o , string i)</p>

<p class=ILprg>{</p>

<p class=ILprg>int z = 0;</p>

<p class=ILprg>int z1 = GetCodedIndexSize(i);</p>

<p class=ILprg>if ( z1 == 2)</p>

<p class=ILprg>z = BitConverter.ToUInt16 (a , o );</p>

<p class=ILprg>if ( z1 == 4)</p>

<p class=ILprg>z = (int)BitConverter.ToUInt32 (a , o );</p>

<p class=ILprg>return z;</p>

<p class=ILprg>}</p>

<p class=ILprg>public bool tablepresent(byte i)</p>

<p class=ILprg>{</p>

<p class=ILprg>int p = (int)(valid &gt;&gt; i) <span style='font-family:"Bookman Old Style"'>&amp;</span>
1;</p>

<p class=ILprg>for ( int j = 0 ; j &lt; i ; j++)</p>

<p class=ILprg>{</p>

<p class=ILprg>int o = sizes[j] * rows[j];</p>

<p class=ILprg>tableoffset = tableoffset + o;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( p == 1)</p>

<p class=ILprg>return true;</p>

<p class=ILprg>else</p>

<p class=ILprg>return false;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void ReadTablesIntoStructures()</p>

<p class=ILprg>{</p>

<p class=ILprg>//Module</p>

<p class=ILprg>int old = tableoffset;</p>

<p class=ILprg>bool b = tablepresent(0);</p>

<p class=ILprg>int offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;\n<span style="mso-spacerun: yes">   
</span>Table Details<span style="mso-spacerun: yes">   </span>\n\n&quot;);</p>

<p class=ILprg>Console.WriteLine(&quot;Module Table Offset {0} Size {1}&quot; ,
offs , sizes[0]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ModuleStruct = new ModuleTable[rows[0] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[0] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ModuleStruct[k].Generation = BitConverter.ToUInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>ModuleStruct[k].Name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>ModuleStruct[k].Mvid = ReadGuidIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetguid;</p>

<p class=ILprg>ModuleStruct[k].EncId = ReadGuidIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetguid;</p>

<p class=ILprg>ModuleStruct[k].EncBaseId = ReadGuidIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetguid;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//TypeRef</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(1);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;TypeRef Table Offset {0} Size {1}&quot;
, offs ,<span style="mso-spacerun: yes">  </span>sizes[1]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>typerefnames = new string[rows[1]+1];</p>

<p class=ILprg>TypeRefStruct = new TypeRefTable[rows[1] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;=rows[1] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>TypeRefStruct[k].resolutionscope = ReadCodedIndex(metadata , offs
, &quot;ResolutionScope&quot;);</p>

<p class=ILprg>offs = offs + GetCodedIndexSize(&quot;ResolutionScope&quot;);</p>

<p class=ILprg>TypeRefStruct[k].name = ReadStringIndex(metadata , offs);</p>

<p class=ILprg>typerefnames[k] = GetString(TypeRefStruct[k].name);</p>

<p class=ILprg>offs = offs + offsetstring;</p>

<p class=ILprg>TypeRefStruct[k].nspace = ReadStringIndex(metadata , offs);</p>

<p class=ILprg>offs = offs + offsetstring;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//TypeDef</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(2);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;TypeDef Table Offset {0} Size {1}&quot;
, offs , sizes[2]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>typedefnames = new string[rows[2]+1];</p>

<p class=ILprg>TypeDefStruct = new TypeDefTable[rows[2] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[2] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>TypeDefStruct[k].flags = BitConverter.ToInt32 (metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>TypeDefStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>typedefnames[k] = GetString(TypeDefStruct[k].name);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>TypeDefStruct[k].nspace = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>TypeDefStruct[k].cindex = ReadCodedIndex(metadata , offs ,
&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>TypeDefStruct[k].findex = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>TypeDefStruct[k].mindex = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Field</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(4);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Field Table Offset {0} Size {1}&quot; ,
offs , sizes[4]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldStruct = new FieldTable[rows[4] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[4] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldStruct[k].flags = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>FieldStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>FieldStruct[k].sig = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Method</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(6);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Method Table Offset {0} Size {1}&quot; ,
offs , sizes[6]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>MethodStruct = new MethodTable[rows[6] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[6] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>MethodStruct[k].rva = BitConverter.ToInt32 (metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>MethodStruct[k].impflags = BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>MethodStruct[k].flags = (int)BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>MethodStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>MethodStruct[k].signature = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>MethodStruct[k].param = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Param</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(8);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Param Table Offset {0} Size {1}&quot; ,
offs , sizes[8]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ParamStruct = new ParamTable[rows[8] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[8] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ParamStruct[k].pattr = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>ParamStruct[k].sequence = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>ParamStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//InterfaceImpl</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(9);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;InterfaceImpl Table Offset {0} Size
{1}&quot; , offs , sizes[9]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>InterfaceImplStruct = new InterfaceImplTable[rows[9] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[9] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>InterfaceImplStruct[k].classindex = ReadCodedIndex(metadata ,
offs , &quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>InterfaceImplStruct[k].interfaceindex = ReadTableIndex(metadata,
offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//MemberRef</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(10);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;MemberRef Table Offset {0} Size
{1}&quot; , offs, sizes[10]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>MemberRefStruct = new MemberRefTable[rows[10] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[10] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>MemberRefStruct[k].clas = ReadCodedIndex(metadata , offs ,
&quot;MemberRefParent&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;MemberRefParent&quot;);</p>

<p class=ILprg>MemberRefStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>MemberRefStruct[k].sig = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Constants </p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(11);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Constant Table Offset {0} Size {1}&quot;
, offs, sizes[11]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ConstantsStruct = new ConstantsTable[rows[11] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[11] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ConstantsStruct[k].dtype = metadata[offs];</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>ConstantsStruct[k].parent = ReadCodedIndex(metadata , offs ,
&quot;HasConst&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;HasConst&quot;);</p>

<p class=ILprg>ConstantsStruct[k].value = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//CustomAttribute</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(12);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;CustomAttribute Table Offset {0} Size
{1}&quot; , offs , sizes[12]);</p>

<p class=ILprg>tableoffset = old; </p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>CustomAttributeStruct = new CustomAttributeTable[rows[12] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[12] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>CustomAttributeStruct[k].parent = ReadCodedIndex(metadata , offs
, &quot;HasCustomAttribute&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;HasCustomAttribute&quot;);</p>

<p class=ILprg>CustomAttributeStruct[k].type = ReadCodedIndex(metadata , offs ,
&quot;HasCustomAttributeType&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;HasCustomAttributeType&quot;);</p>

<p class=ILprg>CustomAttributeStruct[k].value = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//FieldMarshal</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(13);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;FieldMarshal Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldMarshalStruct = new FieldMarshalTable[rows[13] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[13] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldMarshalStruct[k].coded = ReadCodedIndex(metadata , offs ,
&quot;HasFieldMarshal&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;HasFieldMarshal&quot;);</p>

<p class=ILprg>FieldMarshalStruct[k].index = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//DeclSecurity</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(14);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;DeclSecurity Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>DeclSecurityStruct = new DeclSecurityTable[rows[14] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[14] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>DeclSecurityStruct[k].action = BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>DeclSecurityStruct[k].coded = ReadCodedIndex(metadata , offs ,
&quot;HasDeclSecurity&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;HasDeclSecurity&quot;);</p>

<p class=ILprg>DeclSecurityStruct[k].bindex = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//ClassLayout</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(15);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;ClassLayout Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ClassLayoutStruct = new ClassLayoutTable[rows[15] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[15] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ClassLayoutStruct[k].packingsize = BitConverter.ToInt16
(metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>ClassLayoutStruct[k].classsize = BitConverter.ToInt32 (metadata,
offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>ClassLayoutStruct[k].parent = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//FieldLayout</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(16);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;FieldLayout Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldLayoutStruct = new FieldLayoutTable[rows[16] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[16] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldLayoutStruct[k].offset = BitConverter.ToInt32 (metadata,
offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>FieldLayoutStruct[k].fieldindex = ReadTableIndex(metadata,
offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//StandAloneSig</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(17);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;StandAloneSig Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>StandAloneSigStruct = new StandAloneSigTable[rows[17] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[17] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>StandAloneSigStruct[k].index = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//EventMap</p>

<p class=ILprg>old = tableoffset ;</p>

<p class=ILprg>b = tablepresent(18);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;EventMap Table Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>EventMapStruct = new EventMapTable [rows[18] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[18] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>EventMapStruct[k].index = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>EventMapStruct[k].eindex = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Event</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(20);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Event Table Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>EventStruct = new EventTable[rows[20] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[20] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>EventStruct[k].attr = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>EventStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>EventStruct[k].coded = ReadCodedIndex(metadata , offs ,
&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;TypeDefOrRef&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//PropertyMap</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(21);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;PropertyMap Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>PropertyMapStruct = new PropertyMapTable[rows[21] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[21] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>PropertyMapStruct[k].parent = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>PropertyMapStruct[k].propertylist = ReadTableIndex(metadata,
offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Property</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(23);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Property Table Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>PropertyStruct = new PropertyTable[rows[23] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[23] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>PropertyStruct[k].flags = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>PropertyStruct[k].name= ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>PropertyStruct[k].type = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//MethodSemantics</p>

<p class=ILprg>old = tableoffset ;</p>

<p class=ILprg>b = tablepresent(24);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;MethodSemantics Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>MethodSemanticsStruct = new MethodSemanticsTable[rows[24] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[24] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>MethodSemanticsStruct[k].methodsemanticsattributes<span
style="mso-spacerun: yes">  </span>= BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>MethodSemanticsStruct[k].methodindex = ReadTableIndex(metadata,
offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>MethodSemanticsStruct[k].association = ReadCodedIndex(metadata ,
offs , &quot;HasSemantics&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;HasSemantics&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//MethodImpl</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(25);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;MethodImpl Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>MethodImpStruct = new MethodImpTable[rows[25] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[25] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>MethodImpStruct[k].classindex = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>MethodImpStruct[k].codedbody = ReadCodedIndex(metadata , offs ,
&quot;MethodDefOrRef&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;MethodDefOrRef&quot;);</p>

<p class=ILprg>MethodImpStruct[k].codeddef = ReadCodedIndex(metadata , offs ,
&quot;MethodDefOrRef&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;MethodDefOrRef&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//ModuleRef</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(26);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;ModuleRef Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ModuleRefStruct = new ModuleRefTable[rows[26] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[26] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ModuleRefStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//TypeSpec</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(27);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;TypeSpec Table Offset {0} size={1}&quot;
, offs , rows[27]);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>TypeSpecStruct = new TypeSpecTable[rows[27] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[27] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>TypeSpecStruct[k].signature = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//ImplMap</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(28);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;ImplMap Table Offset offs={0} rows={1}
len={2}&quot; , offs , rows[28] , metadata.Length);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ImplMapStruct = new ImplMapTable[rows[28] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[28] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ImplMapStruct[k].attr = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>ImplMapStruct[k].cindex = ReadCodedIndex(metadata , offs ,
&quot;MemberForwarded&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;MemberForwarded&quot;);</p>

<p class=ILprg>ImplMapStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>ImplMapStruct[k].scope = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//FieldRVA</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(29);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;FieldRVA Table Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldRVAStruct = new FieldRVATable[rows[29] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[29] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>FieldRVAStruct[k].rva = BitConverter.ToInt32 (metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>FieldRVAStruct[k].fieldi = ReadTableIndex(metadata, offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Assembly</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(32);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Assembly Table Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>AssemblyStruct = new AssemblyTable[rows[32] + 1];</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[32] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>AssemblyStruct[k].HashAlgId = BitConverter.ToInt32 (metadata,
offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>AssemblyStruct[k].major = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyStruct[k].minor = BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyStruct[k].build= BitConverter.ToInt16 (metadata, offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyStruct[k].revision = BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyStruct[k].flags = BitConverter.ToInt32 (metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>AssemblyStruct[k].publickey = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>AssemblyStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>AssemblyStruct[k].culture = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//AssemblyRef</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(35);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;AssembleyRef Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>AssemblyRefStruct = new AssemblyRefTable[rows[35] + 1];</p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[35]; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>AssemblyRefStruct[k].major = BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyRefStruct[k].minor = BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyRefStruct[k].build= BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyRefStruct[k].revision = BitConverter.ToInt16 (metadata,
offs);</p>

<p class=ILprg>offs += 2;</p>

<p class=ILprg>AssemblyRefStruct[k].flags = BitConverter.ToInt32 (metadata,
offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>AssemblyRefStruct[k].publickey = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>AssemblyRefStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>AssemblyRefStruct[k].culture = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>AssemblyRefStruct[k].hashvalue = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//File</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(38);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;File Table Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>FileStruct = new FileTable[rows[38] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[38] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>FileStruct[k].flags = BitConverter.ToInt32 (metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>FileStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>FileStruct[k].index = ReadBlobIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetblob;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//ExportedType</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(39);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;ExportedType Table Offset {0}&quot; ,
offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ExportedTypeStruct = new ExportedTypeTable[rows[39] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[39] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ExportedTypeStruct[k].flags = BitConverter.ToInt32 (metadata,
offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>ExportedTypeStruct[k].typedefindex = BitConverter.ToInt32
(metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>ExportedTypeStruct[k].name = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>ExportedTypeStruct[k].nspace = ReadStringIndex(metadata, offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>ExportedTypeStruct[k].coded = ReadCodedIndex ( metadata, offs ,
&quot;Implementation&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;Implementation&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//ManifestResource</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(40);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;ManifestResource Table Offset {0}&quot;
, offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>ManifestResourceStruct = new ManifestResourceTable[rows[40] +
1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[40] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>ManifestResourceStruct[k].offset = BitConverter.ToInt32
(metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>ManifestResourceStruct[k].flags = BitConverter.ToInt32
(metadata, offs);</p>

<p class=ILprg>offs += 4;</p>

<p class=ILprg>ManifestResourceStruct[k].name = ReadStringIndex(metadata,
offs);</p>

<p class=ILprg>offs += offsetstring;</p>

<p class=ILprg>ManifestResourceStruct[k].coded = ReadCodedIndex(metadata , offs
, &quot;Implementation&quot;);</p>

<p class=ILprg>offs += GetCodedIndexSize(&quot;&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>//Nested Classes</p>

<p class=ILprg>old = tableoffset;</p>

<p class=ILprg>b = tablepresent(41);</p>

<p class=ILprg>offs = tableoffset;</p>

<p class=ILprg>Console.WriteLine(&quot;Nested Classes Offset {0}&quot; , offs);</p>

<p class=ILprg>tableoffset = old;</p>

<p class=ILprg>if ( b )</p>

<p class=ILprg>{</p>

<p class=ILprg>NestedClassStruct = new NestedClassTable[rows[41] + 1]; </p>

<p class=ILprg>for ( int k = 1 ; k &lt;= rows[41] ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>NestedClassStruct[k].nestedclass= ReadTableIndex(metadata,
offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>NestedClassStruct[k].enclosingclass= ReadTableIndex(metadata,
offs);</p>

<p class=ILprg>offs += GetTableSize();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public long ConvertRVA(long rva)</p>

<p class=ILprg>{</p>

<p class=ILprg>int i;</p>

<p class=ILprg>for ( i = 0 ; i &lt; sections ; i++)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( rva &gt;= SVirtualAddress[i]<span style="mso-spacerun:
yes">  </span><span style='font-family:"Bookman Old Style"'>&amp;&amp;</span> (
rva &lt;<span style="mso-spacerun: yes">  </span>SVirtualAddress[i] +
SSizeOfRawData[i] ))</p>

<p class=ILprg>break ;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( i &gt;= SPointerToRawData.Length)</p>

<p class=ILprg>return -1;</p>

<p class=ILprg>return SPointerToRawData[i] + ( rva - SVirtualAddress[i] );</p>

<p class=ILprg>}</p>

<p class=ILprg>public void CLRHeader()</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;// CLR Header:&quot;);</p>

<p class=ILprg>s.Position = ConvertRVA(datadirectoryrva[14]);</p>

<p class=ILprg>int size = r.ReadInt32();</p>

<p class=ILprg>int majorruntimeversion = r.ReadInt16();</p>

<p class=ILprg>int minorruntimeversion = r.ReadInt16();</p>

<p class=ILprg>metadatarva = r.ReadInt32();</p>

<p class=ILprg>int metadatasize = r.ReadInt32();</p>

<p class=ILprg>corflags = r.ReadInt32();</p>

<p class=ILprg>entrypointtoken = r.ReadInt32();</p>

<p class=ILprg>int resourcesrva = r.ReadInt32();</p>

<p class=ILprg>int resourcessize = r.ReadInt32();</p>

<p class=ILprg>int strongnamesigrva = r.ReadInt32();</p>

<p class=ILprg>int strongnamesigsize = r.ReadInt32();</p>

<p class=ILprg>int codemanagerrva = r.ReadInt32();</p>

<p class=ILprg>int codemanagersize = r.ReadInt32();</p>

<p class=ILprg>vtablerva = r.ReadInt32();</p>

<p class=ILprg>vtablesize = r.ReadInt32();</p>

<p class=ILprg>exportaddressrva = r.ReadInt32();</p>

<p class=ILprg>exportaddresssize = r.ReadInt32();</p>

<p class=ILprg>int managednativeheaderrva = r.ReadInt32();</p>

<p class=ILprg>int managednativeheadersize = r.ReadInt32();</p>

<p class=ILprg>Console.WriteLine(&quot;// {0}<span style="mso-spacerun:
yes">       </span>Header Size&quot;, size);</p>

<p class=ILprg>Console.WriteLine(&quot;// {0}<span style="mso-spacerun:
yes">        </span>Major Runtime Version&quot;, majorruntimeversion);</p>

<p class=ILprg>Console.WriteLine(&quot;// {0}<span style="mso-spacerun:
yes">        </span>Minor Runtime Version&quot;, minorruntimeversion);</p>

<p class=ILprg>Console.WriteLine(&quot;// {0}<span style="mso-spacerun:
yes">        </span>Flags&quot;, corflags);</p>

<p class=ILprg>string dummy = &quot;// &quot; + entrypointtoken.ToString(&quot;x&quot;);</p>

<p class=ILprg>dummy = dummy.PadRight(12) + &quot;Entrypoint Token&quot;;</p>

<p class=ILprg>Console.WriteLine(dummy);</p>

<p class=ILprg>DisplayDataDirectory(metadatarva , metadatasize , &quot;Metadata
Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(resourcesrva, resourcessize,
&quot;Resources Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(strongnamesigrva, strongnamesigsize,
&quot;Strong Name Signature&quot;);</p>

<p class=ILprg>DisplayDataDirectory(codemanagerrva, codemanagersize,
&quot;CodeManager Table&quot;);</p>

<p class=ILprg>DisplayDataDirectory(vtablerva, vtablesize, &quot;VTableFixups
Directory&quot;);</p>

<p class=ILprg>DisplayDataDirectory(exportaddressrva, exportaddresssize ,
&quot;Export Address Table&quot;);</p>

<p class=ILprg>DisplayDataDirectory(managednativeheaderrva,
managednativeheadersize, &quot;Precompile Header&quot;);</p>

<p class=ILprg>Console.WriteLine(&quot;// Code Manager Table:&quot;);</p>

<p class=ILprg>if ( codemanagerrva == 0) </p>

<p class=ILprg>Console.WriteLine(&quot;//<span style="mso-spacerun: yes"> 
</span>default&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayStrings()</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n Strings Stream\n&quot;);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[1] ; k ++ )</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0}&quot; , (char) strings[k]);</p>

<p class=ILprg>if ( strings[k] == 0 )</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayUS()</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n US Stream\n&quot;);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[2] ; k +=2 )</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0}&quot; , (char) us[k]);</p>

<p class=ILprg>if ( us[k] == 0 )</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayGuid()</p>

<p class=ILprg>{</p>

<p class=ILprg>int st=1;</p>

<p class=ILprg>Console.WriteLine(&quot;\n GUID Stream\n&quot;);</p>

<p class=ILprg>Console.Write(&quot;{&quot;);</p>

<p class=ILprg>Console.Write(&quot;{0}{1}{2}{3}&quot;, guid[st+2].ToString(&quot;X&quot;)
, guid[st+1].ToString(&quot;X&quot;) , guid[st].ToString(&quot;X&quot;) ,
guid[st-1].ToString(&quot;X&quot;));</p>

<p class=ILprg>Console.Write(&quot;-{0}{1}-&quot;,guid[st+3].ToString(&quot;X&quot;)
, guid[st+4].ToString(&quot;X&quot;));</p>

<p class=ILprg>Console.Write(&quot;{0}{1}-&quot;,guid[st+6].ToString(&quot;X&quot;)
, guid[st+5].ToString(&quot;X&quot;));</p>

<p class=ILprg>Console.Write(&quot;{0}{1}-&quot;,guid[st+7].ToString(&quot;X&quot;)
, guid[st+8].ToString(&quot;X&quot;));</p>

<p class=ILprg>Console.Write(&quot;{0}{1}{2}{3}{4}{5}&quot;,guid[st+9].ToString(&quot;X&quot;),guid[st+10].ToString(&quot;X&quot;),guid[st+11].ToString(&quot;X&quot;),guid[st+12].ToString(&quot;X&quot;),guid[st+13].ToString(&quot;X&quot;),guid[st+14].ToString(&quot;X&quot;));</p>

<p class=ILprg>Console.Write(&quot;}\n&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>public void ReadStreamsData()</p>

<p class=ILprg>{</p>

<p class=ILprg>startofmetadata = ConvertRVA(metadatarva);</p>

<p class=ILprg>Console.WriteLine(&quot;\nMetadata Details\n&quot;);</p>

<p class=ILprg>Console.WriteLine(&quot;Start of Metadata {0} rva={1}&quot; ,
metadatarva , startofmetadata );</p>

<p class=ILprg>s.Position = startofmetadata ;</p>

<p class=ILprg>s.Seek(4 + 2 + 2 + 4 , SeekOrigin.Current);</p>

<p class=ILprg>int lengthofstring = r.ReadInt32();</p>

<p class=ILprg>Console.WriteLine(&quot;Length of String {0}&quot; ,
lengthofstring );</p>

<p class=ILprg>s.Seek(lengthofstring , SeekOrigin.Current);</p>

<p class=ILprg>long padding = s.Position % 4 ;</p>

<p class=ILprg>padding = 4 - padding; </p>

<p class=ILprg>s.Seek(2 , SeekOrigin.Current);</p>

<p class=ILprg>int streams = r.ReadInt16();</p>

<p class=ILprg>Console.WriteLine(&quot;No of streams {0} Position={1}&quot; ,
streams , s.Position);</p>

<p class=ILprg>streamnames = new string[5];</p>

<p class=ILprg>offset = new int[5];</p>

<p class=ILprg>ssize<span style="mso-spacerun: yes">  </span>= new int[5];</p>

<p class=ILprg>names = new byte[5][];</p>

<p class=ILprg>names[0] = new byte[10];</p>

<p class=ILprg>names[1] = new byte[10];</p>

<p class=ILprg>names[2] = new byte[10];</p>

<p class=ILprg>names[3] = new byte[10];</p>

<p class=ILprg>names[4] = new byte[10];</p>

<p class=ILprg>int j ;</p>

<p class=ILprg>Console.WriteLine(&quot;\n Stream Details\n&quot;);</p>

<p class=ILprg>for ( int i = 0 ; i &lt; streams ; i++)</p>

<p class=ILprg>{</p>

<p class=ILprg>offset[i] = r.ReadInt32();</p>

<p class=ILprg>ssize[i] = r.ReadInt32();</p>

<p class=ILprg>Console.WriteLine(&quot;offset={0} size={1} Position={2}&quot; ,
offset[i] , ssize[i] , s.Position);</p>

<p class=ILprg>j = 0;</p>

<p class=ILprg>byte bb ;</p>

<p class=ILprg>while ( true )</p>

<p class=ILprg>{</p>

<p class=ILprg>bb = r.ReadByte();</p>

<p class=ILprg>if ( bb == 0)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>break;</p>

<p class=ILprg>names[i][j] = bb;</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>j++;</p>

<p class=ILprg>}</p>

<p class=ILprg>names[i][j] = bb;</p>

<p class=ILprg>streamnames[i] = GetStreamNames(names[i]);</p>

<p class=ILprg>while ( true )</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( s.Position % 4 == 0 ) </p>

<p class=ILprg>break;</p>

<p class=ILprg>byte<span style="mso-spacerun: yes">  </span>b = r.ReadByte();</p>

<p class=ILprg>if ( b != 0)</p>

<p class=ILprg>{</p>

<p class=ILprg>s.Seek(-1, SeekOrigin.Current);</p>

<p class=ILprg>break;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>for ( int i = 0 ; i &lt; streams ; i++)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( streamnames[i]<span style="mso-spacerun: yes">  </span>==
&quot;#~&quot; ) </p>

<p class=ILprg>{</p>

<p class=ILprg>metadata = new byte[ssize[i]];</p>

<p class=ILprg>s.Seek(startofmetadata + offset[i] , SeekOrigin.Begin);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[i] ; k ++)</p>

<p class=ILprg>metadata[k] = r.ReadByte(); </p>

<p class=ILprg>}</p>

<p class=ILprg>if ( streamnames[i]<span style="mso-spacerun: yes">  </span>==
&quot;#Strings&quot; ) </p>

<p class=ILprg>{</p>

<p class=ILprg>strings = new byte[ssize[i]];</p>

<p class=ILprg>s.Seek(startofmetadata + offset[i] , SeekOrigin.Begin);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[i] ; k ++)</p>

<p class=ILprg>strings[k] = r.ReadByte(); </p>

<p class=ILprg>DisplayStrings();</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( streamnames[i]<span style="mso-spacerun: yes">  </span>==
&quot;#US&quot; ) </p>

<p class=ILprg>{</p>

<p class=ILprg>us = new byte[ssize[i]];</p>

<p class=ILprg>s.Seek(startofmetadata<span style="mso-spacerun: yes">  </span>+
offset[i] , SeekOrigin.Begin);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[i] ; k ++)</p>

<p class=ILprg>us[k] = r.ReadByte(); </p>

<p class=ILprg>DisplayUS();</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( streamnames[i]<span style="mso-spacerun: yes">  </span>==
&quot;#GUID&quot; ) </p>

<p class=ILprg>{</p>

<p class=ILprg>guid = new byte[ssize[i]];</p>

<p class=ILprg>s.Seek(startofmetadata<span style="mso-spacerun: yes">  </span>+
offset[i] , SeekOrigin.Begin);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[i] ; k ++)</p>

<p class=ILprg>guid[k] = r.ReadByte(); </p>

<p class=ILprg>DisplayGuid();</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( streamnames[i]<span style="mso-spacerun: yes">  </span>==
&quot;#Blob&quot; ) </p>

<p class=ILprg>{</p>

<p class=ILprg>blob = new byte[ssize[i]];</p>

<p class=ILprg>s.Seek(startofmetadata<span style="mso-spacerun: yes">  </span>+
offset[i] , SeekOrigin.Begin);</p>

<p class=ILprg>for ( int k = 0 ; k &lt; ssize[i] ; k ++)</p>

<p class=ILprg>blob[k] = r.ReadByte(); </p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine(&quot;\n Stream offset and stream
size\n&quot;);</p>

<p class=ILprg>for ( int i = 0 ; i &lt; streams ; i++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}...offset: {1} size:{2}&quot; ,
streamnames[i] ,<span style="mso-spacerun: yes">  </span>offset[i] , ssize[i]);</p>

<p class=ILprg>}</p>

<p class=ILprg>int heapsizes = metadata[6];</p>

<p class=ILprg>if ( (heapsizes <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x01) == 0x01)</p>

<p class=ILprg>offsetstring<span style="mso-spacerun: yes">  </span>= 4;</p>

<p class=ILprg>if ( (heapsizes <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x02) == 0x02)</p>

<p class=ILprg>offsetguid = 4;</p>

<p class=ILprg>if ( (heapsizes <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x04) == 0x04)</p>

<p class=ILprg>offsetblob = 4;</p>

<p class=ILprg>valid = BitConverter.ToInt64(metadata, 8);</p>

<p class=ILprg>tableoffset = 24;</p>

<p class=ILprg>rows = new int[64];</p>

<p class=ILprg>Array.Clear (rows, 0, rows.Length);</p>

<p class=ILprg>for ( int k = 0 ; k &lt;= 63 ; k++)</p>

<p class=ILprg>{</p>

<p class=ILprg>int tablepresent = (int)(valid &gt;&gt; k ) <span
style='font-family:"Bookman Old Style"'>&amp;</span> 1; </p>

<p class=ILprg>if ( tablepresent == 1)</p>

<p class=ILprg>{</p>

<p class=ILprg>rows[k] = BitConverter.ToInt32(metadata , tableoffset);</p>

<p class=ILprg>tableoffset += 4;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine(&quot;\nNumber of Rows in the tables:
\n&quot;);</p>

<p class=ILprg>for ( int k = 62 ; k &gt;= 0 ; k--)</p>

<p class=ILprg>{</p>

<p class=ILprg>int tablepresent = (int)(valid &gt;&gt; k ) <span
style='font-family:"Bookman Old Style"'>&amp;</span> 1; </p>

<p class=ILprg>if ( tablepresent == 1)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}<span style="mso-spacerun: yes"> 
</span>:<span style="mso-spacerun: yes">  </span>{1}&quot; , tablenames[k] ,
rows[k]);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetStreamNames(byte [] b)</p>

<p class=ILprg>{</p>

<p class=ILprg>int i = 0;</p>

<p class=ILprg>while (b[i] != 0 )</p>

<p class=ILprg>{</p>

<p class=ILprg>i++;</p>

<p class=ILprg>}</p>

<p class=ILprg>System.Text.Encoding e = System.Text.Encoding.UTF8;</p>

<p class=ILprg>string<span style="mso-spacerun: yes">  </span>s = e.GetString(b
, 0 , i<span style="mso-spacerun: yes">  </span>);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetTableSize()</p>

<p class=ILprg>{</p>

<p class=ILprg>return 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int ReadStringIndex(byte [] a , int o)</p>

<p class=ILprg>{</p>

<p class=ILprg>int z = 0;</p>

<p class=ILprg>if ( offsetstring == 2)</p>

<p class=ILprg>z = BitConverter.ToUInt16 (a , o );</p>

<p class=ILprg>if ( offsetstring == 4)</p>

<p class=ILprg>z = (int)BitConverter.ToUInt32 (a , o );</p>

<p class=ILprg>return z;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int ReadBlobIndex(byte [] a , int o)</p>

<p class=ILprg>{</p>

<p class=ILprg>int z = 0;</p>

<p class=ILprg>if ( offsetblob == 2)</p>

<p class=ILprg>z = BitConverter.ToUInt16 (a , o );</p>

<p class=ILprg>if ( offsetblob == 4)</p>

<p class=ILprg>z = (int)BitConverter.ToUInt32 (a , o );</p>

<p class=ILprg>return z;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int ReadGuidIndex(byte [] a , int o)</p>

<p class=ILprg>{</p>

<p class=ILprg>int z = 0;</p>

<p class=ILprg>if ( offsetguid == 2)</p>

<p class=ILprg>z = BitConverter.ToUInt16 (a , o );</p>

<p class=ILprg>if ( offsetguid == 4)</p>

<p class=ILprg>z = (int)BitConverter.ToUInt32 (a , o );</p>

<p class=ILprg>return z;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int ReadTableIndex(byte [] a , int o)</p>

<p class=ILprg>{</p>

<p class=ILprg>int z = 0;</p>

<p class=ILprg>int z1 = GetTableSize();</p>

<p class=ILprg>if ( z1 == 2)</p>

<p class=ILprg>z = BitConverter.ToUInt16 (a , o );</p>

<p class=ILprg>if ( z1 == 4)</p>

<p class=ILprg>z = (int)BitConverter.ToUInt32 (a , o );</p>

<p class=ILprg>return z;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAllMethods (int i)</p>

<p class=ILprg>{</p>

<p class=ILprg>int start , startofnext=0;</p>

<p class=ILprg>start =<span style="mso-spacerun: yes"> 
</span>TypeDefStruct[i].mindex ;</p>

<p class=ILprg>if ( i == (TypeDefStruct.Length -1) )</p>

<p class=ILprg>{</p>

<p class=ILprg>startofnext= MethodStruct.Length;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>startofnext = TypeDefStruct[i+1].mindex ;</p>

<p class=ILprg>Console.WriteLine(&quot;Number Of Methods {0}&quot; ,
startofnext - start);</p>

<p class=ILprg>for ( int j = start ; j &lt; startofnext ; j++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}. {1}&quot;, j ,
GetString(MethodStruct[j].name));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAllFields (int i)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( FieldStruct == null)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>return;</p>

<p class=ILprg>int start , startofnext=0;</p>

<p class=ILprg>start =<span style="mso-spacerun: yes"> 
</span>TypeDefStruct[i].findex ;</p>

<p class=ILprg>if ( i == (TypeDefStruct.Length -1) )</p>

<p class=ILprg>{</p>

<p class=ILprg>startofnext= FieldStruct.Length;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>startofnext = TypeDefStruct[i+1].findex ;</p>

<p class=ILprg>Console.WriteLine(&quot;Number Of Fields {0}&quot; , startofnext
- start);</p>

<p class=ILprg>for ( int j = start ; j &lt; startofnext ; j++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}. {1}&quot;, j ,
GetString(FieldStruct[j].name));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAllParams (int i)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ParamStruct== null)</p>

<p class=ILprg>return;</p>

<p class=ILprg>int start , startofnext=0;</p>

<p class=ILprg>start =<span style="mso-spacerun: yes"> 
</span>MethodStruct[i].param;</p>

<p class=ILprg>if ( i == (MethodStruct.Length -1) )</p>

<p class=ILprg>{</p>

<p class=ILprg>startofnext= ParamStruct.Length;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>startofnext = MethodStruct[i+1].param ;</p>

<p class=ILprg>Console.WriteLine(&quot;Number Of Params {0}&quot; , startofnext
- start);</p>

<p class=ILprg>for ( int j = start ; j &lt; startofnext ; j++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}. {1}&quot;, j ,
GetString(ParamStruct[j].name));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAllEvents(int i)</p>

<p class=ILprg>{</p>

<p class=ILprg>int ii;</p>

<p class=ILprg>if ( EventMapStruct == null )</p>

<p class=ILprg>return;</p>

<p class=ILprg>for ( ii = 1 ; ii &lt; EventMapStruct.Length ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( i == (EventMapStruct[ii].index ) )</p>

<p class=ILprg>break;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( ii == EventMapStruct.Length)</p>

<p class=ILprg>return;</p>

<p class=ILprg>int start = EventMapStruct[ii].eindex;</p>

<p class=ILprg>int end;</p>

<p class=ILprg>if ( ii == EventMapStruct.Length -1 )</p>

<p class=ILprg>end = EventStruct.Length - 1; </p>

<p class=ILprg>else</p>

<p class=ILprg>end =<span style="mso-spacerun: yes">  </span>EventMapStruct[ii
+ 1].eindex -1;</p>

<p class=ILprg>Console.WriteLine(&quot;Number of Events {0}&quot; , end - start
+ 1);</p>

<p class=ILprg>for ( int jj = start ; jj &lt;= end ; jj++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}. {1}&quot; , jj , GetString(EventStruct[jj].name));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAllProperties(int i)</p>

<p class=ILprg>{</p>

<p class=ILprg>int ii;</p>

<p class=ILprg>if ( PropertyMapStruct == null || PropertyMapStruct.Length == 1
)</p>

<p class=ILprg>return; </p>

<p class=ILprg>for ( ii = 1 ; ii &lt; PropertyMapStruct.Length ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( i == (PropertyMapStruct[ii].parent) )</p>

<p class=ILprg>break;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( ii == PropertyMapStruct.Length)</p>

<p class=ILprg>return;</p>

<p class=ILprg>int start = PropertyMapStruct[ii].propertylist;</p>

<p class=ILprg>int end;</p>

<p class=ILprg>if ( ii+1 == PropertyMapStruct.Length )</p>

<p class=ILprg>end = PropertyStruct.Length - 1; </p>

<p class=ILprg>else</p>

<p class=ILprg>end =<span style="mso-spacerun: yes"> 
</span>PropertyMapStruct[ii + 1].propertylist -1;</p>

<p class=ILprg>Console.WriteLine(&quot;Number of Properties {0}&quot; , end -
start + 1);</p>

<p class=ILprg>for ( int jj = start ; jj &lt;= end ; jj++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0}. {1}&quot; , jj ,
GetString(PropertyStruct[jj].name));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetString(int starting)</p>

<p class=ILprg>{</p>

<p class=ILprg>int i = starting;</p>

<p class=ILprg>while (strings[i] != 0 )</p>

<p class=ILprg>{</p>

<p class=ILprg>i++;</p>

<p class=ILprg>}</p>

<p class=ILprg>System.Text.Encoding e = System.Text.Encoding.UTF8;</p>

<p class=ILprg>string<span style="mso-spacerun: yes">  </span>s =
e.GetString(strings, starting , i - starting<span style="mso-spacerun: yes"> 
</span>);</p>

<p class=ILprg>if ( s.Length == 0)</p>

<p class=ILprg>return &quot;&quot;;</p>

<p class=ILprg>else</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int CorSigUncompressData( byte [] b , int index , out int
answer)</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb = 0;</p>

<p class=ILprg>answer = 0;</p>

<p class=ILprg>if ( (b[index] <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x80) == 0x00)</p>

<p class=ILprg>{</p>

<p class=ILprg>cb = 1;</p>

<p class=ILprg>answer = b[index];</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( (b[index] <span style='font-family:"Bookman Old Style"'>&amp;</span>
0xC0) == 0x80)</p>

<p class=ILprg>{</p>

<p class=ILprg>cb = 2;</p>

<p class=ILprg>answer = ((b[index] <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x3f) &lt;&lt;8 ) |<span style="mso-spacerun: yes">  </span>b[index+1];</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( (b[index] <span style='font-family:"Bookman Old Style"'>&amp;</span>
0xE0) == 0xC0)</p>

<p class=ILprg>{</p>

<p class=ILprg>cb = 3;</p>

<p class=ILprg>answer = ((b[index] <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x1f) &lt;&lt;24 ) |<span style="mso-spacerun: yes">  </span>(b[index+1] &lt;&lt;
16) |<span style="mso-spacerun: yes">  </span>(b[index+2] &lt;&lt; 8) |
b[index+3];</p>

<p class=ILprg>}</p>

<p class=ILprg>return cb;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetType(int b)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( b == 0x01)</p>

<p class=ILprg>return &quot;void&quot;;</p>

<p class=ILprg>if ( b == 0x02)</p>

<p class=ILprg>return &quot;bool&quot;;</p>

<p class=ILprg>if ( b == 0x03)</p>

<p class=ILprg>return &quot;char&quot;;</p>

<p class=ILprg>if ( b == 0x04)</p>

<p class=ILprg>return &quot;int8&quot;;</p>

<p class=ILprg>if ( b == 0x05)</p>

<p class=ILprg>return &quot;unsigned int8&quot;;</p>

<p class=ILprg>if ( b == 0x06)</p>

<p class=ILprg>return &quot;int16&quot;;</p>

<p class=ILprg>if ( b == 0x07)</p>

<p class=ILprg>return &quot;unsigned int16&quot;;</p>

<p class=ILprg>if ( b == 0x08)</p>

<p class=ILprg>return &quot;int32&quot;;</p>

<p class=ILprg>if ( b == 0x09)</p>

<p class=ILprg>return &quot;unsigned int32&quot;;</p>

<p class=ILprg>if ( b == 0x0a)</p>

<p class=ILprg>return &quot;int64&quot;;</p>

<p class=ILprg>if ( b == 0x0b)</p>

<p class=ILprg>return &quot;unsigned int64&quot;;</p>

<p class=ILprg>if ( b == 0x0c)</p>

<p class=ILprg>return &quot;float32&quot;;</p>

<p class=ILprg>if ( b == 0x0d)</p>

<p class=ILprg>return &quot;float64&quot;;</p>

<p class=ILprg>if ( b == 0x0e)</p>

<p class=ILprg>return &quot;string&quot;;</p>

<p class=ILprg>if ( b == 0x0f)</p>

<p class=ILprg>return &quot;pointer&quot;;</p>

<p class=ILprg>if ( b == 0x10)</p>

<p class=ILprg>return &quot;referencetype&quot;;</p>

<p class=ILprg>if ( b== 0x11)</p>

<p class=ILprg>return &quot;valuetype&quot;;</p>

<p class=ILprg>if ( b== 0x12)</p>

<p class=ILprg>return &quot;class&quot;;</p>

<p class=ILprg>if ( b== 0x14)</p>

<p class=ILprg>return &quot;array&quot;;</p>

<p class=ILprg>if ( b== 0x16)</p>

<p class=ILprg>return &quot;typed byref&quot;;</p>

<p class=ILprg>if ( b== 0x18)</p>

<p class=ILprg>return &quot;intptr&quot;;</p>

<p class=ILprg>if ( b== 0x19)</p>

<p class=ILprg>return &quot;uintptr&quot;;</p>

<p class=ILprg>if ( b== 0x1b)</p>

<p class=ILprg>return &quot;function ptr&quot;;</p>

<p class=ILprg>if ( b== 0x1c)</p>

<p class=ILprg>return &quot;object&quot;;</p>

<p class=ILprg>if ( b== 0x1d)</p>

<p class=ILprg>return &quot;sd array&quot;;</p>

<p class=ILprg>if ( b== 0x1f)</p>

<p class=ILprg>return &quot;reqd mod&quot;;</p>

<p class=ILprg>if ( b== 0x20)</p>

<p class=ILprg>return &quot;opt mod&quot;;</p>

<p class=ILprg>if ( b== 0x21)</p>

<p class=ILprg>return &quot;internal&quot;;</p>

<p class=ILprg>if ( b== 0x40)</p>

<p class=ILprg>return &quot;typed mod&quot;;</p>

<p class=ILprg>if ( b== 0x41)</p>

<p class=ILprg>return &quot;sentinel&quot;;</p>

<p class=ILprg>if ( b== 0x45)</p>

<p class=ILprg>return &quot;pinned&quot;;</p>

<p class=ILprg>return &quot;user defined...unknown&quot;;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetCustomAttributeTypeTable( int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span><span
style="mso-spacerun: yes">  </span>0x07;</p>

<p class=ILprg>if ( tag == 0)</p>

<p class=ILprg>s = s + &quot;NotUsed&quot;;</p>

<p class=ILprg>if ( tag == 1)</p>

<p class=ILprg>s = s + &quot;NotUsed&quot;;</p>

<p class=ILprg>if ( tag == 2)</p>

<p class=ILprg>s = s + &quot;MethodDef&quot;;</p>

<p class=ILprg>if ( tag == 3)</p>

<p class=ILprg>s = s + &quot;MethodRef&quot;;</p>

<p class=ILprg>if ( tag == 4)</p>

<p class=ILprg>s = s + &quot;NotUsed&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetResolutionScopeValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetResolutionScopeTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x03;</p>

<p class=ILprg>if ( tag == 0 )</p>

<p class=ILprg>s = s + &quot;Module&quot;<span style="mso-spacerun: yes"> 
</span>;</p>

<p class=ILprg>if ( tag == 1 )</p>

<p class=ILprg>s = s + &quot;ModuleRef&quot;<span style="mso-spacerun: yes"> 
</span>;</p>

<p class=ILprg>if ( tag == 2 )</p>

<p class=ILprg>s = s + &quot;AssemblyRef&quot;<span style="mso-spacerun: yes"> 
</span>;</p>

<p class=ILprg>if ( tag == 3 )</p>

<p class=ILprg>s = s + &quot;TypeRef&quot;<span style="mso-spacerun: yes"> 
</span>;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayModuleTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if( ModuleStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nModule Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ModuleStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Generation: {0}&quot;
,ModuleStruct[ii].Generation );</p>

<p class=ILprg>Console.WriteLine(&quot;Name<span style="mso-spacerun:
yes">      </span>:{0} {1}&quot; ,<span style="mso-spacerun: yes"> 
</span>GetString(ModuleStruct[ii].Name) ,
ModuleStruct[ii].Name.ToString(&quot;X&quot;));</p>

<p class=ILprg>Console.WriteLine(&quot;Mvid<span style="mso-spacerun:
yes">      </span>:#GUID[{0}]&quot; , ModuleStruct[ii].Mvid);</p>

<p class=ILprg>Console.WriteLine(&quot;EncId<span style="mso-spacerun:
yes">     </span>:#GUID[{0}]&quot; , ModuleStruct[ii].EncId );</p>

<p class=ILprg>Console.WriteLine(&quot;EncBaseId :#GUID[{0}]&quot; ,
ModuleStruct[ii].EncBaseId);</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayTypeRefTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( TypeRefStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nTypeRef Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= TypeRefStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row[{0}]&quot; , ii);</p>

<p class=ILprg>string tablename =
GetResolutionScopeTable(TypeRefStruct[ii].resolutionscope) ;</p>

<p class=ILprg>int index =
GetResolutionScopeValue(TypeRefStruct[ii].resolutionscope);</p>

<p class=ILprg>string s = DisplayTable(tablename ,index );</p>

<p class=ILprg>Console.WriteLine(&quot;ResolutionScope:{0}[{1}]...{2} &quot; ,
tablename , index,s );</p>

<p class=ILprg>Console.WriteLine(&quot;Name<span style="mso-spacerun:
yes">           </span>:{0}&quot;,GetString(TypeRefStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;Namespace<span style="mso-spacerun:
yes">      </span>:{0}&quot;,GetString(TypeRefStruct[ii].nspace));</p>

<p class=ILprg>Console.WriteLine(&quot;\n&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayTypeDefTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if (TypeDefStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;TypeDefTable\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= TypeDefStruct.Length -1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row:{0}&quot; , ii);</p>

<p class=ILprg>TypeAttributes flags = (TypeAttributes)TypeDefStruct[ii].flags;</p>

<p class=ILprg>Console.WriteLine(&quot;Flags<span style="mso-spacerun:
yes">     </span>: {0}&quot; , flags);</p>

<p class=ILprg>Console.WriteLine(&quot;Name<span style="mso-spacerun:
yes">      </span>: {0}&quot; , GetString(TypeDefStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;NameSpace : {0}&quot; ,
GetString(TypeDefStruct[ii].nspace));</p>

<p class=ILprg>string tablename =
GetTypeDefOrRefTable(TypeDefStruct[ii].cindex);</p>

<p class=ILprg>int index = GetTypeDefOrRefValue(TypeDefStruct[ii].cindex);</p>

<p class=ILprg>string s = DisplayTable(tablename , index);</p>

<p class=ILprg>Console.WriteLine(&quot;Extends:
{0}[{1}].....{2}&quot;,tablename,index, s);</p>

<p class=ILprg>Console.WriteLine(&quot;FieldList Field[{0}]&quot;,
TypeDefStruct[ii].findex);</p>

<p class=ILprg>Console.WriteLine(&quot;MethodList Method[{0}]&quot;,
TypeDefStruct[ii].mindex);</p>

<p class=ILprg>DisplayAllMethods(ii);</p>

<p class=ILprg>DisplayAllFields(ii);</p>

<p class=ILprg>DisplayAllEvents(ii);</p>

<p class=ILprg>DisplayAllProperties(ii);</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayNestedClassTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if( NestedClassStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nNested Classes Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= NestedClassStruct.Length - 1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot;,ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Nested<span style="mso-spacerun:
yes">    </span>Class TypeDef[{0}]...{1}&quot; , <span style='mso-tab-count:
3'>                         </span><span style='mso-tab-count:1'>            </span>NestedClassStruct[ii].nestedclass,GetTypeDefTable(NestedClassStruct[ii].nestedclass
));</p>

<p class=ILprg>Console.WriteLine(&quot;Enclosing Class TypeDef[{0}]...{1}&quot;
,<span style="mso-spacerun: yes">    
</span>NestedClassStruct[ii].enclosingclass,GetTypeDefTable(NestedClassStruct[ii].enclosingclass
));</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DisplayFieldSignature(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string<span style="mso-spacerun: yes">  </span>s = &quot;&quot;;</p>

<p class=ILprg>int count = blob[index];</p>

<p class=ILprg>Console.WriteLine(&quot;count {0} index {1}&quot;,count, index);</p>

<p class=ILprg>for ( int l = 1; l &lt;= count ; l++)</p>

<p class=ILprg>s = s + blob[index+l].ToString() + &quot; &quot;; </p>

<p class=ILprg>if ( blob[index+1] == 0x06)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = s+&quot;..&quot;+GetType(blob[index+2]);</p>

<p class=ILprg>}</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayFieldTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( FieldStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nFieldTable\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= FieldStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot;,ii );</p>

<p class=ILprg>Console.WriteLine(&quot;Flags: {0}&quot;,
FieldStruct[ii].flags);</p>

<p class=ILprg>Console.WriteLine(&quot;Name : {0}&quot;,
GetString(FieldStruct[ii].name));</p>

<p class=ILprg>string s = DisplayFieldSignature(FieldStruct[ii].sig); </p>

<p class=ILprg>Console.WriteLine(&quot;Signature BLOB[{0}]...{1}&quot;,
FieldStruct[ii].sig,s );</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayMethodTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if (MethodStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nMethod Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= MethodStruct.Length -1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row<span style="mso-spacerun: yes">     
</span>:{0}&quot;, ii);</p>

<p class=ILprg>Console.WriteLine(&quot;RVA<span style="mso-spacerun: yes">     
</span>:{0}&quot;, MethodStruct[ii].rva.ToString(&quot;X&quot;));</p>

<p class=ILprg>MethodImplAttributes impflags = (MethodImplAttributes )
MethodStruct[ii].impflags;</p>

<p class=ILprg>Console.WriteLine(&quot;ImpFlags :{0}&quot;,impflags );</p>

<p class=ILprg>Console.WriteLine(&quot;Flags<span style="mso-spacerun: yes">   
</span>:{0}&quot;,MethodStruct[ii].flags);</p>

<p class=ILprg>Console.WriteLine(&quot;Name<span style="mso-spacerun: yes">    
</span>: {0}&quot;, GetString(MethodStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;Signature:
#Blob[{0}]&quot;,MethodStruct[ii].signature);</p>

<p class=ILprg>Console.WriteLine(&quot;ParamList: Param[{0}]&quot;,MethodStruct[ii].param);</p>

<p class=ILprg>DisplayAllParams(ii);</p>

<p class=ILprg>DisplayMethodSignature(MethodStruct[ii].signature, ii);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetParamAttributes(short a)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( a == 0x00)</p>

<p class=ILprg>return &quot;None&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x01) == 0x01)</p>

<p class=ILprg>return &quot;[In]&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x02) == 0x02)</p>

<p class=ILprg>return &quot;[Out]&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x04) == 0x04)</p>

<p class=ILprg>return &quot;[Optional]&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x1000) == 0x1000)</p>

<p class=ILprg>return &quot;[Default]&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x2000) == 0x2000)</p>

<p class=ILprg>return &quot;[Field Marshal]&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0xcfe0) == 0xcfe0)</p>

<p class=ILprg>return &quot;[Field Marshall]&quot;;</p>

<p class=ILprg>return &quot;Unknown&quot;;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayParamTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ParamStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>Console.WriteLine(&quot;\nParam Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ParamStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;ParamAttributes {0} Bytes {1}&quot; ,
GetParamAttributes(ParamStruct[ii].pattr) ,<span style="mso-spacerun:
yes">          </span>ParamStruct[ii].pattr.ToString(&quot;X&quot;) );</p>

<p class=ILprg>Console.WriteLine(&quot;Sequence {0}&quot; ,
ParamStruct[ii].sequence );</p>

<p class=ILprg>Console.WriteLine(&quot;Name {0}&quot; ,
GetString(ParamStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;\n&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayInterfaceImplTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( InterfaceImplStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;InterfaceImpl Table&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= InterfaceImplStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>int ind = InterfaceImplStruct[ii].classindex ;</p>

<p class=ILprg>Console.WriteLine(&quot;Class TypeDef[{0}]...{1}&quot; , ind ,
GetTypeDefTable(ind) );</p>

<p class=ILprg>string tablename =
GetTypeDefOrRefTable(InterfaceImplStruct[ii].interfaceindex);</p>

<p class=ILprg>int index =
GetTypeDefOrRefValue(InterfaceImplStruct[ii].interfaceindex);</p>

<p class=ILprg>Console.WriteLine(&quot;Interface {0}[{1}] {2}&quot; , tablename
, index , DisplayTable(tablename , index));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetCallingConvention ( int uncompressedbyte )</p>

<p class=ILprg>{</p>

<p class=ILprg>int firstbyte = uncompressedbyte;</p>

<p class=ILprg>byte firstfourbits = (byte)(firstbyte <span style='font-family:
"Bookman Old Style"'>&amp;</span> 0x0f);</p>

<p class=ILprg>string s = &quot;<span style="mso-spacerun: yes"> 
</span>Calling Convention &quot;;</p>

<p class=ILprg>if ( firstfourbits == 0x00)</p>

<p class=ILprg>s = s + &quot; DEFAULT &quot;;</p>

<p class=ILprg>if ( firstfourbits == 0x01)</p>

<p class=ILprg>s = s + &quot; C &quot;;</p>

<p class=ILprg>if ( firstfourbits == 0x02)</p>

<p class=ILprg>s = s + &quot; STDCALL &quot;;</p>

<p class=ILprg>if ( firstfourbits == 0x03)</p>

<p class=ILprg>s = s + &quot; THISCALL &quot;;</p>

<p class=ILprg>if ( firstfourbits == 0x04)</p>

<p class=ILprg>s = s + &quot; FASTCALL &quot;;</p>

<p class=ILprg>if ( firstfourbits == 0x05)</p>

<p class=ILprg>s = s + &quot; VARARG &quot;;</p>

<p class=ILprg>if ( (firstbyte <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x20) == 0x20)</p>

<p class=ILprg>s = s + &quot; HASTHIS &quot;;</p>

<p class=ILprg>if ( (firstbyte <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x40) == 0x40)</p>

<p class=ILprg>s = s + &quot; EXPLICIT &quot;;</p>

<p class=ILprg>s = s + &quot;\n&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetValueType(byte [] b , int bytes , int index ,
out int cb1)</p>

<p class=ILprg>{</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = CorSigUncompressData(b , index + 1 , out
uncompressedbyte);</p>

<p class=ILprg>byte table = (byte)(uncompressedbyte <span style='font-family:
"Bookman Old Style"'>&amp;</span> 0x03);</p>

<p class=ILprg>int ind = uncompressedbyte &gt;&gt; 2;</p>

<p class=ILprg>string s1= &quot;&quot;;</p>

<p class=ILprg>if ( table == 1)</p>

<p class=ILprg>s1 = typerefnames[ind];</p>

<p class=ILprg>if ( table == 0)</p>

<p class=ILprg>s1 = typedefnames[ind];</p>

<p class=ILprg>cb1 = cb;</p>

<p class=ILprg>return s1;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetClassType(byte [] b , int bytes , int index ,
out int cb1)</p>

<p class=ILprg>{</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = CorSigUncompressData(b , index + 1 , out
uncompressedbyte);</p>

<p class=ILprg>Console.WriteLine(&quot;Token Count cb={0}
uncompresedbyte={1}&quot;, cb,uncompressedbyte);</p>

<p class=ILprg>byte table = (byte)(uncompressedbyte <span style='font-family:
"Bookman Old Style"'>&amp;</span> 0x03);</p>

<p class=ILprg>int ind = uncompressedbyte &gt;&gt; 2;</p>

<p class=ILprg>Console.WriteLine(&quot;Token Table={0} index={1}&quot;, table
,ind);</p>

<p class=ILprg>string s1= &quot;&quot;;</p>

<p class=ILprg>if ( table == 1)</p>

<p class=ILprg>s1 = typerefnames[ind];</p>

<p class=ILprg>if ( table == 0)</p>

<p class=ILprg>s1 = typedefnames[ind];</p>

<p class=ILprg>cb1 = cb;</p>

<p class=ILprg>return s1;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetElemType ( int index , byte [] b , out int cb1)</p>

<p class=ILprg>{</p>

<p class=ILprg>cb1 = 0;</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>if ( index == b.Length )</p>

<p class=ILprg>return s;</p>

<p class=ILprg>byte type = b[index];</p>

<p class=ILprg>if ( type &gt;= 0x01 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
type &lt;= 0x0e )</p>

<p class=ILprg>{</p>

<p class=ILprg>s = GetType(type);</p>

<p class=ILprg>cb1 = 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x0f)</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb2;</p>

<p class=ILprg>if ( b[index+1] &lt;= 0x0e)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = GetPointerType( b , index + 1, out cb2);</p>

<p class=ILprg>cb1 = cb2 + 1; </p>

<p class=ILprg>}</p>

<p class=ILprg>else if (b[index + 1] == 0x11 )</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;valuetype &quot; + GetTokenType( b , index + 1, out
cb2) + &quot;*&quot;;</p>

<p class=ILprg>cb1 = cb2 + 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if (b[index + 2] == 0x12 )</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;class &quot; + GetTokenType( b , index + 1, out cb2) +
&quot;*&quot;;</p>

<p class=ILprg>cb1 = cb2 + 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>{</p>

<p class=ILprg>s = GetTokenType( b , index + 1, out cb2) + &quot;*&quot;;</p>

<p class=ILprg>cb1 = cb2 + 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x10)</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb2;</p>

<p class=ILprg>if ( b[index+1] &gt;= 0x00 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
b[index+1] &lt;= 0x0e)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = GetType(b[index+1]) + &quot;<span style='font-family:"Bookman Old Style"'>&amp;</span>&quot;;</p>

<p class=ILprg>cb1 = 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( b[index+1] == 0x1D)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = GetType(b[index+1]) + &quot;[]<span style='font-family:"Bookman Old Style"'>&amp;</span>&quot;;</p>

<p class=ILprg>cb1 = 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>{</p>

<p class=ILprg>s = GetTokenType( b , index , out cb2);</p>

<p class=ILprg>cb1 = cb2 + 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x11 || type == 0x12 )</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb2;</p>

<p class=ILprg>s = GetTokenType( b , index , out cb2);</p>

<p class=ILprg>cb1 = cb2 + 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x14 )</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb2;</p>

<p class=ILprg>s = GetArrayType( b , index , out cb2);</p>

<p class=ILprg>cb1 = cb2 + 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x16)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;typedbyref&quot;;</p>

<p class=ILprg>cb1 = 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x18)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;native int&quot;;</p>

<p class=ILprg>cb1 = 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x19)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;native unsigned int&quot;;</p>

<p class=ILprg>cb1 = 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x1c)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;object&quot;;</p>

<p class=ILprg>cb1 = 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x1d)</p>

<p class=ILprg>{</p>

<p class=ILprg>int i = 1;</p>

<p class=ILprg>s = &quot;[]&quot;;</p>

<p class=ILprg>while ( true )</p>

<p class=ILprg>{</p>

<p class=ILprg>byte next = b[index+i];</p>

<p class=ILprg>if ( next != 0x1d )</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>break;</p>

<p class=ILprg>s = s + &quot;[]&quot;;</p>

<p class=ILprg>i = i +1 ;</p>

<p class=ILprg>}</p>

<p class=ILprg>int cb2;</p>

<p class=ILprg>s = s + GetElemType(index + i , b , out cb2);</p>

<p class=ILprg>cb1 = i + cb2;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x20 )</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb2;</p>

<p class=ILprg>s = &quot;modopt &quot; + GetTokenType( b , index , out cb2);</p>

<p class=ILprg>cb1 = cb2 + 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( type == 0x45 )</p>

<p class=ILprg>{</p>

<p class=ILprg>int cb2 ; </p>

<p class=ILprg>s = GetElemType( index + 1 , b , out cb2) + &quot; pinned&quot;;</p>

<p class=ILprg>cb1 = cb2 + 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetTokenType ( byte [] b , int index , out int
cb1)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = 0;</p>

<p class=ILprg>if ( b[index] == 0x10 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
b[index + 1] == 0x11)</p>

<p class=ILprg>{</p>

<p class=ILprg>index++;</p>

<p class=ILprg>cb=1;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( b[index] == 0x10 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
b[index + 1] == 0x12)</p>

<p class=ILprg>{</p>

<p class=ILprg>index++;</p>

<p class=ILprg>cb=1;</p>

<p class=ILprg>}</p>

<p class=ILprg>cb = cb<span style="mso-spacerun: yes">  </span>+
CorSigUncompressData(b , index + 1 , out uncompressedbyte);</p>

<p class=ILprg>string s1<span style="mso-spacerun: yes">  </span>=
DecodeToken(uncompressedbyte);</p>

<p class=ILprg>if ( b[index] == 0x12)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;class &quot; + s1;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( b[index] == 0x11)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;valuetype &quot; + s1;</p>

<p class=ILprg>}</p>

<p class=ILprg>else if ( b[index] == 0x10)</p>

<p class=ILprg>{</p>

<p class=ILprg>s = &quot;[out] &quot; + s1;</p>

<p class=ILprg>}</p>

<p class=ILprg>else</p>

<p class=ILprg>s = s1;</p>

<p class=ILprg>cb1 = cb;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DecodeToken (int token)</p>

<p class=ILprg>{</p>

<p class=ILprg>byte table = (byte)(token <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x03);</p>

<p class=ILprg>int ind = token &gt;&gt; 2;</p>

<p class=ILprg>string s1 = &quot;&quot;;</p>

<p class=ILprg>if ( table == 0)</p>

<p class=ILprg>s1 = GetString(TypeDefStruct[ind].name);</p>

<p class=ILprg>if ( table == 1 )</p>

<p class=ILprg>s1 = GetString(TypeRefStruct[ind].name) ;</p>

<p class=ILprg>return s1;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetPointerType( byte [] b , int index , out int
cb1)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>s = GetElemType(index , b , out cb1) + &quot; *&quot; ;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetArrayType (byte [] b ,<span
style="mso-spacerun: yes">  </span>int index , out int cb1)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s ;</p>

<p class=ILprg>int total = 1;</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int rank;</p>

<p class=ILprg>int numsizes;</p>

<p class=ILprg>int cb;</p>

<p class=ILprg>s = GetElemType(index +1 , b ,<span style="mso-spacerun: yes"> 
</span>out cb1);</p>

<p class=ILprg>total = total + cb1;</p>

<p class=ILprg>s = s + &quot; [&quot;;</p>

<p class=ILprg>cb = CorSigUncompressData(b , index + total, out
uncompressedbyte);</p>

<p class=ILprg>total = total + cb;</p>

<p class=ILprg>rank = uncompressedbyte;</p>

<p class=ILprg>cb = CorSigUncompressData(b , index + total, out
uncompressedbyte);</p>

<p class=ILprg>total = total + cb;</p>

<p class=ILprg>numsizes = uncompressedbyte;</p>

<p class=ILprg>int [] sizearray = new int[numsizes];</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= numsizes ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>cb = CorSigUncompressData(b , index + total, out
uncompressedbyte);</p>

<p class=ILprg>total = total + cb;</p>

<p class=ILprg>sizearray[l-1] = uncompressedbyte;</p>

<p class=ILprg>}</p>

<p class=ILprg>cb = CorSigUncompressData(b , index + total, out
uncompressedbyte);</p>

<p class=ILprg>total = total + cb;</p>

<p class=ILprg>int bounds = uncompressedbyte;</p>

<p class=ILprg>int [] boundsarray = new int[bounds];</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= bounds ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>cb = CorSigUncompressData(b , index + total, out
uncompressedbyte);</p>

<p class=ILprg>total = total + cb;</p>

<p class=ILprg>int ulSigned = uncompressedbyte <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x1; </p>

<p class=ILprg>uncompressedbyte<span style="mso-spacerun: yes">  </span>=
uncompressedbyte &gt;&gt; 1; </p>

<p class=ILprg>if (ulSigned == 1)<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>{<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>if (cb == 1)<span style="mso-spacerun: yes">    </span></p>

<p class=ILprg>{<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>uncompressedbyte =<span style="mso-spacerun: yes">  </span>(int)
((ushort)uncompressedbyte | 0xffffffc0); </p>

<p class=ILprg>}<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>else if (cb == 2)<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>{<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>uncompressedbyte = (int) ((ushort)uncompressedbyte | 0xffffe000)
; </p>

<p class=ILprg>}<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>else<span style="mso-spacerun: yes">    </span></p>

<p class=ILprg>{<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>uncompressedbyte = (int)((ushort)uncompressedbyte |
0xf0000000);<span style="mso-spacerun: yes">    </span></p>

<p class=ILprg>}<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>}<span style="mso-spacerun: yes">   </span></p>

<p class=ILprg>boundsarray[l-1] = uncompressedbyte ;</p>

<p class=ILprg>}</p>

<p class=ILprg>for ( int l = 0 ; l &lt; bounds ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>if (numsizes != 0)</p>

<p class=ILprg>{</p>

<p class=ILprg>int upper = boundsarray[l] + sizearray[l] - 1 ;</p>

<p class=ILprg>if ( boundsarray[l] == 0 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
sizearray[l] != 0 )</p>

<p class=ILprg>{</p>

<p class=ILprg>s = s + sizearray[l] ;</p>

<p class=ILprg>if ( l != bounds -1<span style="mso-spacerun: yes">  </span>)</p>

<p class=ILprg>s = s + &quot;,&quot;;</p>

<p class=ILprg>}</p>

<p class=ILprg>if (boundsarray[l] == 0 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
sizearray[l] == 0)</p>

<p class=ILprg>s = s + &quot;,&quot; ;</p>

<p class=ILprg>if (boundsarray[l] != 0 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
sizearray[l] != 0) </p>

<p class=ILprg>{</p>

<p class=ILprg>s = s + boundsarray[l] + &quot;...&quot; + upper.ToString()<span
style="mso-spacerun: yes">  </span>;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( !(bounds - l == 1) )</p>

<p class=ILprg>s = s + &quot;,&quot;;</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>int leftover = rank - numsizes ;</p>

<p class=ILprg>if ( numsizes == 0)</p>

<p class=ILprg>leftover--;</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= leftover ; l++)</p>

<p class=ILprg>s = s + &quot;,&quot;;</p>

<p class=ILprg>s = s + &quot;]&quot;;</p>

<p class=ILprg>cb1 = total-1;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMemberRefParentTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x07;</p>

<p class=ILprg>if ( tag == 0)</p>

<p class=ILprg>s = s + &quot;NotUsed&quot;;</p>

<p class=ILprg>if ( tag == 1)</p>

<p class=ILprg>s = s + &quot;TypeRef&quot;;</p>

<p class=ILprg>if ( tag == 2)</p>

<p class=ILprg>s = s + &quot;ModuleRef&quot;;</p>

<p class=ILprg>if ( tag == 3)</p>

<p class=ILprg>s = s + &quot;MethodDef&quot;;</p>

<p class=ILprg>if ( tag == 4)</p>

<p class=ILprg>s = s + &quot;TypeSpec&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetMemberRefParentValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 3;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayMemberRefTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( MemberRefStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nMemberRef Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= MemberRefStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot;,ii);</p>

<p class=ILprg>string s = GetMemberRefParentTable(MemberRefStruct[ii].clas);</p>

<p class=ILprg>int rid =
(int)GetMemberRefParentValue(MemberRefStruct[ii].clas); </p>

<p class=ILprg>Console.WriteLine(&quot;{0}[{1}]:{2}&quot;,s,rid,DisplayTable(s,rid));</p>

<p class=ILprg>Console.WriteLine(&quot;Name:{0}&quot; ,
GetString(MemberRefStruct[ii].name));</p>

<p class=ILprg>Console.Write(&quot;Signature #BLOB[{0}] &quot;,
MemberRefStruct[ii].sig);</p>

<p class=ILprg>Console.WriteLine(&quot;\n&quot;);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetHasConstValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetHasConstTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x03;</p>

<p class=ILprg>Console.Write(&quot;Parent: &quot;);</p>

<p class=ILprg>if ( tag == 0)</p>

<p class=ILprg>s = s + &quot;FieldDef&quot;;</p>

<p class=ILprg>if ( tag == 1)</p>

<p class=ILprg>s = s + &quot;ParamDef&quot;;</p>

<p class=ILprg>if ( tag == 2)</p>

<p class=ILprg>s = s + &quot;Property&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>} </p>

<p class=ILprg>public long GetBytesFromArray(int value , int dtype)</p>

<p class=ILprg>{</p>

<p class=ILprg>long z = 0;</p>

<p class=ILprg>if ( dtype == 2 || dtype == 4 || dtype == 5 )</p>

<p class=ILprg>z = blob[value + 1];</p>

<p class=ILprg>if ( dtype == 3 || dtype == 6 || dtype == 7<span
style="mso-spacerun: yes">  </span>)</p>

<p class=ILprg>z = BitConverter.ToInt16 (blob , value + 1);</p>

<p class=ILprg>if ( dtype == 8 || dtype == 9 )</p>

<p class=ILprg>z = BitConverter.ToInt32 (blob , value + 1);</p>

<p class=ILprg>if ( dtype == 0x0a<span style="mso-spacerun: yes">  </span>||
dtype == 0x0b )</p>

<p class=ILprg>z = BitConverter.ToInt64 (blob , value + 1);</p>

<p class=ILprg>return z;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void GetStringFromBlobArray(int value)</p>

<p class=ILprg>{</p>

<p class=ILprg>int count = blob[value];</p>

<p class=ILprg>Console.Write(&quot; Value &quot;);</p>

<p class=ILprg>for ( int i = 1 ; i &lt;= count ; i = i+2)</p>

<p class=ILprg>Console.Write(&quot;{0}&quot; , (char) blob[value + i] );</p>

<p class=ILprg>}</p>

<p class=ILprg>public void GetBlobConstant(int value , int dtype)</p>

<p class=ILprg>{</p>

<p class=ILprg>int count = blob[value];</p>

<p class=ILprg>Console.Write(&quot;Blob BLOB[{0}] Count {1} &quot;,value ,
count);</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0} &quot; ,
blob[value+l].ToString(&quot;X&quot;));</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( dtype &lt;= 0x0b )</p>

<p class=ILprg>{</p>

<p class=ILprg>long val = GetBytesFromArray(value , dtype );</p>

<p class=ILprg>Console.Write(&quot; Value {0} &quot; , val);</p>

<p class=ILprg>}</p>

<p class=ILprg>if (dtype == 0x0e)</p>

<p class=ILprg>GetStringFromBlobArray(value );</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayConstantTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ConstantsStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nConstant Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ConstantsStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Type {0}&quot; ,
GetType(ConstantsStruct[ii].dtype));</p>

<p class=ILprg>string s = GetHasConstTable(ConstantsStruct[ii].parent);</p>

<p class=ILprg>int off = GetHasConstValue(ConstantsStruct[ii].parent);</p>

<p class=ILprg>int p = 0;</p>

<p class=ILprg>if ( s == &quot;FieldDef&quot; )</p>

<p class=ILprg>{</p>

<p class=ILprg>p = FieldStruct[off].name;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( s == &quot;ParamDef&quot; )</p>

<p class=ILprg>{</p>

<p class=ILprg>p = ParamStruct[off].name;</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( s == &quot;Property&quot; )</p>

<p class=ILprg>{</p>

<p class=ILprg>p = PropertyStruct[off].name;</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine(&quot;{0}[{1}] Name of Constant... {2}
&quot;,<span style="mso-spacerun: yes">  </span>s, off , GetString(p));</p>

<p class=ILprg>GetBlobConstant(ConstantsStruct[ii].value ,
ConstantsStruct[ii].dtype);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetCustomAttributeTypevalue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 3;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetHasCustomAttributeValue( int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 5;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetHasCustomAttributeTable( int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x1F;</p>

<p class=ILprg>if ( tag == 0)</p>

<p class=ILprg>s = s + &quot;MethodDef&quot;;</p>

<p class=ILprg>if ( tag == 1)</p>

<p class=ILprg>s = s + &quot;FieldDef&quot;;</p>

<p class=ILprg>if ( tag == 2)</p>

<p class=ILprg>s = s + &quot;TypeRef&quot;;</p>

<p class=ILprg>if ( tag == 3)</p>

<p class=ILprg>s = s + &quot;TypeDef&quot;;</p>

<p class=ILprg>if ( tag == 4)</p>

<p class=ILprg>s = s + &quot;ParamDef&quot;;</p>

<p class=ILprg>if ( tag == 5)</p>

<p class=ILprg>s = s + &quot;InterfaceImpl&quot;;</p>

<p class=ILprg>if ( tag == 6)</p>

<p class=ILprg>s = s + &quot;MemberRef&quot;;</p>

<p class=ILprg>if ( tag == 7)</p>

<p class=ILprg>s = s + &quot;Module&quot;;</p>

<p class=ILprg>if ( tag == 8)</p>

<p class=ILprg>s = s + &quot;DeclSecurity&quot;;</p>

<p class=ILprg>if ( tag == 9)</p>

<p class=ILprg>s = s + &quot;Property&quot;;</p>

<p class=ILprg>if ( tag == 10)</p>

<p class=ILprg>s = s + &quot;Event&quot;;</p>

<p class=ILprg>if ( tag == 11)</p>

<p class=ILprg>s = s + &quot;Signature&quot;;</p>

<p class=ILprg>if ( tag == 12)</p>

<p class=ILprg>s = s + &quot;ModuleRef&quot;;</p>

<p class=ILprg>if ( tag == 13)</p>

<p class=ILprg>s = s + &quot;TypeSpec&quot;;</p>

<p class=ILprg>if ( tag == 14)</p>

<p class=ILprg>s = s + &quot;Assembly&quot;;</p>

<p class=ILprg>if ( tag == 15)</p>

<p class=ILprg>s = s + &quot;AssemblyRef&quot;;</p>

<p class=ILprg>if ( tag == 16)</p>

<p class=ILprg>s = s + &quot;File&quot;;</p>

<p class=ILprg>if ( tag == 17)</p>

<p class=ILprg>s = s + &quot;ExportedType&quot;;</p>

<p class=ILprg>if ( tag == 18)</p>

<p class=ILprg>s = s + &quot;ManifestResource&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void GetCustomAttributeBlob( int index )</p>

<p class=ILprg>{</p>

<p class=ILprg>int count = blob[index];</p>

<p class=ILprg>Console.Write(&quot;Value Blob[{0}] Count {1} Bytes
&quot;,index, count );</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0} &quot; ,
blob[index+l].ToString(&quot;X&quot;));</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayCustomAttributeTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( CustomAttributeStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n CustomAttribute Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= CustomAttributeStruct.Length-1 ;
ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row [{0}]&quot;, ii);</p>

<p class=ILprg>string tablename= GetHasCustomAttributeTable(CustomAttributeStruct[ii].parent)
;</p>

<p class=ILprg>int index =
GetHasCustomAttributeValue(CustomAttributeStruct[ii].parent);</p>

<p class=ILprg>string s = DisplayTable(tablename , index );</p>

<p class=ILprg>Console.WriteLine(&quot;Parent: {0}[{1}]...{2}&quot; ,
tablename, index,s );</p>

<p class=ILprg>tablename =
GetCustomAttributeTypeTable(CustomAttributeStruct[ii].type) ;</p>

<p class=ILprg>index<span style="mso-spacerun: yes">  </span>=
GetCustomAttributeTypevalue(CustomAttributeStruct[ii].type);</p>

<p class=ILprg>s = DisplayTable(tablename , index );</p>

<p class=ILprg>Console.WriteLine(&quot;Type: {0}[{1}]...{2} &quot; , tablename
, index,s );</p>

<p class=ILprg>GetCustomAttributeBlob(CustomAttributeStruct[ii].value);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetFieldMarshalTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>short tag = (short)(a <span style='font-family:"Bookman Old Style"'>&amp;</span>
(short)0x01);</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 0)</p>

<p class=ILprg>s = s + &quot;Field&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 1)</p>

<p class=ILprg>s = s + &quot;Param&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetFieldMarshalValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMarshallType(byte a)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( a == 2)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_BOOLEAN&quot;;</p>

<p class=ILprg>if ( a == 3)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_I1&quot;;</p>

<p class=ILprg>if ( a == 0x04)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_U1&quot;;</p>

<p class=ILprg>if ( a == 0x05)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_I2&quot;;</p>

<p class=ILprg>if ( a == 0x06)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_U2&quot;;</p>

<p class=ILprg>if ( a == 0x07)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_I4&quot;;</p>

<p class=ILprg>if ( a == 0x08)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_U4&quot;;</p>

<p class=ILprg>if ( a == 0x09)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_I8&quot;;</p>

<p class=ILprg>if ( a == 0x0a)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_U8&quot;;</p>

<p class=ILprg>if ( a == 0x0b)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_R4&quot;;</p>

<p class=ILprg>if ( a == 0x0c)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_R8&quot;;</p>

<p class=ILprg>if ( a == 0x14)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_LPSTR&quot;;</p>

<p class=ILprg>if ( a == 0x1f)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_INT&quot;;</p>

<p class=ILprg>if ( a == 0x20)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_UINT&quot;;</p>

<p class=ILprg>if ( a == 0x26)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_FUNC&quot;;</p>

<p class=ILprg>if ( a == 0x2a)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_ARRAY&quot;;</p>

<p class=ILprg>if ( a == 0x0f)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_CURRENCY&quot;;</p>

<p class=ILprg>if ( a == 0x13)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_BSTR&quot;;</p>

<p class=ILprg>if ( a == 0x15)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_LPWSTR&quot;;</p>

<p class=ILprg>if ( a == 0x16)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_LPTSTR&quot;;</p>

<p class=ILprg>if ( a == 0x17)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_FIXEDSYSSTRING&quot;;</p>

<p class=ILprg>if ( a == 0x19)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_IUNKNOWN&quot;;</p>

<p class=ILprg>if ( a == 0x1a)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_IDISPATCH&quot;;</p>

<p class=ILprg>if ( a == 0x1b)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_STRUCT&quot;;</p>

<p class=ILprg>if ( a == 0x1c)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_INTF&quot;;</p>

<p class=ILprg>if ( a == 0x1d)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_SAFEARRAY&quot;;</p>

<p class=ILprg>if ( a == 0x1e)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_FIXEDARRAY&quot;;</p>

<p class=ILprg>if ( a == 0x22)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_BYVALSTR&quot;;</p>

<p class=ILprg>if ( a == 0x13)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_ANSIBSTR&quot;;</p>

<p class=ILprg>if ( a == 0x24)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_TBSTR&quot;;</p>

<p class=ILprg>if ( a == 0x25)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_VARIANTBOOL&quot;;</p>

<p class=ILprg>if ( a == 0x28)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_ASANY&quot;;</p>

<p class=ILprg>if ( a == 0x2b)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_LPSTRUCT&quot;;</p>

<p class=ILprg>if ( a == 0x2c)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_CUSTOMMARSHALER&quot;;</p>

<p class=ILprg>if ( a == 0x2d)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_ERROR&quot;;</p>

<p class=ILprg>if ( a == 0x50)</p>

<p class=ILprg>return &quot;NATIVE_TYPE_NOINFO&quot;;</p>

<p class=ILprg>return &quot;Unknown&quot;;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayFieldMarshalTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( FieldMarshalStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nFieldMarshal Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= FieldMarshalStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>string tablename =
GetFieldMarshalTable(FieldMarshalStruct[ii].coded) ;</p>

<p class=ILprg>int index = GetFieldMarshalValue(FieldMarshalStruct[ii].coded);</p>

<p class=ILprg>Console.WriteLine(&quot;Parent<span style="mso-spacerun: yes"> 
</span>{0}[{1}]...{2}&quot; ,tablename<span style="mso-spacerun: yes"> 
</span>, index , DisplayTable(tablename ,index<span style="mso-spacerun: yes"> 
</span>));</p>

<p class=ILprg>int count = blob[FieldMarshalStruct[ii].index];</p>

<p class=ILprg>Console.WriteLine(&quot;Native Type Blob[{0}] Count {1} {2}
&quot; , index , count , GetMarshallType(blob[FieldMarshalStruct[ii].index+1]));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetDeclSecurityTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>short tag = (short)(a <span style='font-family:"Bookman Old Style"'>&amp;</span>
(short)0x03);</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 0)</p>

<p class=ILprg>s = s + &quot;TypeDef&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 1)</p>

<p class=ILprg>s = s + &quot;MethodDef&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 2)</p>

<p class=ILprg>s = s + &quot;Assembly&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetDeclSecurityValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayDeclSecurityTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( DeclSecurityStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nDeclSecurity Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= DeclSecurityStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Action {0}&quot; ,
DeclSecurityStruct[ii].action);</p>

<p class=ILprg>string tablename =
GetDeclSecurityTable(DeclSecurityStruct[ii].coded);</p>

<p class=ILprg>int ind = GetDeclSecurityValue(DeclSecurityStruct[ii].coded);</p>

<p class=ILprg>Console.WriteLine(&quot;Parent: {0}[{1}]... {2}&quot; , tablename
, ind , DisplayTable(tablename , ind));</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = CorSigUncompressData(blob ,
DeclSecurityStruct[ii].bindex, out uncompressedbyte);</p>

<p class=ILprg>int count = uncompressedbyte;</p>

<p class=ILprg>int index1 = DeclSecurityStruct[ii].bindex + cb;</p>

<p class=ILprg>Console.WriteLine(&quot;Permission Set BLOB[{0}] Count={1}
&quot; , index1, count );</p>

<p class=ILprg>for ( int l = 0 ; l &lt; count ; l++)</p>

<p class=ILprg>Console.Write(&quot;{0}&quot;,<span style="mso-spacerun: yes"> 
</span>(char)blob[index1 + l]);</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayClassLayoutTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ClassLayoutStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nClassLayout Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ClassLayoutStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Packing Size {0}&quot; ,
ClassLayoutStruct[ii].packingsize );</p>

<p class=ILprg>Console.WriteLine(&quot;Class Size {0}&quot; ,
ClassLayoutStruct[ii].classsize );</p>

<p class=ILprg>int i = ClassLayoutStruct[ii].parent;</p>

<p class=ILprg>string s = GetTypeDefTable(i);</p>

<p class=ILprg>Console.WriteLine(&quot;Parent TypeDef[{0}]...{1} &quot; , i,s
);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayFieldLayoutTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( FieldLayoutStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n Field Layout Table\n&quot;);</p>

<p class=ILprg>for ( int ii= 1 ; ii&lt;= FieldLayoutStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Offset:{0}&quot; ,
FieldLayoutStruct[ii].offset);</p>

<p class=ILprg>int index = FieldLayoutStruct[ii].fieldindex;</p>

<p class=ILprg>string s = GetFieldTable(index);</p>

<p class=ILprg>Console.WriteLine(&quot;Field :Field[{0}]...{1}&quot; , index ,
s);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DisplayStandAloneSigSignature(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string<span style="mso-spacerun: yes">  </span>s = &quot;&quot;;</p>

<p class=ILprg>int count = blob[index];</p>

<p class=ILprg>s = s + count.ToString() + &quot; &quot;; </p>

<p class=ILprg>for ( int l = 1; l &lt;= count ; l++)</p>

<p class=ILprg>s = s + blob[index+l].ToString() + &quot; &quot;; </p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayStandAloneSigTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( StandAloneSigStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nStandAloneSig Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= StandAloneSigStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>string s = DisplayStandAloneSigSignature(StandAloneSigStruct[ii].index
);</p>

<p class=ILprg>Console.WriteLine(&quot;Signature BLOB[{0}] Count {1} &quot; ,
StandAloneSigStruct[ii].index , s );</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetTypeRefTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>int name = TypeRefStruct[index].name;</p>

<p class=ILprg>int nspace = TypeRefStruct[index].nspace;</p>

<p class=ILprg>string s = GetString(nspace) ;</p>

<p class=ILprg>if ( s != &quot;null&quot; )</p>

<p class=ILprg>s = s + &quot;.&quot;; </p>

<p class=ILprg>else</p>

<p class=ILprg>s = &quot;&quot;;</p>

<p class=ILprg>s = s + GetString(name);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetTypeDefOrRefTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>short tag = (short)(a <span style='font-family:"Bookman Old Style"'>&amp;</span>
(short)0x03);</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 0)</p>

<p class=ILprg>s = s + &quot;TypeDef&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 1)</p>

<p class=ILprg>s = s + &quot;TypeRef&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 2)</p>

<p class=ILprg>s = s + &quot;TypeSpec&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetTypeDefOrRefValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetTypeDefTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>int name = TypeDefStruct[index].name;</p>

<p class=ILprg>int nspace = TypeDefStruct[index].nspace;</p>

<p class=ILprg>int cindex = TypeDefStruct[index].cindex;</p>

<p class=ILprg>int typereftableindex = GetTypeDefOrRefValue(cindex);</p>

<p class=ILprg>string tablename = GetTypeDefOrRefTable(cindex);</p>

<p class=ILprg>string s1 = &quot;&quot;;</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;TypeRef&quot;)</p>

<p class=ILprg>s1 = &quot; Extends &quot; + GetTypeRefTable(typereftableindex);</p>

<p class=ILprg>if (GetString(nspace)!= &quot;&quot;)</p>

<p class=ILprg>s1 = s1 +<span style="mso-spacerun: yes">  </span>&quot;
Namespace: &quot; + GetString(nspace);</p>

<p class=ILprg>string s = &quot;Class &quot; + GetString(name) +<span
style="mso-spacerun: yes">  </span>s1 ;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetEventTable(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = EventStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>int coded = EventStruct[index].coded;</p>

<p class=ILprg>string tablename = GetTypeDefOrRefTable(coded);</p>

<p class=ILprg>int ind1 = GetTypeDefOrRefValue(coded);</p>

<p class=ILprg>string s1 = DisplayTable(tablename , ind1);</p>

<p class=ILprg>s = &quot;Event &quot; + s + &quot; &quot; + s1 + &quot; &quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DisplayEventsList(int start , int rowindex)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int end = EventStruct.Length;</p>

<p class=ILprg>int end1 = 10000;</p>

<p class=ILprg>if ( rowindex &lt;= EventMapStruct.Length)</p>

<p class=ILprg>end1 = EventMapStruct[rowindex].eindex; </p>

<p class=ILprg>int end2 = 0;</p>

<p class=ILprg>if ( end &lt;= end1)</p>

<p class=ILprg>end2 = end;</p>

<p class=ILprg>else</p>

<p class=ILprg>end2 = end1; </p>

<p class=ILprg>for ( int i = start<span style="mso-spacerun: yes">  </span>; i
&lt;= end2 ; i++)</p>

<p class=ILprg>s = s + GetEventTable(i) + &quot;\n&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayEventMapTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( EventMapStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nEventMap Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= EventMapStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Parent TypeDef[{0}]...{1}&quot; ,
EventMapStruct[ii].index , GetTypeDefTable(EventMapStruct[ii].index ) );</p>

<p class=ILprg>string s=DisplayEventsList(EventMapStruct[ii].eindex,ii); </p>

<p class=ILprg>Console.Write(&quot;EventList Event[{0}]...{1}&quot; ,
EventMapStruct[ii].eindex,s);<span style="mso-spacerun: yes">               
</span></p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetEventsAttributes(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0200) == 0x0200)</p>

<p class=ILprg>s = s + &quot;Special Name&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0400) == 0x0400)</p>

<p class=ILprg>s = s + &quot;RTSpecialName&quot;;</p>

<p class=ILprg>if (s.Length == 0)</p>

<p class=ILprg>return &quot;None&quot;;</p>

<p class=ILprg>else</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayEventTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( EventStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nEvent Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= EventStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Event Flags: {0}&quot; ,
GetEventsAttributes(EventStruct[ii].attr));</p>

<p class=ILprg>Console.WriteLine(&quot;Name: {0}&quot; ,
GetString(EventStruct[ii].name));</p>

<p class=ILprg>string tablename = GetTypeDefOrRefTable(EventStruct[ii].coded) ;</p>

<p class=ILprg>int index = GetTypeDefOrRefValue(EventStruct[ii].coded);</p>

<p class=ILprg>Console.WriteLine(&quot;Event Type:{0}[{1}]... {2}&quot; ,
tablename , </p>

<p class=ILprg>index , DisplayTable(tablename, index));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DisplayPropertiesList(int start , int rowindex)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int end = PropertyStruct.Length;</p>

<p class=ILprg>int end1 = 10000;</p>

<p class=ILprg>if ( rowindex &lt;= PropertyMapStruct.Length)</p>

<p class=ILprg>end1 = PropertyMapStruct[rowindex].propertylist; </p>

<p class=ILprg>int end2 = 0;</p>

<p class=ILprg>if ( end &lt;= end1)</p>

<p class=ILprg>end2 = end;</p>

<p class=ILprg>else</p>

<p class=ILprg>end2 = end1; </p>

<p class=ILprg>for ( int i = start<span style="mso-spacerun: yes">  </span>; i
&lt;= end2 ; i++)</p>

<p class=ILprg>s = s + GetPropertyTable(i) + &quot;\n&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetPropertyTable(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = PropertyStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayPropertyMapTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( PropertyMapStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n Property Map Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= PropertyMapStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Parent TypeDef[{0}]...{1}&quot; ,
PropertyMapStruct[ii].parent , GetTypeDefTable(PropertyMapStruct[ii].parent ));</p>

<p class=ILprg>string
s=DisplayPropertiesList(PropertyMapStruct[ii].propertylist,ii);</p>

<p class=ILprg>Console.WriteLine(&quot;PropertyList Property[{0}]...{1}&quot; ,
PropertyMapStruct[ii].propertylist,s );</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DisplayPropertySignature(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string<span style="mso-spacerun: yes">  </span>s = &quot;&quot;;</p>

<p class=ILprg>int count = blob[index];</p>

<p class=ILprg>s = s + count.ToString() + &quot; &quot;; </p>

<p class=ILprg>for ( int l = 1; l &lt;= count ; l++)</p>

<p class=ILprg>s = s + blob[index+l].ToString() + &quot; &quot;; </p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayPropertiesTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( PropertyStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nProperties Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= PropertyStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Flags [{0}]&quot; , PropertyStruct[ii].flags);</p>

<p class=ILprg>Console.WriteLine(&quot;Name {0}&quot; ,
GetString(PropertyStruct[ii].name));</p>

<p class=ILprg>string s = DisplayPropertySignature(PropertyStruct[ii].type);</p>

<p class=ILprg>Console.WriteLine(&quot;Type BLOB[{0}]...{1} &quot; ,
PropertyStruct[ii].type , s);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMethodSemanticsAttributes(short a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x01) == 0x01)</p>

<p class=ILprg>s = s + &quot;Setter&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x02) == 0x02)</p>

<p class=ILprg>s = s + &quot;Getter&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x04) == 0x04)</p>

<p class=ILprg>s = s + &quot;Other&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x08) == 0x08)</p>

<p class=ILprg>s = s + &quot;Event Addon&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x10) == 0x10)</p>

<p class=ILprg>s = s + &quot;Event Remove&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x20) == 0x20)</p>

<p class=ILprg>s = s + &quot;Event Fire&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetMethodDefValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMethodDefTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>short tag = (short)(a <span style='font-family:"Bookman Old Style"'>&amp;</span>
(short)0x01);</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 0)</p>

<p class=ILprg>s = s + &quot;MethodDef&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 1)</p>

<p class=ILprg>s = s + &quot;MethodRef&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMethodTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = MethodStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetHasSemanticsValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 1;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetHasSemanticsTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x01;</p>

<p class=ILprg>if ( tag == 0 )</p>

<p class=ILprg>s = s + &quot;Event&quot;;</p>

<p class=ILprg>if ( tag == 1 )</p>

<p class=ILprg>s = s + &quot;Property&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>} </p>

<p class=ILprg>public void DisplayMethodSemanticsTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( MethodSemanticsStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nMethodSemantics Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= MethodSemanticsStruct.Length-1 ;
ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Semantics {0} &quot;,
GetMethodSemanticsAttributes(MethodSemanticsStruct[ii].methodsemanticsattributes));</p>

<p class=ILprg>string s = GetMethodTable(MethodSemanticsStruct[ii].methodindex
);</p>

<p class=ILprg>Console.WriteLine(&quot;Method Method[{0}]...{1}&quot;,
MethodSemanticsStruct[ii].methodindex , s);</p>

<p class=ILprg>string tablename =
GetHasSemanticsTable(MethodSemanticsStruct[ii].association);</p>

<p class=ILprg>int index = GetHasSemanticsValue(MethodSemanticsStruct[ii].association);</p>

<p class=ILprg>s = DisplayTable(tablename,index );</p>

<p class=ILprg>Console.WriteLine(&quot;Association:{0}[{1}]...{2}
&quot;,tablename,index,s );</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayMethodImpTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( MethodImpStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n MethodImp Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= MethodImpStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Class TypeDef[{0}]...{1}&quot; ,
MethodImpStruct[ii].classindex ,
GetTypeDefTable(MethodImpStruct[ii].classindex));</p>

<p class=ILprg>string tablename = GetMethodDefTable(MethodImpStruct[ii].codedbody
);</p>

<p class=ILprg>int index = GetMethodDefValue(MethodImpStruct[ii].codedbody );</p>

<p class=ILprg>string s = DisplayTable(tablename , index );</p>

<p class=ILprg>Console.WriteLine(&quot;MethodBody<span style="mso-spacerun:
yes">  </span>{0}[{1}]...{2} &quot; , tablename<span style="mso-spacerun:
yes">  </span>, index,s );</p>

<p class=ILprg>tablename = GetMethodDefTable(MethodImpStruct[ii].codeddef );</p>

<p class=ILprg>index = GetMethodDefValue(MethodImpStruct[ii].codeddef);</p>

<p class=ILprg>s = DisplayTable(tablename , index );</p>

<p class=ILprg>Console.WriteLine(&quot;MethodDeclaration<span
style="mso-spacerun: yes">  </span>{0}[{1}]...{2} &quot; , tablename<span
style="mso-spacerun: yes">  </span>, index,s );</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayModuleRefTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ModuleRefStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nModuleRef Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ModuleRefStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Name {0}&quot; ,
GetString(ModuleRefStruct[ii].name));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayTypeSpecTableTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( TypeSpecStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nTypeSpec Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= TypeSpecStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot;,ii);</p>

<p class=ILprg>byte count = blob[TypeSpecStruct[ii].signature ];</p>

<p class=ILprg>Console.WriteLine(&quot;Signature BLOB[{0}] Count {1}&quot; ,
TypeSpecStruct[ii].signature<span style="mso-spacerun: yes">  </span>, count );</p>

<p class=ILprg>for (int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;{0} {1}&quot; ,
blob[TypeSpecStruct[ii].signature +
l],GetType(blob[TypeSpecStruct[ii].signature + l]));</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetPInvokeAttributes(short a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0001) == 0x0001)</p>

<p class=ILprg>s = s + &quot;NoMangle &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0006) == 0x0006)</p>

<p class=ILprg>s = s + &quot;CharSetMask &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0000) == 0x0000)</p>

<p class=ILprg>s = s + &quot;CharSetNotSpec &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0002) == 0x0002)</p>

<p class=ILprg>s = s + &quot;CharSetAnsi &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0004) == 0x0004)</p>

<p class=ILprg>s = s + &quot;CharSetUnicode &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0004) == 0x0004)</p>

<p class=ILprg>s = s + &quot;CharSetAuto &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0040) == 0x0040)</p>

<p class=ILprg>s = s + &quot;SupportsLastError &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0700) == 0x0700)</p>

<p class=ILprg>s = s + &quot;CallConvMask &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0100) == 0x0100<span style='mso-tab-count:1'>       </span>)</p>

<p class=ILprg>s = s + &quot;CallConvWinapi &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0200) == 0x0200)</p>

<p class=ILprg>s = s + &quot;CallConvCdecl &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0300) == 0x0300)</p>

<p class=ILprg>s = s + &quot;CallConvStdcall &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0400) == 0x0400)</p>

<p class=ILprg>s = s + &quot;CallConvThiscall &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x0500) == 0x0500)</p>

<p class=ILprg>s = s + &quot;CallConvFastcall &quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetMemberForwardedValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 1 ;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMemberForwardedTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x01;</p>

<p class=ILprg>if ( tag == 0 )</p>

<p class=ILprg>s = &quot;Field&quot;;</p>

<p class=ILprg>if ( tag == 1 )</p>

<p class=ILprg>s = &quot;MethodDef&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>} </p>

<p class=ILprg>public string GetModuleRefTable(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = ModuleRefStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayImplMapTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ImplMapStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;ImplMap Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ImplMapStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Mapping Flags<span style="mso-spacerun:
yes">  </span>:{0}&quot;, GetPInvokeAttributes(ImplMapStruct[ii].attr));</p>

<p class=ILprg>string tablename =
GetMemberForwardedTable(ImplMapStruct[ii].cindex);</p>

<p class=ILprg>int index = GetMemberForwardedValue(ImplMapStruct[ii].cindex);</p>

<p class=ILprg>string s = DisplayTable(tablename , index);</p>

<p class=ILprg>Console.WriteLine(&quot;MemberForwarded:{0}[{1}]...{2} &quot; ,
tablename , index,s );</p>

<p class=ILprg>Console.WriteLine(&quot;Name<span style="mso-spacerun:
yes">           </span>:{0}&quot; , GetString(ImplMapStruct[ii].name));</p>

<p class=ILprg>index = ImplMapStruct[ii].scope ;</p>

<p class=ILprg>Console.WriteLine(&quot;Import Scope<span style="mso-spacerun:
yes">   </span>:ModuleRef[{0}] {1}&quot; , index , GetModuleRefTable(index));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetFieldTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = FieldStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetFileAttributes(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>if ( a == 0x00)</p>

<p class=ILprg>s= &quot;ContainsMetaData&quot;;</p>

<p class=ILprg>if ( a == 0x01)</p>

<p class=ILprg>s= &quot;ContainsNoMetaData&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayFieldRVATable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( FieldRVAStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n FieldRVA Tble \n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= FieldRVAStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;RVA {0}&quot; ,
FieldRVAStruct[ii].rva.ToString(&quot;X&quot;));</p>

<p class=ILprg>int index = FieldRVAStruct[ii].fieldi;</p>

<p class=ILprg>Console.WriteLine(&quot;Field Field[{0}]... {1}&quot; ,index ,
GetFieldTable(index) );</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetAssemblyTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>int ind = AssemblyStruct[index].name;</p>

<p class=ILprg>return GetString(ind);</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetAssemblyRefTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>int ind = AssemblyRefStruct[index].name;</p>

<p class=ILprg>return GetString(ind);</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAssemblyTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( AssemblyStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Assembly Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= AssemblyStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;HashAlgId
{0}&quot;,AssemblyStruct[ii].HashAlgId );</p>

<p class=ILprg>Console.WriteLine(&quot;MajorVersion {0}&quot;,AssemblyStruct[ii].major
);</p>

<p class=ILprg>Console.WriteLine(&quot;MinorVersion
{0}&quot;,AssemblyStruct[ii].minor);</p>

<p class=ILprg>Console.WriteLine(&quot;BuildNumber
{0}&quot;,AssemblyStruct[ii].build);</p>

<p class=ILprg>Console.WriteLine(&quot;RevisionNumber
{0}&quot;,AssemblyStruct[ii].revision);</p>

<p class=ILprg>Console.WriteLine(&quot;Flags {0}&quot;,AssemblyStruct[ii].flags.ToString());</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = CorSigUncompressData( blob ,
AssemblyStruct[ii].publickey , out uncompressedbyte );</p>

<p class=ILprg>cb--;</p>

<p class=ILprg>int count = uncompressedbyte;</p>

<p class=ILprg>Console.WriteLine(&quot;Public Key #BLOB[{0}] Count
{1}&quot;,AssemblyStruct[ii].publickey , count );</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0} &quot; ,
blob[AssemblyStruct[ii].publickey+l+cb].ToString(&quot;X&quot;));</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( count != 0 )</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>Console.WriteLine(&quot;Name:{0}&quot;,GetString(AssemblyStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;Culture:{0}&quot;,GetString(AssemblyStruct[ii].culture));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayAssemblyRefTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( AssemblyRefStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\n AssemblyRef Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= AssemblyRefStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;MajorVersion
{0}&quot;,AssemblyRefStruct[ii].major );</p>

<p class=ILprg>Console.WriteLine(&quot;MinorVersion
{0}&quot;,AssemblyRefStruct[ii].minor);</p>

<p class=ILprg>Console.WriteLine(&quot;BuildNumber
{0}&quot;,AssemblyRefStruct[ii].build);</p>

<p class=ILprg>Console.WriteLine(&quot;RevisionNumber
{0}&quot;,AssemblyRefStruct[ii].revision);</p>

<p class=ILprg>Console.WriteLine(&quot;Flags
{0}&quot;,AssemblyRefStruct[ii].flags.ToString());</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = CorSigUncompressData( blob ,
AssemblyRefStruct[ii].publickey , </p>

<p class=ILprg>out uncompressedbyte );</p>

<p class=ILprg>cb--;</p>

<p class=ILprg>int count = uncompressedbyte;</p>

<p class=ILprg>Console.WriteLine(&quot;Public Key or Token #BLOB[{0}] Count
{1}&quot;,</p>

<p class=ILprg>AssemblyRefStruct[ii].publickey , count);</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0} &quot; ,
blob[AssemblyRefStruct[ii].publickey+l+cb].ToString(&quot;X&quot;));</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( count != 0 )</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>Console.WriteLine(&quot;Name:{0}&quot;,GetString(AssemblyRefStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;Culture:{0}&quot;,GetString(AssemblyRefStruct[ii].culture));</p>

<p class=ILprg>cb = CorSigUncompressData( blob ,
AssemblyRefStruct[ii].hashvalue , out uncompressedbyte );</p>

<p class=ILprg>cb--;</p>

<p class=ILprg>count = uncompressedbyte;</p>

<p class=ILprg>Console.WriteLine(&quot;Hash Value #BLOB[{0}] Count {1} &quot;,</p>

<p class=ILprg>AssemblyRefStruct[ii].hashvalue , count);</p>

<p class=ILprg>for ( int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0} &quot; ,
blob[AssemblyRefStruct[ii].hashvalue +l+cb].ToString(&quot;X&quot;));</p>

<p class=ILprg>}</p>

<p class=ILprg>if ( count != 0 )</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayFileTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( FileStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nFile Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= FileStruct.Length-1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Flags {0}&quot; ,
GetFileAttributes(FileStruct[ii].flags));</p>

<p class=ILprg>Console.WriteLine(&quot;Name {0}&quot; ,
GetString(FileStruct[ii].name));</p>

<p class=ILprg>int uncompressedbyte;</p>

<p class=ILprg>int cb = CorSigUncompressData(blob , FileStruct[ii].index, out
uncompressedbyte);</p>

<p class=ILprg>int count = uncompressedbyte;</p>

<p class=ILprg>cb--;</p>

<p class=ILprg>Console.WriteLine(&quot;HashValue BLOB[{0}] Count {1}&quot; ,
FileStruct[ii].index , count);</p>

<p class=ILprg>for ( int l = 1<span style="mso-spacerun: yes">  </span>; l
&lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.Write(&quot;{0} &quot; ,<span style="mso-spacerun:
yes">  </span>blob[FileStruct[ii].index+l+cb]);</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetImplementationValue( int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetImplementationTable( int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int tag = a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x03;</p>

<p class=ILprg>if ( tag == 0 )</p>

<p class=ILprg>s = s + &quot;File&quot;;</p>

<p class=ILprg>if ( tag == 1 )</p>

<p class=ILprg>s = s + &quot;AssemblyRef&quot;;</p>

<p class=ILprg>if ( tag == 2 )</p>

<p class=ILprg>s = s + &quot;ExportedType&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayExportedTypeTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ExportedTypeStruct!= null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nExported Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii&lt;=ExportedTypeStruct.Length -1 ; ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Flags {0}&quot; ,
ExportedTypeStruct[ii].flags);</p>

<p class=ILprg>Console.WriteLine(&quot;TypeDef TYPEDEF[{0}]...{1}&quot; ,
ExportedTypeStruct[ii].typedefindex,GetTypeDefTable(ExportedTypeStruct[ii].typedefindex)
);</p>

<p class=ILprg>Console.WriteLine(&quot;TypeName {0}&quot; ,
GetString(ExportedTypeStruct[ii].name));</p>

<p class=ILprg>Console.WriteLine(&quot;NameSpace {0}&quot; ,
GetString(ExportedTypeStruct[ii].nspace));</p>

<p class=ILprg>string tablename =
GetImplementationTable(ExportedTypeStruct[ii].coded) ;</p>

<p class=ILprg>int ind = GetImplementationValue(ExportedTypeStruct[ii].coded);</p>

<p class=ILprg>Console.WriteLine(&quot;Implementation {0}[{1}]...{2} &quot; ,
tablename, ind,DisplayTable(tablename,ind)<span style="mso-spacerun: yes"> 
</span>);</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public int GetManifestResourceValue(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>return a &gt;&gt; 2;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetManifestResourceAttributes(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s=&quot;&quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x007) == 0x007)</p>

<p class=ILprg>s = s + &quot;VisibilityMask &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x001) == 0x001)</p>

<p class=ILprg>s = s + &quot;Public &quot;;</p>

<p class=ILprg>if ( (a <span style='font-family:"Bookman Old Style"'>&amp;</span>
0x002) == 0x002)</p>

<p class=ILprg>s = s + &quot;Private &quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetManifestResourceTable(int a)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>short tag = (short)(a <span style='font-family:"Bookman Old Style"'>&amp;</span>
(short)0x03);</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 0)</p>

<p class=ILprg>s = s + &quot;File&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 1)</p>

<p class=ILprg>s = s + &quot;AssemblyRef&quot;;</p>

<p class=ILprg>if ( tag<span style="mso-spacerun: yes">  </span>== 2)</p>

<p class=ILprg>s = s + &quot;ExportedType&quot;;</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayManifestResourceTable()</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( ManifestResourceStruct != null)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;\nManifest Resource Table\n&quot;);</p>

<p class=ILprg>for ( int ii = 1 ; ii &lt;= ManifestResourceStruct.Length-1 ;
ii++)</p>

<p class=ILprg>{</p>

<p class=ILprg>Console.WriteLine(&quot;Row {0}&quot; , ii);</p>

<p class=ILprg>Console.WriteLine(&quot;Offset {0}&quot; ,
ManifestResourceStruct[ii].offset);</p>

<p class=ILprg>Console.WriteLine(&quot;Flags {0}&quot; ,
GetManifestResourceAttributes(ManifestResourceStruct[ii].flags));</p>

<p class=ILprg>Console.WriteLine(&quot;Name {0}&quot; ,
GetString(ManifestResourceStruct[ii].name));</p>

<p class=ILprg>string tablename = GetManifestResourceTable(ManifestResourceStruct[ii].coded);</p>

<p class=ILprg>int index =
GetManifestResourceValue(ManifestResourceStruct[ii].coded);</p>

<p class=ILprg>Console.WriteLine(&quot;Implementation: {0}[{1}]...{2}&quot; , </p>

<p class=ILprg>tablename , index,DisplayTable(tablename,index));</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetModuleTable(int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = ModuleStruct[index].Name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetParamTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = ParamStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetMemberRefTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = MemberRefStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string GetFileTable( int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>int ind = FileStruct[index].name;</p>

<p class=ILprg>s = GetString(ind);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public string DisplayTable( string tablename , int index)</p>

<p class=ILprg>{</p>

<p class=ILprg>string s = &quot;&quot;;</p>

<p class=ILprg>if ( index == 0)</p>

<p class=ILprg>return s;</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;Module&quot;)</p>

<p class=ILprg>s = GetModuleTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;TypeRef&quot;)</p>

<p class=ILprg>s = GetTypeRefTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;TypeDef&quot;)</p>

<p class=ILprg>s = GetTypeDefTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;Field&quot;)</p>

<p class=ILprg>s = GetFieldTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;MethodDef&quot;)</p>

<p class=ILprg>s = GetMethodTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;Param&quot;)</p>

<p class=ILprg>s = GetParamTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;MethodRef&quot;)</p>

<p class=ILprg>s = GetMemberRefTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;AssemblyRef&quot;)</p>

<p class=ILprg>s = GetAssemblyRefTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;Assembly&quot;)</p>

<p class=ILprg>s = GetAssemblyTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;ModuleRef&quot;)</p>

<p class=ILprg>s = GetModuleRefTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;File&quot;)</p>

<p class=ILprg>s = GetFileTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;Property&quot;)</p>

<p class=ILprg>s = GetPropertyTable(index);</p>

<p class=ILprg>if ( tablename<span style="mso-spacerun: yes">  </span>==
&quot;Event&quot;)</p>

<p class=ILprg>s = GetEventTable(index);</p>

<p class=ILprg>return s;</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayMethodSignature(int index1 , int row)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( !(index1 &gt;= 0 <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
index1 &lt; blob.Length) )</p>

<p class=ILprg>return;</p>

<p class=ILprg>int cb,uncompressedbyte , count;</p>

<p class=ILprg>cb = CorSigUncompressData(blob , index1 , out uncompressedbyte);</p>

<p class=ILprg>count = uncompressedbyte;</p>

<p class=ILprg>byte [] b = new byte[count];</p>

<p class=ILprg>Array.Copy(blob , index1 + cb , b , 0 , count);</p>

<p class=ILprg>if ( b[2] == 0x20 )</p>

<p class=ILprg>return ; // modopt not implemented</p>

<p class=ILprg>if ( b[2] == 0x1B)</p>

<p class=ILprg>return ;// Pointer To function not implemented</p>

<p class=ILprg>int index = 0;</p>

<p class=ILprg>cb = CorSigUncompressData(b , index , out uncompressedbyte);</p>

<p class=ILprg>index++;</p>

<p class=ILprg>cb = CorSigUncompressData(b , index , out uncompressedbyte);</p>

<p class=ILprg>count = uncompressedbyte;</p>

<p class=ILprg>index = index + cb;</p>

<p class=ILprg>string ss11 = &quot;&quot;;</p>

<p class=ILprg>ss11 =<span style="mso-spacerun: yes">  </span>GetElemType(
index,b,out cb) + &quot; &quot; + ss11;</p>

<p class=ILprg>Console.Write(ss11 + &quot; &quot; +
GetString(MethodStruct[row].name) + &quot;(&quot;);</p>

<p class=ILprg>index = index + cb;</p>

<p class=ILprg>int paramindex = MethodStruct[row].param;</p>

<p class=ILprg>string ss = &quot;&quot; , s1;</p>

<p class=ILprg>string ss2 = &quot;&quot;;</p>

<p class=ILprg>int emptyparam = 0;</p>

<p class=ILprg>if ( ParamStruct != null <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
paramindex &lt; ParamStruct.Length <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
</p>

<p class=ILprg>ParamStruct[paramindex].sequence == 0)</p>

<p class=ILprg>emptyparam++; </p>

<p class=ILprg>for ( int l = 1 ; l &lt;= count ; l++)</p>

<p class=ILprg>{</p>

<p class=ILprg>if ( b[index] == 0x2d)</p>

<p class=ILprg>break;</p>

<p class=ILprg>s1 = GetElemType(index,b,out cb);</p>

<p class=ILprg>while ( s1[0] == '[' <span style='font-family:"Bookman Old Style"'>&amp;&amp;</span>
s1[1] == ']' )</p>

<p class=ILprg>{</p>

<p class=ILprg>string ss1 = s1.Substring(2);</p>

<p class=ILprg>ss1 = ss1 + &quot;[]&quot;;</p>

<p class=ILprg>s1 = ss1;</p>

<p class=ILprg>}</p>

<p class=ILprg>index = index + cb;</p>

<p class=ILprg>ss2 = ss2 + s1 ;</p>

<p class=ILprg>if (l != count)</p>

<p class=ILprg>ss2 = ss2 + &quot;,&quot;;</p>

<p class=ILprg>int ind = paramindex + l + emptyparam - 1;</p>

<p class=ILprg>ss = ss + s1 + &quot; &quot; + GetString(ParamStruct[ind].name)
;</p>

<p class=ILprg>if ( l != count)</p>

<p class=ILprg>ss = ss + &quot; , &quot; ;</p>

<p class=ILprg>}</p>

<p class=ILprg>Console.Write(ss + &quot;)&quot;);</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>Console.WriteLine();</p>

<p class=ILprg>}</p>

<p class=ILprg>public void DisplayTableForDebugging ()</p>

<p class=ILprg>{</p>

<p class=ILprg>DisplayModuleTable();</p>

<p class=ILprg>DisplayTypeRefTable();</p>

<p class=ILprg>DisplayTypeDefTable();</p>

<p class=ILprg>DisplayNestedClassTable();</p>

<p class=ILprg>DisplayFieldTable();</p>

<p class=ILprg>DisplayMethodTable();</p>

<p class=ILprg>DisplayParamTable();</p>

<p class=ILprg>DisplayInterfaceImplTable();</p>

<p class=ILprg>DisplayMemberRefTable();</p>

<p class=ILprg>DisplayConstantTable();</p>

<p class=ILprg>DisplayCustomAttributeTable();</p>

<p class=ILprg>DisplayFieldMarshalTable();</p>

<p class=ILprg>DisplayDeclSecurityTable();</p>

<p class=ILprg>DisplayClassLayoutTable();</p>

<p class=ILprg>DisplayFieldLayoutTable();</p>

<p class=ILprg>DisplayStandAloneSigTable();</p>

<p class=ILprg>DisplayEventMapTable();</p>

<p class=ILprg>DisplayEventTable();</p>

<p class=ILprg>DisplayPropertyMapTable();</p>

<p class=ILprg>DisplayPropertiesTable();</p>

<p class=ILprg>DisplayMethodSemanticsTable();</p>

<p class=ILprg>DisplayMethodImpTable();</p>

<p class=ILprg>DisplayModuleRefTable();</p>

<p class=ILprg>DisplayTypeSpecTableTable();</p>

<p class=ILprg>DisplayImplMapTable();</p>

<p class=ILprg>DisplayFieldRVATable();</p>

<p class=ILprg>DisplayAssemblyTable();</p>

<p class=ILprg>DisplayAssemblyRefTable();</p>

<p class=ILprg>DisplayFileTable();</p>

<p class=ILprg>DisplayExportedTypeTable(); </p>

<p class=ILprg>DisplayManifestResourceTable();</p>

<p class=ILprg>}</p>

<p class=ILprg>}</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><u>Output</u></p>

<p class=ILprg>//<span style="mso-spacerun: yes">  </span>Microsoft (R) .NET
Framework IL Disassembler.<span style="mso-spacerun: yes">  </span>Version
1.0.3705.0</p>

<p class=ILprg>//<span style="mso-spacerun: yes">  </span>Copyright (C)
Microsoft Corporation 1998-2001. All rights reserved.</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>// PE Header:</p>

<p class=ILprg>// Subsystem:<span style="mso-spacerun:
yes">                      </span>00000003</p>

<p class=ILprg>// Native entry point address:<span style="mso-spacerun:
yes">     </span>00002c7e</p>

<p class=ILprg>// Image base:<span style="mso-spacerun:
yes">                     </span>00400000</p>

<p class=ILprg>// Section alignment:<span style="mso-spacerun:
yes">              </span>00002000</p>

<p class=ILprg>// File alignment:<span style="mso-spacerun:
yes">                 </span>00000200</p>

<p class=ILprg>// Stack reserve size:<span style="mso-spacerun:
yes">             </span>00100000</p>

<p class=ILprg>// Stack commit size:<span style="mso-spacerun:
yes">              </span>00001000</p>

<p class=ILprg>// Directories:<span style="mso-spacerun:
yes">                    </span>00000010</p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Export
Directory:<span style="mso-spacerun: yes">          </span></p>

<p class=ILprg>// 2c2c<span style="mso-spacerun: yes">   </span>[4f<span
style="mso-spacerun: yes">      </span>] address [size] of Import
Directory:<span style="mso-spacerun: yes">          </span></p>

<p class=ILprg>// 4000<span style="mso-spacerun: yes">  </span>[318<span
style="mso-spacerun: yes">     </span>] address [size] of Resource
Directory:<span style="mso-spacerun: yes">        </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">       </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Exception
Directory:<span style="mso-spacerun: yes">       </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Security
Directory:<span style="mso-spacerun: yes">        </span></p>

<p class=ILprg>// 6000<span style="mso-spacerun: yes">     </span>[c<span
style="mso-spacerun: yes">       </span>] address [size] of Base Relocation
Table:<span style="mso-spacerun: yes">     </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">    </span><span
style="mso-spacerun: yes">    </span>[0<span style="mso-spacerun: yes">      
</span>] address [size] of Debug Directory:<span style="mso-spacerun:
yes">           </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Architecture
Specific:<span style="mso-spacerun: yes">     </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Global
Pointer:<span style="mso-spacerun: yes">            </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of TLS Directory:<span
style="mso-spacerun: yes">  </span><span style="mso-spacerun:
yes">           </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Load Config
Directory:<span style="mso-spacerun: yes">     </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Bound Import
Directory:<span style="mso-spacerun: yes">    </span></p>

<p class=ILprg>// 2000<span style="mso-spacerun: yes">     </span>[8<span
style="mso-spacerun: yes">       </span>] address [size] of Import Address
Table:<span style="mso-spacerun: yes">      </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Delay Load
IAT:<span style="mso-spacerun: yes">            </span></p>

<p class=ILprg>// 2008<span style="mso-spacerun: yes">     </span>[48<span
style="mso-spacerun: yes">      </span>] address [size] of CLR Header:<span
style="mso-spacerun: yes">               </span></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>// Import Address Table</p>

<p class=ILprg>//<span style="mso-spacerun: yes">     </span>mscoree.dll</p>

<p class=ILprg>//<span style="mso-spacerun: yes">              </span>00002000
Import Address Table</p>

<p class=ILprg>//<span style="mso-spacerun: yes">              </span>00002c6e
Import Name Table</p>

<p class=ILprg>//<span style="mso-spacerun: yes">              </span>0<span
style="mso-spacerun: yes">      </span><span style="mso-spacerun:
yes">  </span>time date stamp</p>

<p class=ILprg>//<span style="mso-spacerun: yes">              </span>0<span
style="mso-spacerun: yes">        </span>Index of first forwarder reference</p>

<p class=ILprg>//</p>

<p class=ILprg>//<span style="mso-spacerun: yes">                    </span></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>// Delay Load Import Address Table</p>

<p class=ILprg>// No data.</p>

<p class=ILprg>// CLR Header:</p>

<p class=ILprg>// 72<span style="mso-spacerun: yes">       </span>Header Size</p>

<p class=ILprg>// 2<span style="mso-spacerun: yes">        </span>Major Runtime
Version</p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>Minor Runtime
Version</p>

<p class=ILprg>// 1<span style="mso-spacerun: yes">        </span>Flags</p>

<p class=ILprg>// 6000006<span style="mso-spacerun: yes">  </span>Entrypoint
Token</p>

<p class=ILprg>// 22d4<span style="mso-spacerun: yes">     </span>[958<span
style="mso-spacerun: yes">     </span>] address [size] of Metadata
Directory:<span style="mso-spacerun: yes">        </span></p>

<p class=ILprg>// 2174<span style="mso-spacerun: yes">     </span>[15f<span
style="mso-spacerun: yes">     </span>] address [size] of Resources
Directory:<span style="mso-spacerun: yes">       </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Strong Name
Signature:<span style="mso-spacerun: yes">     </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of CodeManager
Table:<span style="mso-spacerun: yes">         </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of VTableFixups
Directory:<span style="mso-spacerun: yes">    </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Export Address
Table:<span style="mso-spacerun: yes">      </span></p>

<p class=ILprg>// 0<span style="mso-spacerun: yes">        </span>[0<span
style="mso-spacerun: yes">       </span>] address [size] of Precompile
Header:<span style="mso-spacerun: yes">         </span></p>

<p class=ILprg>// Code Manager Table:</p>

<p class=ILprg>//<span style="mso-spacerun: yes">  </span>default</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Metadata Details</p>

<p class=ILprg>Start of Metadata 8916 rva=1236</p>

<p class=ILprg>Length of String 12</p>

<p class=ILprg>No of streams 5 Position=1268</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Stream Details</p>

<p class=ILprg>offset=108 size=928 Position=1276</p>

<p class=ILprg>offset=1036 size=500 Position=1288</p>

<p class=ILprg>offset=1536 size=40 Position=1308</p>

<p class=ILprg>offset=1576 size=16 Position=1320</p>

<p class=ILprg>offset=1592 size=800 Position=1336</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>Strings Stream</p>

<p class=ILprg>&lt;Module&gt; </p>

<p class=ILprg>b.exe </p>

<p class=ILprg>mscorlib </p>

<p class=ILprg>System </p>

<p class=ILprg>Object </p>

<p class=ILprg>zzz </p>

<p class=ILprg>iii </p>

<p class=ILprg>yyy </p>

<p class=ILprg>uuu </p>

<p class=ILprg>a1 </p>

<p class=ILprg>j </p>

<p class=ILprg>i </p>

<p class=ILprg>EventHandler </p>

<p class=ILprg>a </p>

<p class=ILprg>add_a </p>

<p class=ILprg>remove_a </p>

<p class=ILprg>b </p>

<p class=ILprg>add_b </p>

<p class=ILprg>remove_b </p>

<p class=ILprg>MessageBox </p>

<p class=ILprg>Main </p>

<p class=ILprg>abc </p>

<p class=ILprg>pqr </p>

<p class=ILprg>xyz </p>

<p class=ILprg>.ctor </p>

<p class=ILprg>xxx </p>

<p class=ILprg>set_aa </p>

<p class=ILprg>get_aa </p>

<p class=ILprg>set_bb </p>

<p class=ILprg>get_bb </p>

<p class=ILprg>iii.xxx </p>

<p class=ILprg>aaa </p>

<p class=ILprg>aa </p>

<p class=ILprg>bb </p>

<p class=ILprg>System.Security.Permissions </p>

<p class=ILprg>SecurityPermissionAttribute </p>

<p class=ILprg>SecurityAction </p>

<p class=ILprg>System.Diagnostics </p>

<p class=ILprg>DebuggableAttribute </p>

<p class=ILprg>value </p>

<p class=ILprg>Delegate </p>

<p class=ILprg>Combine </p>

<p class=ILprg>Remove </p>

<p class=ILprg>System.Runtime.InteropServices </p>

<p class=ILprg>DllImportAttribute </p>

<p class=ILprg>user32.dll </p>

<p class=ILprg>hWnd </p>

<p class=ILprg>text </p>

<p class=ILprg>caption </p>

<p class=ILprg>type </p>

<p class=ILprg>Int32 </p>

<p class=ILprg>Console </p>

<p class=ILprg>WriteLine </p>

<p class=ILprg>k </p>

<p class=ILprg>System.Security </p>

<p class=ILprg>UnverifiableCodeAttribute </p>

<p class=ILprg>a.resources </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>US Stream</p>

<p class=ILprg>hell {0} </p>

<p class=ILprg>hi </p>

<p class=ILprg>hello </p>

<p class=ILprg><span style="mso-spacerun: yes"> </span></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>GUID Stream</p>

<p class=ILprg>{A7CC9DDA-703D-4946-8C4C-DE78659FDC3}</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>Stream offset and stream
size</p>

<p class=ILprg>#~...offset: 108 size:928</p>

<p class=ILprg>#Strings...offset: 1036 size:500</p>

<p class=ILprg>#US...offset: 1536 size:40</p>

<p class=ILprg>#GUID...offset: 1576 size:16</p>

<p class=ILprg>#Blob...offset: 1592 size:800</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Number of Rows in the tables: </p>

<p class=ILprg>NestedClass<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>ManifestResource<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>AssemblyRef<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>Assembly<span style="mso-spacerun: yes">  </span>: <span
style="mso-spacerun: yes"> </span>1</p>

<p class=ILprg>ImplMap<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>ModuleRef<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>MethodImpl<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>MethodSemantics<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>8</p>

<p class=ILprg>Properties<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>2</p>

<p class=ILprg>PropertyMap<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>Event<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>2</p>

<p class=ILprg>EventMap<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>StandAloneSig<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>3</p>

<p class=ILprg>DeclSecurity<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>CustomAttribute<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>2</p>

<p class=ILprg>Constant<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>MemberRef<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>9</p>

<p class=ILprg>InterfaceImpl<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg>Param<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>15</p>

<p class=ILprg>Method<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>21</p>

<p class=ILprg>Field<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>4</p>

<p class=ILprg>TypeDef<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>6</p>

<p class=ILprg>TypeRef<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>10</p>

<p class=ILprg>Module<span style="mso-spacerun: yes">  </span>:<span
style="mso-spacerun: yes">  </span>1</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>Table Details<span
style="mso-spacerun: yes">   </span></p>

<p class=ILprg>Module Table Offset 120 Size 10</p>

<p class=ILprg>TypeRef Table Offset 130 Size 6</p>

<p class=ILprg>TypeDef Table Offset 190 Size 14</p>

<p class=ILprg>Field Table Offset 274 Size 6</p>

<p class=ILprg>Method Table Offset 298 Size 14</p>

<p class=ILprg>Param Table Offset 592 Size 6</p>

<p class=ILprg>InterfaceImpl Table Offset 682 Size 4</p>

<p class=ILprg>MemberRef Table Offset 686 Size 6</p>

<p class=ILprg>Constant Table Offset 740 Size 6</p>

<p class=ILprg>CustomAttribute Table Offset 746 Size 6</p>

<p class=ILprg>FieldMarshal Table Offset 758</p>

<p class=ILprg>DeclSecurity Table Offset 758</p>

<p class=ILprg>ClassLayout Table Offset 764</p>

<p class=ILprg>FieldLayout Table Offset 764</p>

<p class=ILprg>StandAloneSig Table Offset 764</p>

<p class=ILprg>EventMap Table Offset 770</p>

<p class=ILprg>Event Table Offset 774</p>

<p class=ILprg>PropertyMap Table Offset 786</p>

<p class=ILprg>Property Table Offset 790</p>

<p class=ILprg>MethodSemantics Table Offset 802</p>

<p class=ILprg>MethodImpl Table Offset 850</p>

<p class=ILprg>ModuleRef Table Offset 856</p>

<p class=ILprg>TypeSpec Table Offset 858 size=0</p>

<p class=ILprg>ImplMap Table Offset offs=858 rows=1 len=928</p>

<p class=ILprg>FieldRVA Table Offset 866</p>

<p class=ILprg>Assembly Table Offset 866</p>

<p class=ILprg>AssembleyRef Table Offset 888</p>

<p class=ILprg>File Table Offset 908</p>

<p class=ILprg>ExportedType Table Offset 908</p>

<p class=ILprg>ManifestResource Table Offset 908</p>

<p class=ILprg>Nested Classes Offset 920</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Module Table</p>

<p class=ILprg>Generation: 0</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">      </span>:b.exe A</p>

<p class=ILprg>Mvid<span style="mso-spacerun: yes">      </span>:#GUID[1]</p>

<p class=ILprg>EncId<span style="mso-spacerun: yes">     </span>:#GUID[0]</p>

<p class=ILprg>EncBaseId :#GUID[0]</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>TypeRef Table</p>

<p class=ILprg>Row[1]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">           </span>:Object</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">      </span>:System</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[2]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:EventHandler</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">      </span>:System</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[3]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:SecurityPermissionAttribute</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">     
</span>:System.Security.Permissions</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[4]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:SecurityAction</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">     
</span>:System.Security.Permissions</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[5]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:DebuggableAttribute</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">     
</span>:System.Diagnostics</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[6]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">           </span>:Delegate</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">      </span>:System</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[7]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:DllImportAttribute</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">     
</span>:System.Runtime.InteropServices</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[8]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">           </span>:Int32</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">      </span>:System</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[9]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">           </span>:Console</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">      </span>:System</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row[10]</p>

<p class=ILprg>ResolutionScope:AssemblyRef[1]...mscorlib </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:UnverifiableCodeAttribute</p>

<p class=ILprg>Namespace<span style="mso-spacerun: yes">     
</span>:System.Security</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>TypeDefTable</p>

<p class=ILprg>Row:1</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">     </span>: Class</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">      </span>:
&lt;Module&gt;</p>

<p class=ILprg>NameSpace : </p>

<p class=ILprg>Extends: TypeDef[0].....</p>

<p class=ILprg>FieldList Field[1]</p>

<p class=ILprg>MethodList Method[1]</p>

<p class=ILprg>Number Of Methods 0</p>

<p class=ILprg>Number Of Fields 0</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row:2</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">     </span>: AutoLayout,
AnsiClass, NotPublic, Public, BeforeFieldInit</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span><span
style="mso-spacerun: yes"> </span>: zzz</p>

<p class=ILprg>NameSpace : </p>

<p class=ILprg>Extends: TypeRef[1].....System.Object</p>

<p class=ILprg>FieldList Field[1]</p>

<p class=ILprg>MethodList Method[1]</p>

<p class=ILprg>Number Of Methods 10</p>

<p class=ILprg>1. add_a</p>

<p class=ILprg>2. remove_a</p>

<p class=ILprg>3. add_b</p>

<p class=ILprg>4. remove_b</p>

<p class=ILprg>5. MessageBox</p>

<p class=ILprg>6. Main</p>

<p class=ILprg>7. abc</p>

<p class=ILprg>8. pqr</p>

<p class=ILprg>9. xyz</p>

<p class=ILprg>10. .ctor</p>

<p class=ILprg>Number Of Fields 4</p>

<p class=ILprg>1. j</p>

<p class=ILprg>2. i</p>

<p class=ILprg>3. a</p>

<p class=ILprg>4. b</p>

<p class=ILprg>Number of Events 2</p>

<p class=ILprg>1. a</p>

<p class=ILprg>2. b</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row:3</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">     </span>: AutoLayout,
AnsiClass, NotPublic, ClassSemanticsMask, Abstract</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">      </span>: iii</p>

<p class=ILprg>NameSpace : </p>

<p class=ILprg>Extends: TypeDef[0].....</p>

<p class=ILprg>FieldList Field[5]</p>

<p class=ILprg>MethodList Method[11]</p>

<p class=ILprg>Number Of Methods 1</p>

<p class=ILprg>11. xxx</p>

<p class=ILprg>Number Of Fields 0</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row:4</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">     </span>: AutoLayout,
AnsiClass, NotPublic, Public, BeforeFieldInit</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">      </span>: yyy</p>

<p class=ILprg>NameSpace : </p>

<p class=ILprg>Extends: TypeRef[1].....System.Object</p>

<p class=ILprg>FieldList Field[5]</p>

<p class=ILprg>MethodList Method[12]</p>

<p class=ILprg>Number Of Methods 8</p>

<p class=ILprg>12. set_aa</p>

<p class=ILprg>13. get_aa</p>

<p class=ILprg>14. set_bb</p>

<p class=ILprg>15. get_bb</p>

<p class=ILprg>16. uuu</p>

<p class=ILprg>17. iii.xxx</p>

<p class=ILprg>18. aaa</p>

<p class=ILprg>19. .ctor</p>

<p class=ILprg>Number Of Fields 0</p>

<p class=ILprg>Number of Properties 2</p>

<p class=ILprg>1. aa</p>

<p class=ILprg>2. bb</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row:5</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">     </span>: AutoLayout,
AnsiClass, NotPublic, Public, BeforeFieldInit</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">      </span>: uuu</p>

<p class=ILprg>NameSpace : </p>

<p class=ILprg>Extends: TypeDef[4].....Class yyy Extends System.Object</p>

<p class=ILprg>FieldList Field[5]</p>

<p class=ILprg>MethodList Method[20]</p>

<p class=ILprg>Number Of Methods 1</p>

<p class=ILprg>20. .ctor</p>

<p class=ILprg>Number Of Fields 0</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row:6</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">     </span>: AutoLayout,
AnsiClass, NotPublic, NestedPrivate, BeforeFieldInit</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">      </span>: a1</p>

<p class=ILprg>NameSpace : </p>

<p class=ILprg>Extends: TypeRef[1].....System.Object</p>

<p class=ILprg>FieldList Field[5]</p>

<p class=ILprg>MethodList Method[21]</p>

<p class=ILprg>Number Of Methods 1</p>

<p class=ILprg>21. .ctor</p>

<p class=ILprg>Number Of Fields 0</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Nested Classes Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Nested<span style="mso-spacerun: yes">    </span>Class
TypeDef[6]...Class a1 Extends System.Object</p>

<p class=ILprg>Enclosing Class TypeDef[5]...Class uuu</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>FieldTable</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Flags: -32687</p>

<p class=ILprg>Name : j</p>

<p class=ILprg>count 2 index 10</p>

<p class=ILprg>Signature BLOB[10]...6 8 ..int32</p>

<p class=ILprg>Row 2</p>

<p class=ILprg>Flags: 17</p>

<p class=ILprg>Name : i</p>

<p class=ILprg>count 2 index 10</p>

<p class=ILprg>Signature BLOB[10]...6 8 ..int32</p>

<p class=ILprg>Row 3</p>

<p class=ILprg>Flags: 1</p>

<p class=ILprg>Name : a</p>

<p class=ILprg>count 3 index 18</p>

<p class=ILprg>Signature BLOB[18]...6 18 9 ..class</p>

<p class=ILprg>Row 4</p>

<p class=ILprg>Flags: 1</p>

<p class=ILprg>Name : b</p>

<p class=ILprg>count 3 index 18</p>

<p class=ILprg>Signature BLOB[18]...6 18 9 ..class</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Method Table</p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:1</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2050</p>

<p class=ILprg>ImpFlags :Synchronized</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: add_a</p>

<p class=ILprg>Signature: #Blob[22]</p>

<p class=ILprg>ParamList: Param[1]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>1. value</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>add_a(class
EventHandler value)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:2</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2069</p>

<p class=ILprg>ImpFlags :Synchronized</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">  </span><span
style="mso-spacerun: yes">  </span>:2182</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: remove_a</p>

<p class=ILprg>Signature: #Blob[22]</p>

<p class=ILprg>ParamList: Param[2]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>2. value</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>remove_a(class
EventHandler value)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:3</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2082</p>

<p class=ILprg>ImpFlags :Synchronized</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: add_b</p>

<p class=ILprg>Signature: #Blob[22]</p>

<p class=ILprg>ParamList: Param[3]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>3. value</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>add_b(class
EventHandler value)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:4</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:209B</p>

<p class=ILprg>ImpFlags :Synchronized</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: remove_b</p>

<p class=ILprg>Signature: #Blob[22]</p>

<p class=ILprg>ParamList: Param[4]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>4. value</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>remove_b(class
EventHandler value)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:5</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:0</p>

<p class=ILprg>ImpFlags :PreserveSig</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:8342</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: MessageBox</p>

<p class=ILprg>Signature: #Blob[28]</p>

<p class=ILprg>ParamList: Param[5]</p>

<p class=ILprg>Number Of Params 4</p>

<p class=ILprg>5. hWnd</p>

<p class=ILprg>6. text</p>

<p class=ILprg>7. caption</p>

<p class=ILprg>8. type</p>

<p class=ILprg>int32<span style="mso-spacerun: yes">  </span>MessageBox(int32
hWnd , string text , string caption , unsigned int32 type)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:6</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:20B4</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:150</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: Main</p>

<p class=ILprg>Signature: #Blob[36]</p>

<p class=ILprg>ParamList: Param[9]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>Main()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:7</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:20D4</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:134</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: abc</p>

<p class=ILprg>Signature: #Blob[40]</p>

<p class=ILprg>ParamList: Param[9]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>9. k</p>

<p class=ILprg>int32<span style="mso-spacerun: yes">  </span>abc(float32 k)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:8</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:20E8</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:134</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: pqr</p>

<p class=ILprg>Signature: #Blob[45]</p>

<p class=ILprg>ParamList: Param[10]</p>

<p class=ILprg>Number Of Params 2</p>

<p class=ILprg>10. i</p>

<p class=ILprg>11. j</p>

<p class=ILprg>int64<span style="mso-spacerun: yes">  </span>pqr(int32[] i ,
char j)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:9</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:20FB</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:134</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: xyz</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[12]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>xyz()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:10</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:20FD</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:6278</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: .ctor</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[12]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>.ctor()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:11</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:0</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:1478</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: xxx</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[12]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>xxx()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:12</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2105</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name <span style="mso-spacerun: yes">    </span>: set_aa</p>

<p class=ILprg>Signature: #Blob[56]</p>

<p class=ILprg>ParamList: Param[12]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>12. value</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>set_aa(int32 value)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:13</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2108</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: get_aa</p>

<p class=ILprg>Signature: #Blob[61]</p>

<p class=ILprg>ParamList: Param[13]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>int32<span style="mso-spacerun: yes">  </span>get_aa()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:14</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:211B</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: set_bb</p>

<p class=ILprg>Signature: #Blob[65]</p>

<p class=ILprg>ParamList: Param[13]</p>

<p class=ILprg>Number Of Params 1</p>

<p class=ILprg>13. value</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>set_bb(string
value)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:15</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2120</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:2182</p>

<p class=ILprg>Name <span style="mso-spacerun: yes">    </span>: get_bb</p>

<p class=ILprg>Signature: #Blob[70]</p>

<p class=ILprg>ParamList: Param[14]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>string<span style="mso-spacerun: yes">  </span>get_bb()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:16</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2138</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:134</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: uuu</p>

<p class=ILprg>Signature: #Blob[74]</p>

<p class=ILprg>ParamList: Param[14]</p>

<p class=ILprg>Number Of Params 2</p>

<p class=ILprg>14. i</p>

<p class=ILprg>15. j</p>

<p class=ILprg>int64<span style="mso-spacerun: yes">  </span>uuu(int32 i ,
char[] j)</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:17</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:214B</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:481</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: iii.xxx</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[16]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>iii.xxx()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:18</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2157</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:134</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: aaa</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[16]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>aaa()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:19</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2159</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:6278</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: .ctor</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[16]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>.ctor()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:20</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2161</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:6278</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: .ctor</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[16]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>.ctor()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row<span style="mso-spacerun: yes">      </span>:21</p>

<p class=ILprg>RVA<span style="mso-spacerun: yes">      </span>:2169</p>

<p class=ILprg>ImpFlags :Managed</p>

<p class=ILprg>Flags<span style="mso-spacerun: yes">    </span>:6278</p>

<p class=ILprg>Name<span style="mso-spacerun: yes">     </span>: .ctor</p>

<p class=ILprg>Signature: #Blob[52]</p>

<p class=ILprg>ParamList: Param[16]</p>

<p class=ILprg>Number Of Params 0</p>

<p class=ILprg>void<span style="mso-spacerun: yes">  </span>.ctor()</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Param Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name value</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 2</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name value</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 3</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name value</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 4</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name value</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 5</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name hWnd</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 6</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 2</p>

<p class=ILprg>Name text</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 7</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 3</p>

<p class=ILprg>Name caption</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 8</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 4</p>

<p class=ILprg>Name type</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 9</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name k</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 10</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name i</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 11</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 2</p>

<p class=ILprg>Name j</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 12</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name value</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 13</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name value</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 14</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 1</p>

<p class=ILprg>Name i</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 15</p>

<p class=ILprg>ParamAttributes None Bytes 0</p>

<p class=ILprg>Sequence 2</p>

<p class=ILprg>Name j</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>InterfaceImpl Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Class TypeDef[4]...Class yyy Extends System.Object</p>

<p class=ILprg>Interface TypeDef[3] Class iii</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>MemberRef Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>TypeRef[3]:System.Security.Permissions.SecurityPermissionAttribute</p>

<p class=ILprg>Name:.ctor</p>

<p class=ILprg>Signature #BLOB[89] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 2</p>

<p class=ILprg>TypeRef[5]:System.Diagnostics.DebuggableAttribute</p>

<p class=ILprg>Name:.ctor</p>

<p class=ILprg>Signature #BLOB[95] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 3</p>

<p class=ILprg>TypeRef[6]:System.Delegate</p>

<p class=ILprg>Name:Combine</p>

<p class=ILprg>Signature #BLOB[101] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 4</p>

<p class=ILprg>TypeRef[6]:System.Delegate</p>

<p class=ILprg>Name:Remove</p>

<p class=ILprg>Signature #BLOB[101] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 5</p>

<p class=ILprg>TypeRef[7]:System.Runtime.InteropServices.DllImportAttribute</p>

<p class=ILprg>Name:.ctor</p>

<p class=ILprg>Signature #BLOB[65] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 6</p>

<p class=ILprg>TypeRef[9]:System.Console</p>

<p class=ILprg>Name:WriteLine</p>

<p class=ILprg>Signature #BLOB[110] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 7</p>

<p class=ILprg>TypeRef[1]:System.Object</p>

<p class=ILprg>Name:.ctor</p>

<p class=ILprg>Signature #BLOB[52] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 8</p>

<p class=ILprg>TypeRef[9]:System.Console</p>

<p class=ILprg>Name:WriteLine</p>

<p class=ILprg>Signature #BLOB[128] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Row 9</p>

<p class=ILprg>TypeRef[10]:System.Security.UnverifiableCodeAttribute</p>

<p class=ILprg>Name:.ctor</p>

<p class=ILprg>Signature #BLOB[52] </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Constant Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Type int32</p>

<p class=ILprg>Parent: FieldDef[1] Name of Constant... j </p>

<p class=ILprg>Blob BLOB[13] Count 4 2 0 0 0<span style="mso-spacerun: yes"> 
</span>Value 2 </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>CustomAttribute Table</p>

<p class=ILprg>Row [1]</p>

<p class=ILprg>Parent: Module[1]...b.exe</p>

<p class=ILprg>Type: MethodRef[9]....ctor </p>

<p class=ILprg>Value Blob[133] Count 4 Bytes 1 0 0 0 </p>

<p class=ILprg>Row [2]</p>

<p class=ILprg>Parent: Assembly[1]...b</p>

<p class=ILprg>Type: MethodRef[2]....ctor </p>

<p class=ILprg>Value Blob[138] Count 6 Bytes 1 0 0 1 0 0 </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>DeclSecurity Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Action 8</p>

<p class=ILprg>Parent: Assembly[1]... b</p>

<p class=ILprg>Permission Set BLOB[147] Count=652 </p>

<p class=ILprg>&lt; P e r m i s s i o n S e t<span style="mso-spacerun: yes">  
</span>c l a s s = &quot; S y s t e m . S e c u r i t y . P e r m i s s i o n S
e t &quot; </p>

<p class=ILprg><span style="mso-spacerun: yes">                       </span><span
style="mso-spacerun: yes">        </span>v e r s i o n = &quot; 1 &quot; &gt; </p>

<p class=ILprg><span style="mso-spacerun: yes">       </span>&lt; I P e r m i s
s i o n<span style="mso-spacerun: yes">   </span>c l a s s = &quot; S y s t e m
. S e c u r i t y . P e r m i s s i o n s . S e c u r i t y P e r m i s s i o n
,<span style="mso-spacerun: yes">   </span>m s c o r l i b ,<span
style="mso-spacerun: yes">   </span>V e r s i o n = 1 . 0 . 3 3 0 0 . 0 ,<span
style="mso-spacerun: yes">   </span>C u l t u r e = n e u t r a l ,<span
style="mso-spacerun: yes">   </span>P u b l i c K e y T o k e n = b 7 7 a 5 c 5
6 1 9 3 4 e 0 8 9 &quot; </p>

<p class=ILprg><span style="mso-spacerun: yes">                                
</span>v e r s i o n = &quot; 1 &quot; </p>

<p class=ILprg><span style="mso-spacerun: yes">                                
</span>F l a g s = &quot; S k i p V e r i f i c a t i o n &quot; / &gt; </p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>&lt; / P e r m i s s i o
n S e t &gt; </p>

<p class=ILprg><span style="mso-spacerun: yes"> </span></p>

<p class=ILprg>StandAloneSig Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Signature BLOB[116] Count 3 7 1 8<span style="mso-spacerun:
yes">  </span></p>

<p class=ILprg>Row 2</p>

<p class=ILprg>Signature BLOB[120] Count 3 7 1 10<span style="mso-spacerun:
yes">  </span></p>

<p class=ILprg>Row 3</p>

<p class=ILprg>Signature BLOB[124] Count 3 7 1 14<span style="mso-spacerun:
yes">  </span></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>EventMap Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Parent TypeDef[2]...Class zzz Extends System.Object</p>

<p class=ILprg>EventList Event[1]...Event a System.EventHandler </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Event Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Event Flags: None</p>

<p class=ILprg>Name: a</p>

<p class=ILprg>Event Type:TypeRef[2]... System.EventHandler</p>

<p class=ILprg>Row 2</p>

<p class=ILprg>Event Flags: None</p>

<p class=ILprg>Name: b</p>

<p class=ILprg>Event Type:TypeRef[2]... System.EventHandler</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>Property Map Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Parent TypeDef[4]...Class yyy Extends System.Object</p>

<p class=ILprg>PropertyList Property[1]...aa</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Properties Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Flags [0]</p>

<p class=ILprg>Name aa</p>

<p class=ILprg>Type BLOB[81]...3 40 0 8<span style="mso-spacerun: yes"> 
</span></p>

<p class=ILprg>Row 2</p>

<p class=ILprg>Flags [0]</p>

<p class=ILprg>Name bb</p>

<p class=ILprg>Type BLOB[85]...3 40 0 14<span style="mso-spacerun: yes"> 
</span></p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>MethodSemantics Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Semantics Event Remove </p>

<p class=ILprg>Method Method[2]...remove_a</p>

<p class=ILprg>Association:Event[1]...Event a System.EventHandler<span
style="mso-spacerun: yes">  </span></p>

<p class=ILprg>Row 2</p>

<p class=ILprg>Semantics Event Addon </p>

<p class=ILprg>Method Method[1]...add_a</p>

<p class=ILprg>Association:Event[1]...Event a System.EventHandler<span
style="mso-spacerun: yes">  </span></p>

<p class=ILprg>Row 3</p>

<p class=ILprg>Semantics Setter </p>

<p class=ILprg>Method Method[12]...set_aa</p>

<p class=ILprg>Association:Property[1]...aa </p>

<p class=ILprg>Row 4</p>

<p class=ILprg>Semantics Getter </p>

<p class=ILprg>Method Method[13]...get_aa</p>

<p class=ILprg>Association:Property[1]...aa </p>

<p class=ILprg>Row 5</p>

<p class=ILprg>Semantics Event Remove </p>

<p class=ILprg>Method Method[4]...remove_b</p>

<p class=ILprg>Association:Event[2]...Event b System.EventHandler<span
style="mso-spacerun: yes">  </span></p>

<p class=ILprg>Row 6</p>

<p class=ILprg>Semantics Event Addon </p>

<p class=ILprg>Method Method[3]...add_b</p>

<p class=ILprg>Association:Event[2]...Event b System.EventHandler<span
style="mso-spacerun: yes">  </span></p>

<p class=ILprg>Row 7</p>

<p class=ILprg>Semantics Getter </p>

<p class=ILprg>Method Method[15]...get_bb</p>

<p class=ILprg>Association:Property[2]...bb </p>

<p class=ILprg>Row 8</p>

<p class=ILprg>Semantics Setter </p>

<p class=ILprg>Method Method[14]...set_bb</p>

<p class=ILprg>Association:Property[2]...bb </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>MethodImp Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Class TypeDef[4]...Class yyy Extends System.Object</p>

<p class=ILprg>MethodBody<span style="mso-spacerun: yes"> 
</span>MethodDef[17]...iii.xxx </p>

<p class=ILprg>MethodDeclaration<span style="mso-spacerun: yes"> 
</span>MethodDef[11]...xxx </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>ModuleRef Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Name user32.dll</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>ImplMap Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Mapping Flags<span style="mso-spacerun: yes"> 
</span>:CharSetNotSpec CallConvWinapi </p>

<p class=ILprg>MemberForwarded:MethodDef[5]...MessageBox </p>

<p class=ILprg>Name<span style="mso-spacerun: yes">          
</span>:MessageBox</p>

<p class=ILprg>Import Scope<span style="mso-spacerun: yes">  
</span>:ModuleRef[1] user32.dll</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Assembly Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>HashAlgId 32772</p>

<p class=ILprg>MajorVersion 0</p>

<p class=ILprg>MinorVersion 0</p>

<p class=ILprg>BuildNumber 0</p>

<p class=ILprg>RevisionNumber 0</p>

<p class=ILprg>Flags 0</p>

<p class=ILprg>Public Key #BLOB[0] Count 0</p>

<p class=ILprg>Name:b</p>

<p class=ILprg>Culture:</p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg><span style="mso-spacerun: yes"> </span>AssemblyRef Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>MajorVersion 1</p>

<p class=ILprg>MinorVersion 0</p>

<p class=ILprg>BuildNumber 3300</p>

<p class=ILprg>RevisionNumber 0</p>

<p class=ILprg>Flags 0</p>

<p class=ILprg>Public Key or Token #BLOB[1] Count 8</p>

<p class=ILprg>B7 7A 5C 56 19 34 E0 89 </p>

<p class=ILprg>Name:mscorlib</p>

<p class=ILprg>Culture:</p>

<p class=ILprg>Hash Value #BLOB[0] Count 0 </p>

<p class=ILprg><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>Manifest Resource Table</p>

<p class=ILprg>Row 1</p>

<p class=ILprg>Offset 0</p>

<p class=ILprg>Flags Public </p>

<p class=ILprg>Name a.resources</p>

<p class=ILprg>Implementation: File[0]...</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The Main function in the zzz class calls the abc function,
which launches forthwith the task of displaying information from the metadata
table, by calling other functions. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>public void abc(string [] args)<span style='mso-tab-count:1'>     </span></p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>InitializeObjects(args);</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>ReadPEStructures();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>DisplayPEStructures();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>ImportAdressTable();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>CLRHeader();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>ReadStreamsData();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>FillTableSizes();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>ReadTablesIntoStructures();</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>DisplayTableForDebugging();</p>

<p class=ILprg>}</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The first function to be called is InitializeObject.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>public void InitializeObjects(string [] args)<span
style="mso-spacerun: yes">  </span>{</p>

<p class=ILprg>tablenames = new String[]{&quot;Module&quot; ,
&quot;TypeRef&quot; ,<span style='mso-tab-count:1'>            </span>&quot;TypeDef&quot;
,&quot;FieldPtr&quot;,&quot;Field&quot;,
&quot;MethodPtr&quot;,&quot;Method&quot;,&quot;ParamPtr&quot; ,
&quot;Param&quot;, &quot;InterfaceImpl&quot;, &quot;MemberRef&quot;,
&quot;Constant&quot;, &quot;CustomAttribute&quot;, &quot;FieldMarshal&quot;,
&quot;DeclSecurity&quot;, &quot;ClassLayout&quot;, &quot;FieldLayout&quot;,
&quot;StandAloneSig&quot; , &quot;EventMap&quot;,&quot;EventPtr&quot;,
&quot;Event&quot;, &quot;PropertyMap&quot;, &quot;PropertyPtr&quot;,
Properties&quot;,&quot;MethodSemantics&quot;,</p>

<p class=ILprg>&quot;MethodImpl&quot;,&quot;ModuleRef&quot;,&quot;TypeSpec&quot;,&quot;ImplMap&quot;,&quot;FieldRVA&quot;,&quot;ENCLog&quot;,&quot;ENCMap&quot;,</p>

<p class=ILprg>&quot;Assembly&quot;,&quot;AssemblyProcessor&quot;,&quot;AssemblyOS&quot;,&quot;AssemblyRef&quot;,</p>

<p class=ILprg>&quot;AssemblyRefProcessor&quot;,&quot;AssemblyRefOS&quot;,&quot;File&quot;,&quot;ExportedType&quot;,</p>

<p class=ILprg>&quot;ManifestResource&quot;,&quot;NestedClass&quot;,&quot;TypeTyPar&quot;,&quot;MethodTyPar&quot;};</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>if
( args.Length == 0)</p>

<p class=ILprg><span style='mso-tab-count:3'>                                    </span>filename
= &quot;C:\\mdata\\b.exe&quot;;</p>

<p class=ILprg><span style='mso-tab-count:2'>                        </span>else</p>

<p class=ILprg><span style='mso-tab-count:3'>                                    </span>filename
= args[0];</p>

<p class=ILprg>}</p>

<p class=ILbase>This function verifies if the executable has been called with
any command line arguments or not. If the executable has been called with a
single argument, i.e. &gt;a mscorlib.dll, the 0th member becomes the first
argument, i.e. mscorlib.dll and the length member becomes a non-zero number. In
the case where command line arguments have not been supplied, the file named
b.exe gets scrutinized by default. We have tried and tested this program with
mscorlib.dll, and with various other dlls that are furnished together with the
.Net framework. You may disassemble the main program to authenticate whether
the output relates to the program file or not. Just make a copy of a.exe as
bb.exe, and then, run the program as </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase><span style='mso-tab-count:1'>            </span>&gt;a bb.exe</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Every metadata table is identified by a name and an id. The
first table has an id of 0 and the name of 'module'. Similarly, the second
table has an id of 1 and the name of 'TypeDef'. There are a total of 43 such
defined tables. However, in the IL disassembled mode, the name is not stored
anywhere, since the table is referenced by its id.<span style="mso-spacerun:
yes">  </span>So, in order to display a readable output, we have stored the
tables' names in an array, where the offset in the array can be regarded as the
id.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>We start deciphering the file contents from the next function
named ReadPEStructures. The PE file header is read first, followed by the Image
Optional Header. The virtual address, size of rawdata and pointer to rawdata,
are all stored in separate arrays. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The function DisplayPEStructures displays the output as emitted
by the Microsoft ILDASM program utility. Also, the functions of ImportAddressTable
and DisplayFromFile facilitate the display of the output as depicted by the
utility. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The Data Directory renders information about where the
Directories begin, i.e. its Relative Virtual Address (RVA) and the size. An RVA
is a memory location. However, since the file is read from the disk and is not
loaded into the memory, the disk locations of these directories need to be
ascertained.<span style="mso-spacerun: yes">  </span>The DisplayDataDirectory
function prints out these details in a proper format for every directory.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The second last data directory member, i.e. CLR header, is a
recipient of special treatment, since it forms the very foundation of the
metadata information. The CLRHeader function details every aspect of the
header.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The PE file format has a sections table, which is a series of
structures containing variegated information about data code, etc. It also
stores the starting locations of these sections in both, the memory and on the
disk, together with the size of each section. The ConvertRVA function
determines the actual disk location of a section whose memory location has been
provided.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The metadata header is read into different variables and then,
these details are displayed using the WriteLine function.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The next function to be called in the abc function is
ReadStreamsData(). It is very similar to what we have observed in the earlier
chapters. The lone dissimilarity is that, the variable startofmetadata has been
initialized using the ConvertRVA function. The filepointer is then positioned
at the startofmetadata in memory, by using the Position property in the stream.
A vital point to be taken into account is that, everything in the .Net world is
aligned at 4.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>In the .Net world, the metadata tables are stored as offsets or
indexes in the streams of String, GUID or Blob. The question that crops up now
is, whether these indexes should take up 2 bytes or 4 bytes. The answer depends
entirely on the stream sizes.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>If the stream size is upto 64K, then the index field takes up 2
byes. However, if it exceeds 64K, then the index takes up 4 bytes. The
designers of metadata could have stringently fixed it at 4 bytes, but they were
quick to realize that this approach would result in excessive wastage of space.
Thus, it is amply evident that the metadata concept has been primarily designed
for efficiency. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Five arrays have been created for the five streams. Then, the
data contained within the streams is stored within them. Thereafter, the
details of the streams, barring the #~ stream, are printed out. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The 6th byte from the start of the metadata header is a byte
called heapsize. Out of the 8 bits, 3 bits are inspected to ascertain the size
of the index. If the first bit is on, the string size is larger than 64 K, and
therefore, the offsetstring variable is set to 4. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>if ( (heapsizes<span style='mso-tab-count:1'>   </span><span
style='font-family:"Bookman Old Style"'>&amp;</span> 0x01)<span
style='mso-tab-count:1'>            </span>== 0x01)</p>

<p class=ILprg><span style='mso-tab-count:3'>                                    </span>offsetstring<span
style="mso-spacerun: yes">  </span>=<span style='mso-tab-count:1'>   </span>4;</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Similarly, the second and the third bits are checked, and if
these bits are on, the variables of offsetguid and offsetblob are assigned a
value of 4 each, respectively.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>if ( (heapsizes<span style='mso-tab-count:1'>   </span><span
style='font-family:"Bookman Old Style"'>&amp;</span> 0x02)<span
style='mso-tab-count:1'>            </span>== 0x02)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>offsetguid = 4;</p>

<p class=ILprg>if ( (heapsizes<span style='mso-tab-count:1'>   </span><span
style='font-family:"Bookman Old Style"'>&amp;</span> 0x04)<span
style='mso-tab-count:1'>            </span>== 0x04)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>offsetblob = 4;</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>By default, the three variables of offsetstring, offsetguid and
offsetblob are initialized to a value of 3.<span style="mso-spacerun: yes"> 
</span>Thereafter, to eschew any further complications, the functions of
ReadStringIndex, ReadGuidIndex and ReadBlobIndex determine the values of the
offset variables offsetstring, offsetguid and offsetblob, respectively; it is
done whenever indexes are to be read off the stream. If the value is set to 2,
the Int16 converter is used, however if it is 4, the converter of Int32 is
employed. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>All the earlier programs in this book had utilized small
program snippets. As a consequence, the values never exceeded 64 K. Therefore,
we had worked under the assumption that the value is 2 bytes.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>An index into a table may also be either 2 bytes or 4 bytes.
However, we have set the value to 2, assuming that the tablesizes, i.e. the
rows in the tables, shall never exceed 64K.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>public int GetTableSize()</p>

<p class=ILprg>{</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>return 2;</p>

<p class=ILprg>}</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The apposite approach here would be to ascertain if the rows
exceed 64K in the rows array; and based on the value, either 2 or 4 shall be
returned.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>As perceived in the earlier programs, before the function
ReadStreamsData terminates, the tables in the valid field are inspected, and
simultaneously, the number of rows that it contains is placed in the rows
array. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Once the rows size array is filled up, the size of every table
is checked to fill up the sizes array. The most imperative function here is the
GetCodedIndexSize function. Let us consider a specific case where the tablesize
of the typeref table is to be ascertained. The function of
GetCodedIndexSize(&quot;ResolutionScope&quot;) is called to establish whether
the size of the field is 2 bytes or 4 bytes.</p>

<p class=ILbase>Thus, the GetCodedIndexSize function gets called, and the 'if'
statement that checks for the ReolutionScope, returns True. Then, the following
statements get executed:</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILprg>if ( rows[0x00]&gt;= 8192 ||<span style='mso-tab-count:1'>          </span>rows[0x1a]
&gt;= 8192<span style='mso-tab-count:1'>       </span> ||<span
style='mso-tab-count:1'>        </span>rows[0x23] &gt;= 8192<span
style='mso-tab-count:1'>       </span> ||<span style='mso-tab-count:1'>        </span>rows[0x01]
&gt;= 8192<span style='mso-tab-count:1'>            </span>)</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>return 4;</p>

<p class=ILprg>else</p>

<p class=ILprg><span style='mso-tab-count:1'>            </span>return 2;</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>For those with an evasive memory, the resolutionscope is an
index into one of the 4 tables, i.e. Module, ModuleRef, AssemblyRef or TypeRef,
having the id of 0x00, 0x1a, 0x23 and 0x01, respectively. In one of the earlier
chapters, we had observed that if the three bits held the value of 0, it
referred to the module table. A value of 1 was for moduleref, 3 was for
assemblyref and 4 was for typeref. In the GetCodedIndexSize function, the rows
in these three tables are verified to establish if they exceed 8192, i.e. 2^13,
since the remaining 3 bits of 2 bytes are occupied by the table references. If
they do, the resolutionscope takes up 4 bytes, or else, it occupies 2 bytes. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>In brief, GetCodedIndexSize takes a string parameter, which is
the name of the coded index. It uses the rows array to determine if the rows
for the table exceed the 2 byte limit. This is accomplished by subtracting the
bits that have been utilized for the table. If this is the case, then 4 bytes
are used for accommodating the resolutionscope.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The sizes of these tables are never constant. If the rows
expand in size, then the number of bytes that are consumed to accommodate
these, also undergoes expansion. For the MemberRef table, out of the 3 fields,
the first one is the coded index, the second is an index to the string, while
the third one is an index into the Blob. In case of the table being small, the
fields can be assumed to have a size of 2 bytes each, thus resulting in a total
size of 6 bytes. However, this assumption is far from being technically
accurate. Thus, GetCodedIndexSize dynamically assigns the size for the coded
index field in the tables. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The computed sizes of these tables are stored in the sizes
array. Thus, to retrieve the size of the MemberRef table, you can merely use
size[0x0a].</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The tablepresent function computes the offset of every table
and stores it in the variable tableoffset. It returns a boolean value of True,
if the table is present in the metadata stream; however, in case of its
absence, it returns a value of False.<span style="mso-spacerun: yes">  </span></p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>This nugget of information is exploited in the next function
named ReadTablesIntoStructures. If the table exists, an array of structures is
created, which is large enough to store all the rows in the table. We have
appended an additional structure to the quantity in existence, since we would
be ignoring the 0th member in the array and shall be starting the array index
from 1. Every member in the structure is then filled up for the entire array.
This has been repeated for all the tables. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Once the structures are filled up, the function of
DisplayTableForDebugging() is called, which displays the information stored in
every table of the file.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>We have already explicated each one of the tables in great
detail earlier. The only divergence here is that, the cross references to
several tables are specified in values, along with other relevant information.
For example, the function of DisplayTypeDefTable generates a lot more
information, as compared to what we had encountered earlier. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The DisplayTable function called in this function, returns
intelligent information. It takes two parameters, viz. the tablename and the
index. Let us consider the case of class zzz, which is the second row in the
typedef table. The function DisplayTable is called with the table name of
TypeRef and with an index of 1. Since the table is TypeRef, the function
GetTypeRefTable is called with the index parameter.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>In GetTypeRefTable, the value in the name field is extracted
from the typeref structure, with the index variable comporting itself as the
row number. Moreover, the namespace is also retrieved. If the namespace is not
null, then a dot is specified after the namespace name. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Finally, using the GetString function, the actual name is
obtained, which is then specified as the return value. Thus, in place of
TypeRef[1], we see the value of System.Object.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>Apart from this, all the methods contained in the class are
also displayed, using the DisplayAllMethods function. This function is passed
the rowindex member named ii, as the parameter. The mindex member of the
structure provides the starting method index owned by the type. Thus, we have
stored it in the variable named 'start'. However, there is no technique of
ascertaining the last method owned by the type. Yet again, the ease of
understanding has been sacrificed at the altar of efficiency.</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>In order to obtain the last method, the next typedef member is
checked. The function pointed by this typedef, marks the new set of functions
owned by the next type. Thus, it can be safely concluded that all functions
preceding the new set, are owned by the current type. The difference between
startofnext and start belong to the current type. Then, by employing a 'for'
loop, all the methods falling within the range are displayed. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>A small glitch rears its head, if the type happens to be the
last type in the typedeftable. </p>

<p class=ILbase>In such a case, the startofnext variable is initialized to the
length of the methodstruct -1. So, when the index in the typedef table
corresponds to the last entry in the table, all methods from the start upto the
end of methods in the method table, are assigned to the type. Moreover, when
two types share the same start, it is assumed that the current typedef does not
enclose any methods in it. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>The same rules have been applied while displaying all fields,
events, parameters and properties.</p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><img width=518 height=417 id="_x0000_i1026" src="chap6\1.gif"></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=MsoNormal><img width=575 height=414 id="_x0000_i1027" src="chap6\2.gif"><img
width=575 height=411 id="_x0000_i1028" src="chap6\3.gif"></p>

<p class=MsoNormal><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>We have chosen to abstain from explicating any more code, since
a large quantum of it has already been elucidated in the preceding chapters in
diminutive bits and pieces. However, there are a few things that have been left
unfinished, such as complex types, which have not been attended to; and
signatures, which have not been decoded in their entirety. </p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

<p class=ILbase>We set aside these as an exercise for you, since these have
already been expounded in considerable detail in the earlier chapters. One can
synthesize all this knowledge and write a thesis on the subject with effortless
ease. However, we are going to save you this effort, since our next book shall
cater to all these requests with a re-production of Microsoft's IL disassembler
utility, using the C# language. It shall incorporate all the formatting issues
too. Au revoir!</p>

<p class=ILbase><![if !supportEmptyParas]>&nbsp;<![endif]><o:p></o:p></p>

</div>

</body>

</html>
