[TOC]

在C#中，类可以定义自己的事件，其他类可以注册它，以便在发生事件时得到通知。这对于桌面应用程序或独立的windows服务很有用。但是，对于web应用程序来说，这有点问题，因为对象是在web请求中创建的，并且它们的生命周期很短。很难注册某些类的事件。另外，直接注册到另一个类的事件会使类紧密耦合。

域事件可用于分离业务逻辑并对应用程序中的重要域更改作出反应。

## 事件总线(Event Bus)

EventBus是一个由所有其他类共享以触发和处理事件的单例对象。要使用事件总线，您应该获得对它的引用。你可以用两种方法。

### 注入 IEventBus

您可以使用依赖注入来获取对IEventBus的引用。这里，我们使用属性注入模式：

```
public class TaskAppService : ApplicationService
{
    public IEventBus EventBus { get; set; }

    public TaskAppService()
    {
        EventBus = NullEventBus.Instance;
    }
}
```

属性注入比构造函数注入更适合注入事件总线。因此，您的类可以在没有事件总线的情况下工作。NullEventBus实现空对象模式。当你调用它的方法时，它什么也不做。

### 获取默认实例

如果不能注射，可以直接使用事件总线(EventBus.Default)。默认. 它是全局事件总线，可以如下所示使用：

```
EventBus.Default.Trigger(...); //trigger an event
```
不建议直接使用事件总线。默认因为这会增加单元测试的难度。

## 定义事件(Defining Events)

在触发事件之前，应该先定义事件。事件由从EventData派生的类表示。假设要在任务完成时触发事件：

```
public class TaskCompletedEventData : EventData
{
    public int TaskId { get; set; }
}
```
此类包含处理事件的类所需的属性。EventData类定义EventSource（哪个对象触发了事件）和EventTime（当它被触发时）属性。

### 预定义事件(Predefined Events)

处理异常

ASP.NET Boilerplate 定义abpHandlexceptionData并在自动处理任何异常时触发此事件。如果您想获得关于异常的更多信息（甚至ASP.NET Boilerplate 会自动记录所有异常）。您可以注册此事件，以便在发生异常时得到通知。

实体改变

事件数据<TEntity>、实体更新事件数据<TEntity>、EntityUpdatedEventData<tenty>、EntityUpdatedEventData<tenty>、EntityDeletingEventData<tenty>和EntityDeletedEventData<tenty>。EventData<TEntity>和EntityChangedEventData<TEntity>。可以插入、更新或删除更改。

“ing”事件（例如：EntityUpdating）在保存更改之前触发。因此，您可以回滚工作单元，通过在这些事件中引发异常来防止操作ed'事件（例如：EntityUpdated）在保存更改并且没有机会回滚工作单元后触发。

实体更改事件在中定义Abp.Events.Bus.Entities命名空间，并由ASP.NET  Boilerplate插入、更新或删除实体时自动触发。若您有一个Person实体，可以注册到EntityCreatedEventData<Person>以便在创建新的人员并将其插入数据库时得到通知。这些事件还支持继承。如果Student类派生自Person类，并且您注册到EntityCreatedEventData<Person>，则在插入Person或Student时将通知您。

## 触发事件(Triggering Events)

触发一个简单事件:

```
public class TaskAppService : ApplicationService
{
    public IEventBus EventBus { get; set; }

    public TaskAppService()
    {
        EventBus = NullEventBus.Instance;
    }

    public void CompleteTask(CompleteTaskInput input)
    {
        //TODO: complete the task on database...
        EventBus.Trigger(new TaskCompletedEventData {TaskId = 42});
    }
}
```

触发器方法有一些重载：

```
EventBus.Trigger<TaskCompletedEventData>(new TaskCompletedEventData { TaskId = 42 }); //Explicitly declare generic argument
EventBus.Trigger(this, new TaskCompletedEventData { TaskId = 42 }); //Set 'event source' as 'this'
EventBus.Trigger(typeof(TaskCompletedEventData), this, new TaskCompletedEventData { TaskId = 42 }); //Call non-generic version (first argument is the type of the event class)
```
触发事件的另一种方法是使用AggregateRoot类的DomainEvents集合（请参阅实体文档中的相关部分）。

## 处理事件(Handling Events)

要处理事件，应实现IEventHandler<T>接口，如下所示：

```
public class ActivityWriter : IEventHandler<TaskCompletedEventData>, ITransientDependency
{
    public void HandleEvent(TaskCompletedEventData eventData)
    {
        WriteActivity("A task is completed by id = " + eventData.TaskId);
    }
}
```
IEventHandler定义了HandleEvent方法，我们实现了它，如上图所示。

EventBus集成到依赖注入系统中。当我们在上面实现ITransiteDependency时，当TaskCompleted事件发生时，它会创建ActivityWriter类的一个新实例，并调用它的HandleEvent方法，然后处理它。有关详细信息，请参见依赖注入。

### 处理基本事件

Eventbus支持事件继承。例如，可以创建TaskEventData和两个派生类：TaskCompletedEventData和TaskCreatedEventData：

```
public class TaskEventData : EventData
{
    public Task Task { get; set; }
}

public class TaskCreatedEventData : TaskEventData
{
    public User CreatorUser { get; set; }
}

public class TaskCompletedEventData : TaskEventData
{
    public User CompletorUser { get; set; }
}
```

然后可以实现IEventHandler<TaskEventData>来处理这两个事件：

```
public class ActivityWriter : IEventHandler<TaskEventData>, ITransientDependency
{
    public void HandleEvent(TaskEventData eventData)
    {
        if (eventData is TaskCreatedEventData)
        {
            //...
        }
        else if (eventData is TaskCompletedEventData)
        {
            //...
        }
    }
}
```
这也意味着您可以实现IEventHandler<EventData>来处理应用程序中的所有事件。你可能不想那样，但这是可能的。

### 处理异常(Handler Exceptions)

EventBus触发所有处理程序，甚至其中一个或某些处理程序抛出异常。如果其中只有一个抛出异常，则触发器方法直接抛出异常。如果有多个处理程序引发异常，EventBus将为所有这些处理程序抛出单个AggregateException。

### 处理多事件(Handling Multiple Events)

您可以在一个处理程序中处理多个事件。此时，您应该为每个事件实现IEventHandler<T>。例子：

```
public class ActivityWriter :
    IEventHandler<TaskCompletedEventData>,
    IEventHandler<TaskCreatedEventData>,
    ITransientDependency
{
    public void HandleEvent(TaskCompletedEventData eventData)
    {
        //TODO: handle the event...
    }

    public void HandleEvent(TaskCreatedEventData eventData)
    {
        //TODO: handle the event...
    }
}
```

## 注册处理器(Registration Of Handlers)

为了处理事件，我们必须将处理程序注册到事件总线。

### 自动型

ASP.NET Boilerplate查找实现IEventHandler并注册到依赖项注入的所有类（例如，通过像上面的示例一样实现ITransiteDependency）。然后它自动将它们注册到事件总线。当事件发生时，它使用依赖注入来获取对处理程序的引用，并在处理事件后释放处理程序。这是在中使用事件总线的建议方法ASP.NET Boilerplate。

### 手动型

也可以手动注册到事件，但要谨慎使用。在web应用程序中，事件注册应该在应用程序启动时完成。在web请求中注册事件不是一个好方法，因为注册的类在请求完成并为每个请求重新注册之后仍然保持注册状态。这可能会给应用程序带来问题，因为注册的类可以被多次调用。还要记住，手动注册不使用依赖注入系统。

事件总线的register方法有一些重载。最简单的方法是等待委托（或lambda）：

```
EventBus.Register<TaskCompletedEventData>(eventData =>
{
        WriteActivity("A task is completed by id = " + eventData.TaskId);
});
```

因此，将发生“任务已完成”事件，调用此lambda方法。第二个等待实现IEventHandler<T>的对象：

```
EventBus.Register<TaskCompletedEventData>(new ActivityWriter());
```

为事件调用相同的ActivityWriter实例。此方法还有一个非泛型重载。另一个重载接受两个泛型参数：

```
EventBus.Register<TaskCompletedEventData, ActivityWriter>();
```
此时，事件总线为每个事件创建一个新的ActivityWriter。它在召唤ActivityWriter.Dispose方法，如果它是一次性的。

最后，您可以注册一个事件处理程序工厂来处理处理程序的创建。处理程序工厂有两个方法：GetHandler和ReleaseHandler。例子：

```
public class ActivityWriterFactory : IEventHandlerFactory
{
    public IEventHandler GetHandler()
    {
        return new ActivityWriter();
    }

    public void ReleaseHandler(IEventHandler handler)
    {
        //TODO: release/dispose the activity writer instance (handler)
    }
}
```

还有一个特殊的工厂类，IocHandlerFactory，可以用来使用依赖注入系统来创建/释放处理程序。ASP.NET Boilerplate 在自动注册中也使用这个类。所以，如果你想使用依赖注入系统，直接使用之前定义的自动注册。

## 撤销(Unregistration)

当您手动注册到事件总线时，您可能希望稍后取消注册到事件。注销事件的最简单方法是释放Register方法的返回值。例子：

```
//Register to an event...
var registration = EventBus.Register<TaskCompletedEventData>(eventData => WriteActivity("A task is completed by id = " + eventData.TaskId) );

//Unregister from event
registration.Dispose();
```

当然，注销将在某处或某个时候出现。保留注册对象并在要注销时释放它。Register方法的所有重载都将返回一个要注销到事件的可释放对象。
EventBus还提供了注销方法。用法示例：

```
//Create a handler
var handler = new ActivityWriter();

//Register to the event
EventBus.Register<TaskCompletedEventData>(handler);

//Unregister from event
EventBus.Unregister<TaskCompletedEventData>(handler);
```
它还为取消注册委托和工厂提供重载。注销处理程序对象必须与之前注册的对象相同。
最后，EventBus提供了一个UnregisterAll<T>（）方法来注销事件的所有处理程序，UnregisterAll（）方法用于注销所有事件的所有处理程序。
