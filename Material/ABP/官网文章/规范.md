[TOC]

## 介绍

规范模式是一种特殊的软件设计模式，通过使用布尔逻辑（Wikipedia）将业务规则链接在一起，可以重新组合业务规则。

实际上，它主要用于为实体或其他业务对象定义可重用的过滤器。

### 例子

在本节中，我们将看到规范模式的需要。本节是通用的，与ABP的实现无关。

假设您有一个计算客户总数的服务方法，如下所示：

```
public class CustomerManager
{
    public int GetCustomerCount()
    {
        //TODO...
        return 0;
    }
}
```
您可能希望通过过滤器获取客户数量。例如，您可能有高级客户（余额超过100000美元），或者您可能希望仅按注册年份筛选客户。然后您可以创建其他方法，如GetPremiumCustomerCount（）、GetCustomerCountRegisteredInYear（int-year）、GetPremiumCustomerCountRegisteredInYear（int-year）等。因为你有更多的标准，不可能为每一种可能性创建一个组合。

这个问题的一个解决方案是规范模式。我们可以创建一个方法来获取一个参数作为过滤器：

```
public class CustomerManager
{
    private readonly IRepository<Customer> _customerRepository;

    public CustomerManager(IRepository<Customer> customerRepository)
    {
        _customerRepository = customerRepository;
    }

    public int GetCustomerCount(ISpecification<Customer> spec)
    {
        var customers = _customerRepository.GetAllList();

        var customerCount = 0;

        foreach (var customer in customers)
        {
            if (spec.IsSatisfiedBy(customer))
            {
                customerCount++;
            }
        }

        return customerCount;
    }
}
```

因此，我们可以得到任何一个对象作为实现ISpecification<Customer>接口的参数，定义如下：

```
public interface ISpecification<T>
{
    bool IsSatisfiedBy(T obj);
}
```
我们可以调用 IsSatisfiedBy 来判断这个客户是否有意。因此，我们可以对不同的过滤器使用相同的GetCustomerCount，而不必更改方法本身。

虽然这个解决方案在理论上很好，但是应该改进它以更好地在C#中工作。例如，让数据库中的所有客户检查他们是否满足给定的规范/条件是不有效的。在下一节中，我们将看到ABP的实现克服了这个问题。

## 创建规范类

ABP 定义一个规范接口如下：

```
public interface ISpecification<T>
{
    bool IsSatisfiedBy(T obj);

    Expression<Func<T, bool>> ToExpression();
}
```

添加一个ToExpression（）方法，该方法返回表达式并用于更好地与IQueryable和表达式树集成。因此，我们可以轻松地将规范传递给存储库，以便在数据库级别应用过滤器。

我们通常从Specification<T>类继承，而不是直接实现ISpecification<T>接口。规范类自动实现IsSatifiedBy方法。所以，我们只需要定义ToExpression。让我们创建一些规范类：

```
//Customers with $100,000+ balance are assumed as PREMIUM customers.
public class PremiumCustomerSpecification : Specification<Customer>
{
    public override Expression<Func<Customer, bool>> ToExpression()
    {
        return (customer) => (customer.Balance >= 100000);
    }
}

//A parametric specification example.
public class CustomerRegistrationYearSpecification : Specification<Customer>
{
    public int Year { get; }

    public CustomerRegistrationYearSpecification(int year)
    {
        Year = year;
    }

    public override Expression<Func<Customer, bool>> ToExpression()
    {
        return (customer) => (customer.CreationYear == Year);
    }
}
```

如您所见，我们只是实现了简单的lambda表达式来定义规范。让我们使用这些规范来计算客户数量：

```
count = customerManager.GetCustomerCount(new PremiumCustomerSpecification());
count = customerManager.GetCustomerCount(new CustomerRegistrationYearSpecification(2017));
```
## 仓储使用规范(Using Specification With Repository)

现在，我们可以优化CustomerManager以在数据库中应用筛选器：

```
public class CustomerManager
{
    private readonly IRepository<Customer> _customerRepository;

    public CustomerManager(IRepository<Customer> customerRepository)
    {
        _customerRepository = customerRepository;
    }

    public int GetCustomerCount(ISpecification<Customer> spec)
    {
        return _customerRepository.Count(spec.ToExpression());
    }
}
```
就这么简单。我们可以将任何规范传递给存储库，因为存储库可以将表达式用作过滤器。在本例中，CustomerManager是不必要的，因为我们可以直接使用带有规范的存储库来查询数据库。但是我们想对一些客户进行商业运作。在这种情况下，我们可以使用域服务的规范来指定要处理的客户。

## 编写规范(Composing Specifications)

规范的一个强大特性是它们可以与And、Or、Not和AndNot扩展方法组合。例子：

```
var count = customerManager.GetCustomerCount(new PremiumCustomerSpecification().And(new CustomerRegistrationYearSpecification(2017)));
```
我们甚至可以根据现有规范创建新的规范类：

```
public class NewPremiumCustomersSpecification : AndSpecification<Customer>
{
    public NewPremiumCustomersSpecification()
        : base(new PremiumCustomerSpecification(), new CustomerRegistrationYearSpecification(2017))
    {
    }
}
```
AndSpecification是Specification类的一个子类，它只满足两个规范。然后我们可以像其他任何规范一样使用NewPremiumCustomersSpecification：
```
var count = customerManager.GetCustomerCount(new NewPremiumCustomersSpecification());
```
## 讨论

虽然规范模式比C#lambda表达式旧，但它通常与表达式进行比较。一些开发人员可能认为不再需要它了，我们可以直接将表达式传递到存储库或域服务，如下所示：

```
var count = _customerRepository.Count(c => c.Balance > 100000 && c.CreationYear == 2017);
```
由于ABP的存储库支持经验，这是完全有效的用法。您不必在应用程序中定义或使用任何规范，您可以使用表达式。那么，规范的意义何在？我们为什么和何时应该考虑使用它们？

什么时候使用？

使用规范的一些好处：

* __Reusable__ : 认为您需要在代码库的许多地方预先筛选客户。如果使用表达式而不创建规范，那么如果以后更改“Premium Customer”的定义（例如，您希望将最低余额从100000美元更改为250000美元，并添加另一个条件，例如成为3岁以上的客户），会发生什么情况。如果使用规范，只需更改一个类。如果使用（复制/粘贴）相同的表达式，则需要更改所有表达式。
* __Composable__ : 可以组合多个规范来创建新规范。这是另一种可重用性。
* __Named__ : PremiumCustomerSpecification更好地解释了意图，而不是复杂的表达式。因此，如果您有一个在您的业务中有意义的表达式，请考虑使用规范。
* __Testable__ : 规范是可单独（且容易）测试的对象。

什么时候不要使用?

* __Non business expressions__ : 您可以考虑不将规范用于与业务无关的表达式和操作。
* __Reporting__ : 如果您只是创建一个报告，不要创建规范，而是直接使用IQueryable。实际上，您甚至可以使用纯SQL、视图或其他工具进行报告。DDD不太关心报告，从性能的角度来看，获取底层数据存储的查询好处非常重要。
