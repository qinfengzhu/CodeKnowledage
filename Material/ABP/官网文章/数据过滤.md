[TOC]

## 介绍

通常使用软删除模式，该模式用于不从数据库中删除实体，而只将其标记为“已删除”。因此，如果一个实体被软删除，它不应该被意外地检索到应用程序中。为此，我们将在每个选择实体的查询中添加一个SQL where条件，如“IsDeleted=false”。这是一个乏味但更重要的是一个容易忘记的任务。所以，应该有一个自动的方法。

ASP.NET Boilerplate  提供数据过滤器，这些过滤器可用于根据某些规则自动过滤查询。有一些预定义的过滤器，但也可以创建自己的过滤器。

## 预定义过滤(Pre-Defined Filters)

### ISoftDelete

软删除过滤器用于在查询数据库时自动过滤（从结果中提取）已删除的实体。如果一个实体应该被软删除，它必须实现只定义IsDeleted属性的ISoftDelete接口。例子：

```
public class Person : Entity, ISoftDelete
{
    public virtual string Name { get; set; }
    public virtual bool IsDeleted { get; set; }
}
```
Person实体实际上并没有从数据库中删除，而是在需要删除时将IsDeleted属性设置为true。当你使用IRepository中的Delete方法的时候，ASP.NET Boilerplate  自动完成该功能。删除方法（您可以手动将IsDeleted设置为true，但Delete方法更为自然和首选）

在实现ISOFTelete之后，当您从数据库中获取人员列表时，不会检索已删除的人员。下面是一个使用人员存储库获取所有人员的示例类：

```
public class MyService
{
    private readonly IRepository<Person> _personRepository;

    public MyService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public List<Person> GetPeople()
    {
        return _personRepository.GetAllList();
    }
}
```

GetPeople方法只获取IsDeleted=false（未删除）的Person实体。所有存储库方法和导航属性都能正常工作。我们可以添加一些其他的Where条件，连接。。它会自动将IsDeleted=false条件正确添加到生成的SQL查询中。

> 什么时候启用(When Enabled?)
除非明确禁用，否则始终启用ISOFTelete筛选器。

附带说明：如果您实现了IDeletionAudited（它扩展了isoftelete），那么删除时间和deleter用户id也会由自动由ASP.NE TBoilerplate 设置。

### IMustHaveTenant

如果您正在构建多租户应用程序，并将所有租户数据存储在单个数据库中，您绝对不希望租户意外地看到其他租户的数据。在这种情况下，你可以让承租人来实施。例子：

```
public class Product : Entity, IMustHaveTenant
{
    public int TenantId { get; set; }
    public string Name { get; set; }
}
```
IMustHaveTenant定义TenantId以区分不同的租户实体。ASP.NET Boilerplate 使用IAbpSession默认获取当前租户ID，并自动筛选当前租户的查询。

> 什么时候启用(When Enabled?)
除非显式禁用IMayHaveTenant，否则始终启用它。

## 禁用数据过滤(Disable Filters)

您可以通过调用DisableFilter方法禁用每个工作单元的筛选器，如下所示：

```
var people1 = _personRepository.GetAllList();

using (_unitOfWorkManager.Current.DisableFilter(AbpDataFilters.SoftDelete))
{
    var people2 = _personRepository.GetAllList();                
}
var people3 = _personRepository.GetAllList();
```
DisableFilter方法以字符串形式获取一个或多个筛选器名称。AbpDataFilters.SoftDelete是一个常量字符串，它包含的标准软删除筛选器的名称ASP.NET Boilerplate。

people2还将包括已删除的人，而people1和people3将只包含未删除的人。使用using语句，可以禁用作用域中的筛选器。如果不使用using stamement，过滤器将被禁用，直到当前工作单元结束或您再次显式启用它。

您可以注入IUnitOfWorkManager并在示例中使用。如果你也可以使用一些特殊的类，比如应用程序控件，或者其他的类。

> 关于Using Statement
如果在使用using语句调用DisableFilter方法时启用了筛选器，则该筛选器将被禁用，然后在using语句之后自动重新启用。但是，如果过滤器在using语句之前已经被禁用，那么DisableFilter实际上什么也不做，并且过滤器即使在using语句之后仍然保持禁用状态。

> 关于多租户
您可以禁用租赁筛选器来查询所有租户数据。但请记住，这只适用于单数据库方法。如果每个租户都有独立的数据库，则禁用筛选器无助于查询所有租户的所有数据，因为它们位于不同的数据库中，甚至可以位于不同的服务器中。有关详细信息，请参阅多租户文档。

### 禁用全局过滤(Disable Filters Globally)

如果需要，可以全局禁用预定义的过滤器。例如，要全局禁用软删除筛选器，请将以下代码添加到模块的PreInitialize方法：

```
Configuration.UnitOfWork.OverrideFilter(AbpDataFilters.SoftDelete, false);
```

## 启用过滤(Enable Filters)

您可以使用EnableFilter方法在工作单元中启用筛选器，这与DisableFilter类似（相反）。EnableFilter还返回要在using语句中使用的disposable，以便在需要时自动重新禁用筛选器。

## 设置过滤参数(Setting Filter Parameters)

过滤器可以是参数化的。IMustHaveTenant filter就是这类过滤器的一个例子，因为当前租户的Id是在运行时确定的。对于这样的过滤器，我们可以根据需要改变过滤器的值。例子：

```
CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42);
```
另一个示例：要设置IMayHaveTenant筛选器的tenantId值，请执行以下操作：

```
CurrentUnitOfWork.SetFilterParameter(AbpDataFilters.MayHaveTenant, AbpDataFilters.Parameters.TenantId, 42);
```
SetFilterParameter方法还返回IDisposable。因此，我们可以在using语句中使用它来自动恢复using语句后的旧值。

### 设置租户Id 方法(SetTenantId Method)

虽然您可以使用SetFilterParameter方法更改MayHaveTenant和MustHaveTenant筛选器的筛选器值，但有一种更好的方法来更改租户筛选器：setnantId（）。SettentId更改两个过滤器的参数值，也适用于单个数据库和每个租户的数据库方法。因此，我们总是建议使用setnantId来更改租赁过滤器参数值。有关详细信息，请参阅多租户文档。

## ORM 集成 (ORM Integrations)

预定义过滤器的数据过滤适用于NHibernate、entityframework6.x和entityframeworkcore。目前，您只能为EntityFramework6.x定义自定义筛选器。

### Entity EntityFramework

对于实体框架集成，使用EntityFramework.DynamicFilters 类库

为实体框架创建自定义筛选器并集成到ASP.NET Boilerplate，首先我们应该定义一个接口，这个接口将由使用这个过滤器的实体实现。假设我们想通过PersonId自动过滤实体。示例接口：

```
public interface IHasPerson
{
    int PersonId { get; set; }
}
```
然后我们可以为需要的实体实现这个接口。示例实体：
```
public class Phone : Entity, IHasPerson
{
    [ForeignKey("PersonId")]
    public virtual Person Person { get; set; }
    public virtual int PersonId { get; set; }
    public virtual string Number { get; set; }
}
```

我们用它的规则来定义过滤器。在DbContext类中，我们重写OnModelCreating并定义filter，如下所示：

```
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);

    modelBuilder.Filter("PersonFilter", (IHasPerson entity, int personId) => entity.PersonId == personId, 0);
}
```

“PersonFilter”是此处过滤器的唯一名称。第二个参数定义过滤器接口和personId过滤器参数（如果filter不是参数化的，则不需要），最后一个参数是personId的默认值。

最后，我们必须将此筛选器注册到ABP 我们模块预初始化方法中样板的工作单元系统：

```
Configuration.UnitOfWork.RegisterFilter("PersonFilter", false);
```
第一个参数和我们之前定义的唯一名称相同。第二个参数指示默认情况下启用还是禁用此筛选器。在声明了这样一个参数化过滤器之后，我们可以通过在运行时提供它的值来使用它。
```
using (CurrentUnitOfWork.EnableFilter("PersonFilter"))
{
    using(CurrentUnitOfWork.SetFilterParameter("PersonFilter", "personId", 42))
    {
        var phones = _phoneRepository.GetAllList();
        //...
    }
}
```
我们可以从某个来源得到拟人，而不是静态编码。上面的例子是参数化过滤器。过滤器可以有零个或多个参数。如果没有参数，则不需要设置过滤器参数值。另外，如果默认启用了它，就不需要手动启用它（当然，我们可以禁用它）。

> EntityFramework.DynamicFilters 文档
有关动态数据过滤器的更多信息，请参阅github页面上的[文档]( https://github.com/jcachat/EntityFramework.DynamicFilters)

我们可以为安全性、主动/被动实体等创建自定义过滤器。
