[TOC]

## 介绍

连接和事务管理是使用数据库的应用程序中最重要的概念之一。何时打开连接、何时启动事务、如何处置连接等等。。ASP.NET Boilerplate通过其工作单元系统管理数据库连接和事务。

## 连接&事务管理 (Connection & Transaction Management in Asp.net Boilerplate)

打开一个数据库连接（它可能不会立即打开，但在第一次使用数据库时打开，基于ORM提供程序实现），并在输入工作单元方法时开始事务。因此，您可以在这种方法中安全地使用连接。在方法的末尾，提交事务并释放连接。如果该方法抛出任何异常，则回滚事务并释放连接。这样，工作单元方法就是原子的（工作单元）。ASP.NET Boilerplate 自动完成所有这些。

若一个工作单元方法调用另一个工作单元方法，则两者都使用相同的连接和事务。第一个输入方法管理连接和事务，其他人使用它。

### 常规的工作单元方法

一些方法默认情况下为工作单元方法：
* 所有的 MVC ,Web API ,Asp.net Core Mvc 控制器的方法
* 所有的 应用服务方法
* 所有的 仓储方法

假设我们有一个应用服务方法如下：

```
public class PersonAppService : IPersonAppService
{
    private readonly IPersonRepository _personRepository;
    private readonly IStatisticsRepository _statisticsRepository;

    public PersonAppService(IPersonRepository personRepository, IStatisticsRepository statisticsRepository)
    {
        _personRepository = personRepository;
        _statisticsRepository = statisticsRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        _personRepository.Insert(person);
        _statisticsRepository.IncrementPeopleCount();
    }
}
```
在CreatePerson方法中，我们使用person存储库插入一个人，并使用statistics repository增加总人数。在本例中，两个存储库共享相同的连接和事务，因为默认情况下，应用程序服务方法是工作单元。ASP.NET Boilerplate 在进入CreatePerson方法时打开一个数据库连接并启动一个事务，如果没有抛出异常，则在方法末尾提交事务，如果发生异常，则回滚。这样，CreatePerson方法中的所有数据库操作都成为原子（工作单元）。

除了默认的常规工作单位类外，您还可以在模块的PreInitialize方法中添加自己的约定，如下所示：

```
Configuration.UnitOfWork.ConventionalUowSelectors.Add(type => ...);
```
如果这个类型应该是工作类的常规单位，则应该检查类型并返回true。

### 控制工作单元

工作单元隐式地为上面定义的方法工作。在大多数情况下，您不必手动控制web应用程序的工作单元。如果您想在其他地方控制工作单元，可以显式地使用它。有两种方法。

UnitOfWork 标记属性
第一种也是首选的方法是使用UnitOfWork属性。例子：

```
[UnitOfWork]
public void CreatePerson(CreatePersonInput input)
{
    var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
    _personRepository.Insert(person);
    _statisticsRepository.IncrementPeopleCount();
}
```
因此，CreatePerson方法成为工作单元并管理数据库连接和事务，两个存储库使用相同的工作单元。请注意，如果这是应用程序服务方法，则不需要UnitOfWork属性。另请参阅“工作单元方法限制”部分。

UnitOfWork属性有一些选项。参见“详细工作单元”部分。UnitOfWork属性也可以用于类来配置类的所有方法。方法属性重写类属性（如果存在）。

IUnitOfWorkManager

第二种方法是使用工作经理。开始（…）方法如下：

```
public class MyService
{
    private readonly IUnitOfWorkManager _unitOfWorkManager;
    private readonly IPersonRepository _personRepository;
    private readonly IStatisticsRepository _statisticsRepository;

    public MyService(IUnitOfWorkManager unitOfWorkManager, IPersonRepository personRepository, IStatisticsRepository statisticsRepository)
    {
        _unitOfWorkManager = unitOfWorkManager;
        _personRepository = personRepository;
        _statisticsRepository = statisticsRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {
        var person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };

        using (var unitOfWork = _unitOfWorkManager.Begin())
        {
            _personRepository.Insert(person);
            _statisticsRepository.IncrementPeopleCount();

            unitOfWork.Complete();
        }
    }
}
```

您可以注入并使用IUnitOfWorkManager，如下所示（一些基类已经默认注入了UnitOfWorkManager：MVC控制器、应用程序服务、域服务…）。这样你就可以创作出更多的作品。在这种方法中，您应该手动调用Complete方法。若不调用，事务将回滚，更改不会保存。

Begin方法具有用于设置工作单元选项的重载。如果没有充分的理由，那么使用UnitOfWork属性会更好、更短。

## 工作单元的细节

### 不启用工作单元（Disabling Unit Of Work）

您可能希望禁用常规工作单元方法的工作单元。为此，请使用UnitOfWorkAttribute的IsDisabled属性。用法示例：

```
[UnitOfWork(IsDisabled = true)]
public virtual void RemoveFriendship(RemoveFriendshipInput input)
{
    _friendshipRepository.Delete(input.Id);
}
```
通常，您不希望这样做，但在某些情况下，您可能希望禁用工作单元：
* 您可能希望在上面描述的UnitOfWorkScope类中使用有限范围内的工作单元

请注意，如果工作单元方法调用此RemoveFriendly方法，则会忽略禁用此方法，并使用与调用方方法相同的工作单元。所以，小心使用禁用。另外，由于存储库方法在默认情况下是工作单元，所以上面的代码运行良好。

### 无实物的工作单元

工作单元是事务性的（按其本质）。因此，ASP.NET Boilerplate 启动/提交/回滚显式数据库级事务。在某些特殊情况下，事务可能会导致问题，因为它可能会锁定数据库中的某些行或表。在这种情况下，您可能需要禁用数据库级事务。UnitOfWork属性可以在其构造函数中获取一个布尔值，以作为非事务处理。用法示例：

```
[UnitOfWork(isTransactional: false)]
public GetTasksOutput GetTasks(GetTasksInput input)
{
    var tasks = _taskRepository.GetAllWithPeople(input.AssignedPersonId, input.State);
    return new GetTasksOutput
            {
                Tasks = Mapper.Map<List<TaskDto>>(tasks)
            };
}
```
建议将此属性用作[UnitOfWork（isTransactional:false）]。我认为它更具可读性和明确性。但可以用作[UnitOfWork（false）]。

注意，ORM框架（如NHibernate和EntityFramework）在内部用一个命令保存更改。假设您更新了非事务性UOW中的几个实体。即使在这种情况下，所有更新都是在工作单元结束时使用单个数据库命令执行的。但是，如果直接执行SQL查询，它会立即执行，如果UOW不是事务性的，则不会回滚。

对非事务性UOWs有限制。如果您已经在事务性工作单元范围内，则将忽略将isTransaction设置为false（使用事务范围选项在事务性工作单元中创建非事务性工作单元）。

谨慎使用非事务性工作单元，因为大多数时候它应该是事务性的，以保证数据的完整性。如果您的方法只是读取数据，而不是更改数据，那么它可以是安全的非事务性的。

### 一个工作单元方法调用另外一个

工作单位是环境的。若一个工作单元方法调用另一个工作单元方法，它们共享相同的连接和事务。第一种方法管理连接，其他方法使用它。

### 工作单元范围

您可以在另一个事务中创建不同的独立事务，也可以在事务中创建非事务范围。NET为此定义TransactionScopeOption。您可以设置工作单元的范围选项来控制它。

### 自动保存更改

如果方法是工作单元，ASP.NET Boilerplate 在方法结束时自动保存所有更改。假设我们需要更新人名的方法：
```
[UnitOfWork]
public void UpdateName(UpdateNameInput input)
{
    var person = _personRepository.Get(input.PersonId);
    person.Name = input.NewName;
}
```
就这样，名字改了！我们甚至没调用 personRepository 的更新方法。O/RM框架跟踪工作单元中实体的所有更改，并反映对数据库的更改。

注意，对于传统的工作单元方法，不需要声明UnitOfWork。

### IRepository.GetAll() Method

当您从存储库方法调用GetAll（）时，必须有一个打开的数据库连接，因为它返回IQueryable。这是必需的，因为IQueryable的延迟执行。除非调用ToList（）方法或在foreach循环中使用IQueryable（或以某种方式访问查询的项），否则它不会执行数据库查询。所以，当您调用ToList（）方法时，数据库连接必须是活动的。

考虑下面的例子：

```
[UnitOfWork]
public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
{
    //Get IQueryable<Person>
    var query = _personRepository.GetAll();

    //Add some filters if selected
    if (!string.IsNullOrEmpty(input.SearchedName))
    {
        query = query.Where(person => person.Name.StartsWith(input.SearchedName));
    }

    if (input.IsActive.HasValue)
    {
        query = query.Where(person => person.IsActive == input.IsActive.Value);
    }

    //Get paged result list
    var people = query.Skip(input.SkipCount).Take(input.MaxResultCount).ToList();

    return new SearchPeopleOutput { People = Mapper.Map<List<PersonDto>>(people) };
}
```
在这里，SearchPeople方法必须是工作单元，因为在方法体中调用了IQueryable的ToList（）方法，并且数据库连接必须在IQueryable.ToList()已执行。

在大多数情况下，您将在web应用程序中安全地使用GetAll方法，因为默认情况下所有控制器操作都是工作单元，因此数据库连接在整个请求中都是可用的。

### UnitWork 属性限制

你可以使用 UnitOfWork 属性如下：

* 在接口上使用的类的所有公共或公共虚拟方法（如在服务接口上使用的应用程序服务）。
* 自注入类的所有公共虚拟方法（如MVC控制器和webapi控制器）。
* 所有受保护的虚拟方法。

建议始终使方法虚拟化。不能将其用于私有方法。因为，ASP.NETBoilerplate为此使用了动态代理，派生类看不到私有方法。如果不使用依赖注入并自己实例化类，UnitOfWork属性（以及任何代理）都不起作用。

### 选项

有一些选项可以用来改变工作单元的行为。
首先，我们可以在启动配置中更改所有工作单元的默认值。这通常是在我们模块的PreInitialize方法中完成的。

```
public class SimpleTaskSystemCoreModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.UnitOfWork.IsolationLevel = IsolationLevel.ReadCommitted;
        Configuration.UnitOfWork.Timeout = TimeSpan.FromMinutes(30);
    }

    //...other module methods
}
```
其次，我们可以覆盖特定工作单元的默认值。为此，UnitOfWork属性构造函数和工作经理。开始方法具有获取选项的重载。

最后，您可以使用启动配置来配置ASP.NETMVC、Web API和ASP.NET核心MVC控制器（见他们的文档）。

## 方法

UnitOfWork系统无缝、无形地工作。但是，在某些特殊情况下，你需要调用它的方法。
您可以通过以下两种方式之一访问当前工作单元：

* 如果您的类是从某些特定的基类（ApplicationService、DomainService、AbpController、AbpApiController。。。等等）
* 您可以将IUnitOfWorkManager注入任何类并使用IUnitOfWorkManager。

### 保存改变

ASP.NET Boilerplate保存在一个工作单元结束时的所有更改，您不必做任何事情。但是，有时，您可能希望在工作单元操作过程中保存对数据库的更改。一个示例用法可能是保存更改以获取EntityFramework中新插入实体的Id。

您可以使用当前工作单元的SaveChanges或SaveChangesAsync方法。

请注意：如果当前工作单元是事务性的，则当发生异常时，事务中的所有更改都将回滚，即使保存的更改也是如此。

## 事件

工作单元已完成、失败并已处理事件。您可以注册这些事件并执行所需的操作。例如，当当前工作单元成功完成时，您可能希望运行一些代码。例子：

```
public void CreateTask(CreateTaskInput input)
{
    var task = new Task { Description = input.Description };

    if (input.AssignedPersonId.HasValue)
    {
        task.AssignedPersonId = input.AssignedPersonId.Value;
        _unitOfWorkManager.Current.Completed += (sender, args) => { /* TODO: Send email to assigned person */ };
    }

    _taskRepository.Insert(task);
}
```
