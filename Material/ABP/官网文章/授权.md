[TOC]

## 介绍

几乎所有的企业应用程序都在某种程度上使用授权。授权用于检查是否允许用户在应用程序中执行某些特定操作。ASP.NET Boilerplate 文件定义了一个基于权限的基础设施来实现授权。

> 关于 IPermissionChecker
授权系统使用IPermissionChecker检查权限。虽然您可以用自己的方式实现它，但它在modulezero项目中完全实现了。如果checker没有实现所有权限，那么checker将授予所有权限。

## 定义权限(Defining Permissions)

为每个需要授权的操作定义了唯一权限。我们应该在使用它之前定义一个权限。ASP.NET Boilerplate 设计成模块化。因此，不同的模块可以有不同的权限。模块应创建从AuthorizationProvider派生的类，以便定义其权限。授权提供程序示例如下所示：

```
public class MyAuthorizationProvider : AuthorizationProvider
{
    public override void SetPermissions(IPermissionDefinitionContext context)
    {
        var administration = context.CreatePermission("Administration");

        var userManagement = administration.CreateChildPermission("Administration.UserManagement");
        userManagement.CreateChildPermission("Administration.UserManagement.CreateUser");

        var roleManagement = administration.CreateChildPermission("Administration.RoleManagement");
    }
}
```

__IPermissionDefinitionContext__ :  包含创建权限 以及 获取权限 。

权限有一些属性可以定义它：

* __Name__ : 系统范围内的唯一名称。最好为权限名定义一个常量字符串，而不是一个魔法字符串。我们更喜欢使用。（dot）等级名称的符号，但不是必需的。你可以设置任何你喜欢的名字。唯一的规则是它必须是唯一的。
* __Display Name__ : 一个可本地化的字符串，可用于在稍后的UI中显示权限。
* __Description__ : 一个可本地化的字符串，可用于在稍后的UI中显示权限的定义。
* __MultiTenancySides__ : 对于多租户应用程序，权限可以由租户或主机使用。这是一个Flags枚举，因此可以在两边都使用权限。
* __FeatureDependency__ : 可用于声明对功能的依赖关系。因此，只有在满足特性依赖性时才能授予此权限。它等待对象实现IFeatureDependency。默认实现是SimpleFeatureDependency类。示例用法：new SimpleFeatureDependency（“MyFeatureName”）

权限可以有父权限和子权限。虽然这不会影响权限检查，但可能有助于在UI中对权限进行分组。

在创建了一个授权提供者之后，我们需要在模块的PreInitialize方法中注册它：

```
Configuration.Authorization.Providers.Add<MyAuthorizationProvider>();
```

授权提供者会自动注册到依赖注入。因此，授权提供程序可以注入任何依赖项（如存储库）以使用其他源构建权限定义。

## 验证权限(Checking Permissions)

使用 AbpAuthorize 属性标记

AbpAuthorize（用于MVC控制器的AbpMvcAuthorize和用于Web API控制器的AbpApiAuthorize）属性是检查权限的最简单和最常用的方法。考虑如下所示的应用程序服务方法：

```
[AbpAuthorize("Administration.UserManagement.CreateUser")]
public void CreateUser(CreateUserInput input)
{
    //A user can not execute this method if he is not granted for "Administration.UserManagement.CreateUser" permission.
}
```
未被授予权限的用户无法调用CreateUser方法“Administration.UserManagement.CreateUser".

AbpAuthorize属性还检查当前用户是否已登录（使用IAbpSession.UserId). 因此，如果我们为一个方法声明AbpAuthorize，它只检查登录：

```
[AbpAuthorize]
public void SomeMethod(SomeMethodInput input)
{
    //A user can not execute this method if he did not login.
}
```

ASP.NET Boilerplate 使用动态方法拦截的能力进行授权。因此，对于使用AbpAuthorize属性的方法有一些限制。

* 不能用在私有方法(private methods)
* 不能使用在静态方法(static methods)
* 不用使用在没有注入到容器中类的任何方法上

另外

* 如果方法是通过接口调用的（如在接口上使用的应用程序服务），则可以将其用于任何公共方法。
* 如果直接从类引用调用方法（比如ASP.NETMVC或Web API控制器）。
* 如果方法受保护，则它应该是虚拟的。

下面有一些授权的标注：

* 在应用程序服务（应用程序层）中，我们使用Abp.Authorization.Abp授权属性。
* 在MVC控制器（web层）中，我们使用Abp.Web.Mvc.Authorization.AbpMvcAuthorize 属性。
* 在ASP.NET Web API，我们使用Abp.WebApi.Authorization.AbpApiAuthorize 属性。
* 在ASP.NET Core，我们使用Abp.AspNetCore.Mvc.Authorization.AbpMvcAuthorize 属性。

这种差异来自于遗传。在应用层ASP.NET Boilerplate 不扩展任何类。但是，在MVC和webapi中，它继承了这些框架的Authorize属性。

取消授权

通过向应用程序服务添加AbpAllowAnonymous属性，可以禁用方法/类的授权。对MVC、Web API和ASP.NET核心控制器，它们是这些框架的本机属性。

### 使用 IPermissionChecker

虽然AbpAuthorize属性对于大多数情况来说已经足够了，但是在某些情况下我们应该检查方法体中的权限。我们可以为其注入并使用IPermissionChecker，如下例所示：

```
public void CreateUser(CreateOrUpdateUserInput input)
{
    if (!PermissionChecker.IsGranted("Administration.UserManagement.CreateUser"))
    {
        throw new AbpAuthorizationException("You are not authorized to create user!");
    }

    //A user can not reach this point if he is not granted for "Administration.UserManagement.CreateUser" permission.
}
```
当然，您可以编写任何逻辑，因为IsGranted只返回true或false（它还有异步版本）。如果您只需检查权限并抛出如上所示的异常，则可以使用Authorize方法：

```
public void CreateUser(CreateOrUpdateUserInput input)
{
    PermissionChecker.Authorize("Administration.UserManagement.CreateUser");

    //A user can not reach this point if he is not granted for "Administration.UserManagement.CreateUser" permission.
}
```

由于授权被广泛使用，ApplicationService和一些公共基类注入并定义PermissionChecker属性。因此，无需在应用程序服务类中注入，就可以使用权限检查器。

### 在Razor视图中 (In Razor Views)

基视图类定义IsGranted方法来检查当前用户是否具有权限。因此，我们可以有条件地渲染视图。例子：

```
@if (IsGranted("Administration.UserManagement.CreateUser"))
{
    <button id="CreateNewUserButton" class="btn btn-primary"><i class="fa fa-plus"></i> @L("CreateNewUser")</button>
}
```

### 客户端(javacript)

在客户端，我们可以使用 abp.auth 命名空间。在大多数情况下，我们需要检查当前用户是否具有特定的权限（使用权限名称）。例子：

```
abp.auth.isGranted('Administration.UserManagement.CreateUser');
```
你也可以使用abp.auth.granted权限获取所有授予的权限或abp.auth.all权限获取应用程序中所有可用的权限名称。检查总部授权其他人在运行时的命名空间。

##  权限管理(Permission Manger)

我们可能需要定义权限。IPermissionManager可以被注入并在这种情况下使用。
