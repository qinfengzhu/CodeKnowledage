[TOC]

## 介绍

维基百科：“审计跟踪（也称为审计日志）是一种与安全相关的时间顺序记录、一组记录和/或记录的目的地和来源，这些记录提供了在任何时候影响了特定操作、程序或事件的活动顺序的文件证据”。

ASP.NET Boilerplate 提供了一个基础设施来自动记录与应用程序的所有交互。它可以用调用方信息和参数记录预期的方法调用。

基本上，保存的字段有：相关租户id、调用方用户id、被调用服务名称（被调用方法的类）、被调用方法名称、执行参数（序列化为JSON）、执行时间、执行持续时间（以毫秒计）、客户端IP地址、客户端计算机名称和异常（如果方法抛出异常）。

通过这些信息，我们不仅可以知道谁做了操作，还可以测量应用程序的性能并观察抛出的异常。更重要的是，您可以获得有关应用程序使用情况的统计信息。

审核系统使用IAbpSession获取当前用户ID和TenantId。

应用程序服务、MVC控制器、Web API和ASP.NET默认情况下，核心方法是自动审核的。

> 关于 IAuditingStore
审计系统使用iaauditingstore保存审计信息。虽然您可以用自己的方式实现它，但它在modulezero项目中完全实现了。如果不实现，则使用SimpleLogAuditingStore并将审核信息写入日志。

## 配置(Configuration)

要配置审核，可以使用配置。审核属性。默认情况下启用审核。您可以禁用它，如下所示。

```
public class MyModule : AbpModule
{
    public override void PreInitialize()
    {
        Configuration.Auditing.IsEnabled = false;
    }

    //...
}
```
下面是审核配置属性的列表：

* __IsEnabled__ : 用于完全启用/禁用审核系统。默认值：true。
* __IsEnabledForAnonymousUsers__ : 如果设置为true，则还将为未登录到系统的用户保存审核日志。默认值：false。
* __Selectors__ : 用于选择其他类以保存审核日志。

选择器(Selectors)是一个谓词列表，用于选择其他类型以保存审核日志。选择器具有唯一的名称和判断(predicate)。此列表中唯一的默认选择器用于选择应用程序服务类。定义如下：

```
Configuration.Auditing.Selectors.Add(
    new NamedTypeSelector(
        "Abp.ApplicationServices",
        type => typeof (IApplicationService).IsAssignableFrom(type)
    )
);
```
您可以在模块的PreInitialize方法中添加选择器。另外，如果不想保存应用程序服务的审核日志，可以按名称删除上面的选择器。这就是为什么它有一个唯一的名称（使用简单的LINQ在选择器中找到选择器，并根据需要删除它）。

注：除了标准审计配置，MVC和ASP.NET核心模块定义配置以启用/禁用操作的审核日志记录。

## 启用/不启用 通过属性标记(Enable/Disable by attributes)

虽然可以按配置选择审核类，但可以对单个类（单个方法）使用Audited和DisableAuditing属性。例如：

```
[Audited]
public class MyClass
{
    public void MyMethod1(int a)
    {
        //...
    }

    [DisableAuditing]
    public void MyMethod2(string b)
    {
        //...
    }

    public void MyMethod3(int a, int b)
    {
        //...
    }
}
```
除了MyMethod2之外，所有MyClass方法都被审计，因为它被显式禁用。Audited属性可用于只保存所需方法的审核的方法。
DisableAuditing也可用于DTO或DTO的单个属性。因此，您可以在审核日志中隐藏敏感数据，例如密码。

## 注意

* 方法必须是公共的才能保存审核日志。私有和受保护的方法被忽略。
* 如果方法是通过类引用调用的，则它必须是虚的。如果是使用接口注入的，则不需要这样做（比如注入IPersonService接口来使用PersonService类）。这是需要的，因为ASP.NET Boilerplate 使用动态代理和拦截。对于MVC控制器操作，这是不正确的。它们可能不是虚拟的。
