[TOC]

“使用类似集合的接口在域和数据映射层之间进行中介，以访问域对象”（martinfowler）。

实际上，存储库用于对域对象（实体和值类型）执行数据库操作。通常，每个实体（或聚合根）使用一个独立的存储库。

## 默认仓储(Default Repositories)

在ASP.NET Boilerplate 一个存储库类实现IRepository<TEntity，TPrimaryKey>接口。ABP可以为每个实体类型自动创建默认存储库。您可以直接注入IRepository<TEntity>（或IRepository<TEntity，TPrimaryKey>）。示例应用程序服务使用存储库将实体插入数据库：

```
public class PersonAppService : IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public void CreatePerson(CreatePersonInput input)
    {        
        person = new Person { Name = input.Name, EmailAddress = input.EmailAddress };
        _personRepository.Insert(person);
    }
}
```
PersonapService构造函数注入IRepository<Person>并使用Insert方法。

## 自定义仓储(Custom Repositories)

只有在需要为实体创建自定义存储库方法时，才能为该实体创建存储库类。

### 自定义仓储接口(Custom Repository Inderface)

个人实体的存储库定义如下所示：

```
public interface IPersonRepository : IRepository<Person>
{
}
```

IPersonRepository扩展了IRepository<TEntity>。它用于定义主键类型为int（Int32）的实体。如果实体的主键不是int，可以扩展IRepository<TEntity，TPrimaryKey>接口，如下所示：

```
public interface IPersonRepository : IRepository<Person, long>
{
}
```

### 自定义仓储实现(Custom Repository Implementation)

ASP.NET Boilerplate 被设计成独立于特定的ORM（对象/关系映射）框架或其他访问数据库的技术。存储库以开箱即用的方式在NHibernate和EntityFramework中实现。请参阅要在中实现存储库的文档ASP.NET Boilerplate 中的这些框架：

* [NHibernate集成](NHibernate集成.md)
* [EntityFramework集成](EntityFramework集成.md)

## 仓储的基本方法(Base Repository Methods)

每个存储库都有一些来自IRepository<TEntity>接口的常用方法。我们将在这里调查其中的大部分。

### 查询(Querying)

获取单个实体

```
TEntity Get(TPrimaryKey id);
Task<TEntity> GetAsync(TPrimaryKey id);
TEntity Single(Expression<Func<TEntity, bool>> predicate);
Task<TEntity> SingleAsync(Expression<Func<TEntity, bool>> predicate);
TEntity FirstOrDefault(TPrimaryKey id);
Task<TEntity> FirstOrDefaultAsync(TPrimaryKey id);
TEntity FirstOrDefault(Expression<Func<TEntity, bool>> predicate);
Task<TEntity> FirstOrDefaultAsync(Expression<Func<TEntity, bool>> predicate);
TEntity Load(TPrimaryKey id);
```
Get方法用于获取具有给定主键（Id）的实体。如果数据库中没有具有给定Id的实体，则会引发异常。单个方法类似于Get，但使用表达式而不是Id。因此，您可以编写lambda表达式来获取实体。示例用法：

```
var person = _personRepository.Get(42);
var person = _personRepository.Single(p => p.Name == "John");
```
请注意，如果没有具有给定条件的实体或存在多个实体，则单个方法将引发异常。
FirstOrDefault类似，但如果没有给定Id或表达式的实体，则返回null（而不是引发异常）。如果给定条件下有多个实体，则返回第一个找到的实体。

Load不会从数据库中检索实体，但会为延迟加载创建一个代理对象。如果只使用Id属性，则不会实际检索实体。只有当您访问实体的其他属性时，才会从数据库中检索它。出于性能原因，可以使用它代替Get。它在NHibernate实施。若ORM提供程序并没有实现它，则Load方法的工作方式和Get方法相同。

获取实体集合
```
List<TEntity> GetAllList();
Task<List<TEntity>> GetAllListAsync();
List<TEntity> GetAllList(Expression<Func<TEntity, bool>> predicate);
Task<List<TEntity>> GetAllListAsync(Expression<Func<TEntity, bool>> predicate);
IQueryable<TEntity> GetAll();
```
GetAllList用于从数据库中检索所有实体。它的重载可用于筛选实体。示例：

```
var allPeople = _personRepository.GetAllList();
var somePeople = _personRepository.GetAllList(person => person.IsActive && person.Age > 42);
```

GetAll返回IQueryable<T>。因此，您可以在它之后添加Linq方法。示例：

```
//Example 1
var query = from person in _personRepository.GetAll()
            where person.IsActive
            orderby person.Name
            select person;
var people = query.ToList();

//Example 2:
List<Person> personList2 = _personRepository.GetAll().Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).Skip(40).Take(20).ToList();
```

使用GetAll，几乎所有查询都可以用Linq编写。甚至可以在连接表达式中使用。

>  关于IQueryable<T>
从存储库方法调用GetAll（）时，必须有一个打开的数据库连接。这是因为延迟执行IQueryable<T>。除非调用ToList（）方法或在foreach循环中使用IQueryable<T>（或以某种方式访问查询的项），否则它不会执行数据库查询。所以，当您调用ToList（）方法时，数据库连接必须是活动的。对于web应用程序，在大多数情况下，您并不关心这一点，因为MVC控制器方法在默认情况下是工作单元，并且数据库连接可用于整个请求。请参阅UnitOfWork文档以更好地理解它。

自定义返回值

还有一种额外的方法来提供IQueryable的能力，它可以在一个工作单元之外使用。

```
T Query<T>(Func<IQueryable<TEntity>, T> queryMethod);
```

Query方法接受lambda（或方法），该lambda（或方法）接收IQueryable<T>并返回任何类型的对象。例子：

```
var people = _personRepository.Query(q => q.Where(p => p.Name.Contains("H")).OrderBy(p => p.Name).ToList());
```
由于给定的lamda（或方法）是在repository方法中执行的，所以它是在数据库连接可用时执行的。可以返回实体列表、单个实体、投影或执行查询的其他内容。

### 新增

IRepository接口定义将实体插入数据库的方法：

```
TEntity Insert(TEntity entity);
Task<TEntity> InsertAsync(TEntity entity);
TPrimaryKey InsertAndGetId(TEntity entity);
Task<TPrimaryKey> InsertAndGetIdAsync(TEntity entity);
TEntity InsertOrUpdate(TEntity entity);
Task<TEntity> InsertOrUpdateAsync(TEntity entity);
TPrimaryKey InsertOrUpdateAndGetId(TEntity entity);
Task<TPrimaryKey> InsertOrUpdateAndGetIdAsync(TEntity entity);
```

Insert方法只需将新实体插入数据库并返回相同的插入实体。InsertAndGetId方法返回新插入实体的Id。如果Id是自动递增的，并且您需要新插入的实体的Id，这将非常有用。InsertOrUpdate插入或更新给定实体，方法是检查其Id的值。最后，InsertOrUpdateAndGetId在插入或更新后返回实体的Id。

### 更新

IRepository定义更新数据库中现有实体的方法。它获取要更新的实体并返回相同的实体对象。

```
TEntity Update(TEntity entity);
Task<TEntity> UpdateAsync(TEntity entity);
```

### 删除

IRepository定义从数据库中删除现有实体的方法
```
void Delete(TEntity entity);
Task DeleteAsync(TEntity entity);
void Delete(TPrimaryKey id);
Task DeleteAsync(TPrimaryKey id);
void Delete(Expression<Func<TEntity, bool>> predicate);
Task DeleteAsync(Expression<Func<TEntity, bool>> predicate);
```
第一个方法接受现有实体，第二个方法接受要删除的实体的Id。最后一个接受一个条件来删除所有符合给定条件的实体。请注意，所有匹配给定谓词的实体都可以从数据库中检索，然后删除（基于存储库实现）。因此，请谨慎使用，如果给定条件的实体太多，可能会导致性能问题。

### 其它

IRepository还提供了获取表中实体计数的方法。
```
int Count();
Task<int> CountAsync();
int Count(Expression<Func<TEntity, bool>> predicate);
Task<int> CountAsync(Expression<Func<TEntity, bool>> predicate);
long LongCount();
Task<long> LongCountAsync();
long LongCount(Expression<Func<TEntity, bool>> predicate);
Task<long> LongCountAsync(Expression<Func<TEntity, bool>> predicate);
```

### 关于Async(异步)方法

ASP.NET Boilerplate 支持异步编程模型。因此，存储库方法有异步版本。下面是一个使用异步模型的示例应用程序服务方法：

```
public class PersonAppService : AbpWpfDemoAppServiceBase, IPersonAppService
{
    private readonly IRepository<Person> _personRepository;

    public PersonAppService(IRepository<Person> personRepository)
    {
        _personRepository = personRepository;
    }

    public async Task<GetPeopleOutput> GetAllPeople()
    {
        var people = await _personRepository.GetAllListAsync();

        return new GetPeopleOutput
        {
            People = Mapper.Map<List<PersonDto>>(people)
        };
    }
}
```
GetAllPeople方法是异步的，并使用带有await关键字的GetAllListAsync。

并非所有ORM框架都支持异步。它由EntityFramework支持。如果不支持，异步存储库方法将同步工作。另外，例如，InsertAsync的工作原理与EntityFramework中的Insert相同，因为EF在工作单元完成之前不会向数据库写入新的实体（即。DbContext.SaveChanges).

## 管理数据库连接(Managing Database Connection)

数据库连接未在存储库方法中打开或关闭。连接管理由 ASP.NET Boilerplate。

数据库连接打开，事务在自动输入存储库方法时开始。当方法结束并返回时，保存所有更改，提交事务并自动关闭数据库连接ASP.NET Boilerplate。如果存储库方法抛出任何类型的异常，事务将自动回滚并关闭数据库连接。对于那些实现IRepository接口的类的所有公共方法来说都是如此。

若一个存储库方法调用另一个存储库方法（即使是不同存储库的方法），它们共享相同的连接和事务。连接由进入存储库的第一个方法管理（打开/关闭）。有关数据库连接管理的更多信息，请参阅UnitOfWork文档。

## 仓储的生命周期

所有存储库实例都是临时的。这意味着，它们是按用法实例化的。有关详细信息，请参阅依赖注入文档。

## 仓储的最佳实践(Repository Best Practices)

* 对于T的实体，尽可能使用IRepository<T>。除非确实需要，否则不要创建自定义存储库。对于许多情况，预定义的存储库方法就足够了。
* 如果要创建自定义存储库（通过扩展IRepository<TEntity>）;
1. 存储库类应该是无状态的。这意味着，您不应该定义存储库级别的状态对象，并且存储库方法调用不应影响另一个调用。
2. 自定义存储库方法不应包含业务逻辑或应用程序逻辑。它应该只执行与数据相关或orm特定的任务。  
3. 虽然存储库可以使用依赖注入，但定义的对其他服务的依赖性较少或没有。
