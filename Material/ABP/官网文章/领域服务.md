[TOC]

## 介绍

域服务（或者在DDD中只是服务）用于执行域操作和业务规则。埃里克·埃文斯（Eric Evans）在他的DDD书籍中描述了良好的服务的三个特点：

* 操作都是些领域大概念，而不是一个实体或者值对象的CRUD。
* 接口都是根据域模型定义
* 操作是无状态的

与获取/返回数据传输对象(Data Transfer Objects)的应用程序服务不同，域服务获取/返回域对象(Domain objects)（如实体或值类型）。

域服务可以由应用程序服务和其他域服务使用，但不能直接由表示层使用（应用程序服务就是为了这个目的）。

## 域服务接口与域服务类(IDomainService Interface and DomainService Class)

ASP.NET Boilerplate文件定义由所有域服务按惯例实现的IDomainService接口。当它被实现时，域服务被自动注册到依赖注入系统中作为临时的。
另外，域服务（可选）可以从DomainService类继承。因此，它可以利用某些继承属性的功能来记录日志、本地化等。。。当然，即使它没有继承，它也可以在需要时注入它们。

## 实例

假设我们有一个任务管理系统，并且在给一个人分配任务时有业务规则。

### 创建一个接口(Creating an Interface)

首先，我们为服务定义一个接口（不是必需的，但作为一种良好的实践）：

```
public interface ITaskManager : IDomainService
{
    void AssignTaskToPerson(Task task, Person person);
}
```
如您所见，TaskManager服务使用域对象：任务和人员。有一些命名域服务的约定。它可以是TaskManager、TaskService或TaskDomainService。。。

### 服务实现(Service Implementation)

```
public class TaskManager : DomainService, ITaskManager
{
    public const int MaxActiveTaskCountForAPerson = 3;

    private readonly ITaskRepository _taskRepository;

    public TaskManager(ITaskRepository taskRepository)
    {
        _taskRepository = taskRepository;
    }

    public void AssignTaskToPerson(Task task, Person person)
    {
        if (task.AssignedPersonId == person.Id)
        {
            return;
        }

        if (task.State != TaskState.Active)
        {
            throw new ApplicationException("Can not assign a task to a person when task is not active!");
        }

        if (HasPersonMaximumAssignedTask(person))
        {
            throw new UserFriendlyException(L("MaxPersonTaskLimitMessage", person.Name));
        }

        task.AssignedPersonId = person.Id;
    }

    private bool HasPersonMaximumAssignedTask(Person person)
    {
        var assignedTaskCount = _taskRepository.Count(t => t.State == TaskState.Active && t.AssignedPersonId == person.Id);
        return assignedTaskCount >= MaxActiveTaskCountForAPerson;
    }
}
```
我们有2个业务规则:

* 一个Task 应该在激活状态(Active state) ，才可以分配一个新人员
* 一个人最多拥有 3 个激活状态Task

您可能会想知道为什么我在第一次检查时抛出ApplicationException，在第二次检查时抛出UserFriendlyException（请参阅异常处理）。这与域服务完全无关。我这样做只是一个例子，完全取决于你。我认为用户界面必须检查任务的状态，不应该允许我们将任务分配给一个人。我认为这是一个应用程序错误，我们可以对用户隐藏它。第二种方法更难被UI检查，我们可以向用户显示可读的错误消息。只是举个例子。

### 使用应用程序服务(Application Service)

现在，让我们看看如何从应用程序服务中使用TaskManager：

```
public class TaskAppService : ApplicationService, ITaskAppService
{
    private readonly IRepository<Task, long> _taskRepository;
    private readonly IRepository<Person> _personRepository;
    private readonly ITaskManager _taskManager;

    public TaskAppService(IRepository<Task, long> taskRepository, IRepository<Person> personRepository, ITaskManager taskManager)
    {
        _taskRepository = taskRepository;
        _personRepository = personRepository;
        _taskManager = taskManager;
    }

    public void AssignTaskToPerson(AssignTaskToPersonInput input)
    {
        var task = _taskRepository.Get(input.TaskId);
        var person = _personRepository.Get(input.PersonId);

        _taskManager.AssignTaskToPerson(task, person);
    }
}
```

任务应用程序服务使用给定的DTO（输入）和存储库来检索相关的任务和人员，并将它们传递给任务管理器（域服务）。

## 一些讨论

根据上面的例子，您可能有一些问题。

### 为什么不仅仅是应用程序服务？

您可以说为什么应用程序服务没有在域服务中实现逻辑？

我们可以简单地说，这不是应用程序服务任务。因为这不是一个用例，而是一个业务操作。我们可以在不同的用例中使用相同的“向用户分配任务”域逻辑。假设我们可能有另一个屏幕来以某种方式更新任务，这个更新可以包括将任务分配给另一个人。所以，我们可以在那里使用相同的域逻辑。此外，我们可能有两个不同的UI（一个移动应用程序和一个web应用程序）共享同一个域，或者我们可能有一个用于远程客户端的web API，其中包括一个任务分配操作。

如果您的域很简单，将只有一个UI，并且将任务分配给一个人只需一个点，那么您可以考虑跳过域服务并在应用程序服务中实现逻辑。这不是DDD的最佳实践，但是ASP.NET Boilerplate 并不强迫你做这样的设计。

### 如何强制使用域服务？

您可以看到，应用程序服务可以做到：

```
public void AssignTaskToPerson(AssignTaskToPersonInput input)
{
    var task = _taskRepository.Get(input.TaskId);
    task.AssignedPersonId = input.PersonId;
}
```

开发人员编写应用程序服务时可能不知道有TaskManager，可以直接将给定的PersonId设置为任务的AssignedPersonId。那么，如何预防呢？基于此，在DDD领域有很多讨论，并有一些常用的模式。我们不会走得很深。但是，我们将提供一种简单的方法。

我们可以更改任务实体，如下所示：

```
public class Task : Entity<long>
{
    public virtual int? AssignedPersonId { get; protected set; }

    //...other members and codes of Task entity

    public void AssignToPerson(Person person, ITaskPolicy taskPolicy)
    {
        taskPolicy.CheckIfCanAssignTaskToPerson(this, person);
        AssignedPersonId = person.Id;
    }
}
```

我们将AssignedPersonId的setter改为protected。因此，它不能从这个任务实体类中更改。添加了一个接受person和任务策略的AssignToPerson方法。CheckIfCanAssignTaskToPerson方法检查它是否是有效的赋值，如果不是，则抛出一个适当的异常（它的实现在这里并不重要）。则应用服务方法如下：

```
public void AssignTaskToPerson(AssignTaskToPersonInput input)
{
    var task = _taskRepository.Get(input.TaskId);
    var person = _personRepository.Get(input.PersonId);

    task.AssignToPerson(person, _taskPolicy);
}
```
我们将ITaskPolicy注入为_taskPolicy并传递给AssignToPerson方法。现在，没有第二种方法可以把任务分配给一个人。我们应该始终使用AssignToPerson，不能跳过业务规则。
