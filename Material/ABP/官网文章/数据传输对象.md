[TOC]

数据传输对象用于在应用层和表示层之间传输数据。

表示层使用数据传输对象（DTO）调用应用程序服务方法，然后应用程序服务使用域对象执行某些特定的业务逻辑，并将DTO返回到表示层。所以，表示层和域层完全隔离。在理想的分层应用程序中，表示层不直接与域对象（存储库、实体…）一起工作。

## 需要DTOS的原因

首先，为每个应用程序创建一个DTO，服务方法可以被看作是一项冗长而耗时的工作。但是如果你正确地使用它，它们可以保存你的应用程序。为什么？

### 抽象的域层 (Abstraction of domain layer)

dto提供了一种从表示层抽象领域对象的有效方法。因此，你的层被正确地分开了。即使您想完全更改表示层，也可以继续使用现有的应用程序层和域层。相反，只要应用程序服务的契约（方法签名和dto）保持不变，您就可以重写域层，完全更改数据库模式、实体和O/RM框架，而不必更改表示层。

### 数据隐藏(Data hiding)

假设您有一个具有属性Id、Name、EmailAddress和Password字段的用户实体。如果UserAppService的GetAllUsers（）方法返回一个List<User>，那么任何人都可以看到所有用户的密码，即使您没有在屏幕上显示它。这不仅仅是安全问题，也是数据隐藏的问题。应用程序服务应该返回到表示层。不要多，不要少。

### 序列化 以及 懒加载问题(Serialization & lazy load problems)

当您将数据（对象）返回到表示层时，它可能在某个地方序列化了。例如，在返回JSON的MVC方法中，可以将对象序列化为JSON并发送到客户端。在这种情况下，将实体返回到表示层可能会有问题。怎么办？

在实际应用程序中，您的实体将相互引用。用户实体可以有对其角色的引用。所以，若要序列化用户，其角色也将被序列化。甚至角色类也可能有一个List<Permission>和PermissionGroup类的引用等等。。。你能认为所有这些对象都是序列化的吗？您很容易意外地序列化整个数据库。另外，如果对象有循环引用，则无法序列化。

解决办法是什么？将属性标记为非序列化？不，您不知道何时应该序列化它，什么时候不应该序列化。在一个应用程序服务方法中可能需要它，在另一个应用程序服务方法中可能不需要它。因此，在这种情况下，返回一个安全可序列化的、专门设计的dto是一个不错的选择。

几乎所有的O/RM框架都支持延迟加载。这是一个在需要时从数据库加载实体的功能。假设User类有对Role类的引用。从数据库中获取用户时，不会填充角色属性。当您第一次读取Role属性时，它是从数据库加载的。所以，若您将这样一个实体返回到表示层，它将导致从数据库检索额外的实体。如果序列化工具读取实体，它将递归地读取所有属性，并且可以再次检索完整的数据库（如果实体之间存在适当的关系）。

关于在表示层中使用实体，我们可以说一些更多的问题。最好不要将包含域（业务）层的程序集引用到表示层。

##  DTO 约定与验证 (DTO conventions & validation)

ASP.NET Boilerplate  大力支持DTO。它提供了一些常规的类和接口，并建议了一些关于dto的命名和使用约定。当你按照这里的描述写代码时，ASP.NET Boilerplate  可以轻松地自动化一些任务。

### 实例

让我们看一个完整的例子。假设我们要开发一个应用程序服务方法，该方法用于搜索具有姓名的人员并返回人员列表。在这种情况下，我们可能拥有如下所示的个人实体：

```
public class Person : Entity
{
    public virtual string Name { get; set; }
    public virtual string EmailAddress { get; set; }
    public virtual string Password { get; set; }
}
```
我们可以为我们的应用程序服务定义一个接口：

```
public interface IPersonAppService : IApplicationService
{
    SearchPeopleOutput SearchPeople(SearchPeopleInput input);
}
```
ASP.NET Boilerplate  建议将输入/输出参数命名为MethodNameInput和MethodNameOutput，并为每个应用程序服务方法定义一个单独的输入和输出DTO。即使您的方法只接受/返回一个参数，也最好创建一个DTO类。因此，您的代码将更具可扩展性。以后可以添加更多属性，而不必更改方法的签名，也不必破坏现有的客户端应用程序。

当然，如果没有返回值，您的方法可以返回void。如果稍后添加返回值，则不会中断现有应用程序。如果方法没有获取任何参数，则不必定义输入DTO。但是，如果将来有可能添加参数，那么最好将输入数据写入类。这取决于你。

让我们看看为这个例子定义的输入和输出DTO类：

```
public class SearchPeopleInput
{
    [StringLength(40, MinimumLength = 1)]
    public string SearchedName { get; set; }
}

public class SearchPeopleOutput
{
    public List<PersonDto> People { get; set; }
}

public class PersonDto : EntityDto
{
    public string Name { get; set; }
    public string EmailAddress { get; set; }
}
```

在执行方法之前，ASP.NET Boilerplate 会自动验证输入。类似于ASP.NETMVC的验证，但请注意，应用程序服务不是一个控制器，而是一个普通的C类。ASP.NET Boilerplate 自动截取和检查输入。关于验证还有很多。见[DTO验证](验证数据传输对象.md)文件。

EntityDto是一个声明Id属性的简单类，因为它们对于实体来说是通用的。如果实体的主键不是int，则具有泛型版本。您不必使用它，但最好定义一个Id属性。

正如您所见，PersonDto不包括Password属性，因为表示层不需要它。甚至将所有人的密码发送到表示层也是很危险的。假设是Javascript客户端请求的，任何人都可以轻松获取所有密码。

在进一步讨论之前，让我们先实现IPersonAppService。

```
public class PersonAppService : IPersonAppService
{
    private readonly IPersonRepository _personRepository;

    public PersonAppService(IPersonRepository personRepository)
    {
        _personRepository = personRepository;
    }

    public SearchPeopleOutput SearchPeople(SearchPeopleInput input)
    {
        //Get entities
        var peopleEntityList = _personRepository.GetAllList(person => person.Name.Contains(input.SearchedName));

        //Convert to DTOs
        var peopleDtoList = peopleEntityList
            .Select(person => new PersonDto
                                {
                                    Id = person.Id,
                                    Name = person.Name,
                                    EmailAddress = person.EmailAddress
                                }).ToList();

        return new SearchPeopleOutput { People = peopleDtoList };
    }
}
```
我们从数据库中获取实体，将它们转换为DTO并返回输出。请注意，我们没有验证输入。ASP.NET Boilerplate  验证了它。它甚至会检查输入参数是否为null，如果是，则抛出异常。这节省了我们在每个方法中编写保护子句的开销。

但是，您可能不喜欢将代码从Person实体转换为PersonDto对象。这真是一项乏味的工作。个人实体可以有更多的属性。

### DTOs 与 Entities 之间建立 AutoMapping 映射关系

幸运的是，有一些工具使这一切变得非常容易。AutoMapper 就是其中之一。请参阅[AutoMapper集成文档](对象映射.m)以了解如何使用它。

### 帮助接口以及帮助类(Helper interfaces and classes)

ASP.NET提供一些帮助器接口，这些接口可以实现通用DTO属性名称的标准化。

ILimitedResultRequest定义MaxResultCount属性。所以，您可以在输入DTO中实现它来标准化限制结果集。

IPagedResultRequest通过添加SkipCount扩展ILimitedResultRequest。因此，我们可以在SearchPeopleInput中实现分页：

```
public class SearchPeopleInput : IPagedResultRequest
{
    [StringLength(40, MinimumLength = 1)]
    public string SearchedName { get; set; }

    public int MaxResultCount { get; set; }
    public int SkipCount { get; set; }
}
```
作为分页请求的结果，您可以返回实现iHastTalCount的输出DTO。命名标准化帮助我们创建可重用的代码和约定。请参阅下面的其他接口和类__Abp.Application.Services.Dto__命名空间。
